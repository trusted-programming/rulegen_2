[
    {
        "hole_rule": "function checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function",
        "context": "function translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\n\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n",
        "after": " int color;\n\ninternal ColoredPoint (int x, int y) : this (x, y, WHITE) {\n}\n\ninternal ColoredPoint (int x, int y, int color) : base (x, y) {\n    this.color = color;\n}\n\n ",
        "before": "\nint color;\n\nColoredPoint (int x, int y) {\n    this (x, y, WHITE);\n}\n\nColoredPoint (int x, int y, int color) {\n    super (x, y);\n    this.color = color;\n}\n\n "
    },
    {
        "hole_rule": "function isFinal\n\tmatch [modifier]\n\t\t'final\nend function",
        "context": "function translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\n\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " internal FieldDeclaration () {\n    // unitialized final variable must be initialized in constructor\n    \n    f = 17.21f;\n}\n\n ",
        "before": "\nFieldDeclaration () {\n    // unitialized final variable must be initialized in constructor\n    \n    f = 17.21f;\n}\n\n "
    },
    {
        "hole_rule": "rule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule",
        "context": "rule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\n\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\n",
        "after": " public ",
        "before": "\n"
    },
    {
        "hole_rule": "function isFinal\n\tmatch [modifier]\n\t\t'final\nend function",
        "context": "function changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\n\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " static void throwOne () {\n    Console.WriteLine (\"Inside throwOne.\");\n    throw new IndexOutOfRangeException ();\n    //throw new NumberFormatException();}\n    \n}\n\n ",
        "before": "\nstatic void throwOne () throws ArrayIndexOutOfBoundsException {\n    System.out.println (\"Inside throwOne.\");\n    throw new ArrayIndexOutOfBoundsException ();\n    //throw new NumberFormatException();}\n    \n}\n\n "
    },
    {
        "hole_rule": "function changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function",
        "context": "function translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\n\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " {\n    lock (this) {\n        count ++;\n    }\n} ",
        "before": "\n{\n    synchronized (this) {\n        count ++;\n    }\n} "
    },
    {
        "hole_rule": "rule inference1a\n    replace [formula]\n        - ( - S [formula] '| - ( - S '| R [formula] ) ) \n    by\n        R\nend rule",
        "context": "function inference\n    replace [formula]\n        S [formula]\n    by\n        S [inference1a]\n          [inference1b]\nend function\n\nfunction simplifynot\n    replace [formula]\n        S [formula]\n    by\n        S [simplifynottrue]\n          [simplifynotfalse]\nend function\n\nfunction simplifyor\n    replace [formula]\n        S [formula]\n    by\n        S [simplifyor1]\n          [simplifyor2]\n          [simplifyor3]\n          [simplifyor4]\nend function\n\nfunction theorem10\n    replace [formula]\n        S [formula]\n    by\n        S [theorem10a]\n          [theorem10b]\nend function\n\nfunction theorem12\n    replace [formula]\n        S [formula]\n    by\n        S [theorem12a]\n          [theorem12b]\nend function\n\nfunction transitiveelimination\n    replace [formula]\n        S [formula]\n    by\n        S [transitiveelimination1]\n          [transitiveelimination2]\n          [transitiveelimination3]\n          [transitiveelimination4]\nend function\n\nfunction distributiveelimination\n    replace [formula]\n        S [formula]\n    by\n        S [distributiveelimination1]\n          [distributiveelimination2]\nend function\n\nfunction deductiveelimination\n    replace [formula]\n        S [formula]\n    by\n        S [deductiveelimination1]\n          [deductiveelimination2]\n          [deductiveelimination3]\n          [deductiveelimination4]\nend function\n\nrule axiom1\n    replace [formula]\n        ( - P [formula] '| - ( - P '| - P ) ) \n    by\n        true\nend rule\n\nrule axiom2\n    replace [formula]\n        ( ( - P [formula] '| - Q [formula] ) '| P ) \n    by\n        true\nend rule\n\nrule axiom3\n    replace [formula]\n        ( - ( - P [formula] '| Q [formula] ) '| ( - ( - Q '| - R [formula] ) '| ( - R '| - P ) ) ) \n    by\n        true\nend rule\n\nrule theorem1\n    replace [formula]\n        ( S [formula] '| - S )\n    by\n        true\nend rule\n\nrule theorem2\n    replace [formula]\n        ( - S [formula] '| S )\n    by\n        true\nend rule\n\nrule theorem3\n    replace [formula]\n        ( - ( Q [formula] '| R [formula] ) '| ( R '| Q ) ) \n    by\n        true\nend rule\n\nrule theorem4\n    replace [formula]\n        ( S [formula] '| - S )\n    by\n        true\nend rule\n\nrule theorem5\n    replace [formula]\n        ( - ( - Q [formula] '| P [formula] ) '| ( P '| - Q ) ) \n    by\n        true\nend rule\n\nrule theorem6\n    replace [formula]\n        ( ( - R [formula] '| - P [formula] ) '| - ( - P '| - R ) ) \n    by\n        true\nend rule\n\nrule theorem7\n    replace [formula]\n        ( - P [formula] '| P )\n    by\n        true\nend rule\n\nrule theorem8\n    replace [formula]\n        ( ( - R [formula] '| - P [formula] ) '| - ( - P '| - R ) ) \n    by\n        true\nend rule\n\nrule theorem9\n    replace [formula]\n        ( - ( - P [formula] '| - R [formula] ) '| ( - R '| - P ) ) \n    by\n        true\nend rule\n\nrule theorem11\n    replace [formula]\n        ( - ( P [formula] '| Q [formula] ) '| ( Q '| P ) ) \n    by\n        true\nend rule\n\nrule theorem13\n    replace [formula]\n        ( - ( - P [formula] '| ( - Q [formula] '| R [formula] ) ) '| ( ( - P '| - Q ) '| R ) ) \n    by\n        true\nend rule\n\nrule theorem14\n    replace [formula]\n        ( - ( ( - P [formula] '| - Q [formula] ) '| R [formula] ) '| ( - P '| ( - Q '| R ) ) ) \n    by\n        true\nend rule\n\nrule theorem15\n    replace [formula]\n        ( - P [formula] '| ( - Q [formula] '| - ( - P '| - Q ) ) ) \n    by\n        true\nend rule\n\nrule theorem16\n    replace [formula]\n        ( - P [formula] '| ( - Q [formula] '| P ) ) \n    by\n        true\nend rule\n\nrule theorem17\n    replace [formula]\n        ( ( - ( - P [formula] '| Q [formula] ) '| - ( - Q '| R [formula] ) ) '| ( - P '| R ) ) \n    by\n        true\nend rule\n\nrule theorem18\n    replace [formula]\n        ( ( - S [formula] '| R [formula] ) '| ( - R '| S ) ) \n    by\n        true\nend rule\n\nrule theorem19\n    replace [formula]\n        - ( - ( P [formula] '| Q [formula] ) '| - P )\n    by\n        true\nend rule\n\nrule theorem20\n    replace [formula]\n        - ( - ( Q [formula] '| P [formula] ) '| - P )\n    by\n        true\nend rule\n\nrule redundancyelimination\n    replace [formula]\n        ( P [formula] '| P )\n    by\n        P\nend rule\n\nrule doublenotelimination\n    replace [formula]\n        - - P [formula]\n    by\n        P\nend rule\n\n\n\nrule inference1b\n    replace [formula]\n        - ( - ( - S [formula] '| R [formula] ) '| - S ) \n    by\n        R\nend rule\n\nrule simplifynottrue\n    replace [formula]\n        - true\n    by\n        false\nend rule\n\nrule simplifynotfalse\n    replace [formula]\n        - false\n    by\n        true\nend rule\n\nrule simplifyor1\n    replace [formula]\n        ( false '| P [formula] )\n    by\n        P\nend rule\n\nrule simplifyor2\n    replace [formula]\n        ( P [formula] '| false )\n    by\n        P\nend rule\n\nrule simplifyor3\n    replace [formula]\n        ( true '| P [formula] )\n    by\n        true\nend rule\n\nrule simplifyor4\n    replace [formula]\n        ( P [formula] '| true )\n    by\n        true\nend rule\n\nrule theorem10a\n    replace [formula]\n        ( ( ( - P [formula] '| - Q [formula] ) '| - R [formula] ) '| - ( - P '| ( - Q '| - R ) ) ) \n    by\n        true\nend rule\n\nrule theorem10b\n    replace [formula]\n        ( ( - P [formula] '| ( - Q [formula] '| - R [formula] ) ) '| - ( ( - P '| - Q ) '| - R ) ) \n    by\n        true\nend rule\n\nrule theorem12a\n    replace [formula]\n        ( - ( ( P [formula] '| Q [formula] ) '| R [formula] ) '| ( P '| ( Q '| R ) ) ) \n    by\n        true\nend rule\n\nrule theorem12b\n    replace [formula]\n        ( - ( P [formula] '| ( Q [formula] '| R [formula] ) ) '| ( ( P '| Q ) '| R ) ) \n    by\n        true\nend rule\n\nrule transitiveelimination1\n    replace [formula]\n        - ( - ( - P [formula] '| Q [formula] ) '| - ( - Q '| R [formula] ) ) \n    where not\n        P [= R]\n    by\n        ( - P '| R )\nend rule\n\nrule transitiveelimination2\n    replace [formula]\n        - ( - ( - P [formula] '| Q [formula] ) '| - ( R [formula] '| - Q ) ) \n    where not\n        P [= R]\n    by\n        ( - P '| R )\nend rule\n\nrule transitiveelimination3\n    replace [formula]\n        - ( - ( Q [formula] '| - P [formula] ) '| - ( - Q '| R [formula] ) ) \n    where not\n        P [= R]\n    by\n        ( - P '| R )\nend rule\n\nrule transitiveelimination4\n    replace [formula]\n        - ( - ( Q [formula] '| - P [formula] ) '| - ( R [formula] '| - Q ) ) \n    where not\n        P [= R]\n    by\n        ( - P '| R )\nend rule\n\nrule distributiveelimination1\n    replace [formula]\n        - ( - - ( - P [formula] '| - Q [formula] ) '| - ( - Q '| R [formula] ) )\n    by\n        - ( - P '| - R )\nend rule\n\nrule distributiveelimination2\n    replace [formula]\n        - ( - - ( - Q [formula] '| - P [formula] ) '| - ( - Q '| R [formula] ) )\n    by\n        - ( - P '| - R )\nend rule\n\nrule deductiveelimination1\n    replace [formula]\n        ( - P [formula] '| - ( - P '| R [formula] ) ) \n    by\n        - R\nend rule\n\nrule deductiveelimination2\n    replace [formula]\n        ( - ( - P [formula] '| R [formula] ) '| - P ) \n    by\n        - R\nend rule\n\nrule deductiveelimination3\n    replace [formula]\n        ( - - ( - P [formula] '| - Q [formula] ) '| Q )\n    by\n        P\nend rule\n\nrule deductiveelimination4\n    replace [formula]\n        ( - - ( - Q [formula] '| - P [formula] ) '| Q )\n    by\n        P\nend rule\n\n",
        "after": " true ",
        "before": "\n(Z | - Z) "
    },
    {
        "hole_rule": "function toRight Pivot [id] N [id]\n    where not \n        N [< Pivot]\n    replace [id *] \n        List [id *]\n    by \n        N List\nend function",
        "context": "function toLeft Pivot [id] N [id]\n    where \n        N [< Pivot]\n    replace [id *] \n        List [id *]\n    by \n        N List\nend function\n\n\n\n",
        "after": " on of on of set small ",
        "before": "\nof on of set small "
    },
    {
        "hole_rule": "function before SL [stringlit]\n    replace [stringlit]\n\tScope [stringlit]\n    construct N [number]\n\t_ [index Scope SL]\n    construct NewN [number]\n\tN [- 1]\n    by\n\tScope [changeNull N]\n\t      [changeNOTNull 1 NewN]\nend function",
        "context": "function changeCStatement\n    replace [statement]\n\tS [statement]\n    construct NewS [statement]\n\tS [changeExprStatement]\n\t  [changeIfStatement]\n\t%% Loop statements\n\t  [changeDoWhileStatement]\n\t  [changeWhileStatement]\n\t  [changeForStatement]\n\t%% Jump statements\n\t  [changeReturnStatement]\n\t  [changeBreakStatement]\n    deconstruct not NewS\n\tS\n    by\n\tNewS\nend function\n\nfunction changeDoWhileStatement\n    replace [statement]\n\t'do\n\t    S [statement] \n\t'while '( E [expression] ') ';\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( E [changeExpression] ')\n    construct NewS [repeat statement]\n\tS \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'loop\n\t    NewBody [. exitCondition]\n\t'end 'loop\nend function\n\nfunction changeWhileStatement\n    replace [statement]\n\t'while '( E [expression] ') \n\t    S [statement]\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( E [changeExpression] ')\n    construct NewS [repeat statement]\n\tS \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'loop\n\t    exitCondition \n\t    NewBody\n\t'end 'loop\nend function\n\nfunction changeForStatement\n    replace [statement]\n\t'for '( I [expression] '; C [expression] '; S1 [expression] ') \n\t    S2 [statement]\n    construct InitStatement [statement]\n\tI\n    construct NewInitStatement [statement]\n\tInitStatement [changeCStatement]\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( C [changeExpression] ')\n    construct NewFinalStatement [repeat statement]\n\tS1\n    construct NewS [repeat statement]\n\tS2 \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets] [. NewFinalStatement]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'begin\n\t    NewInitStatement\n\t    'loop\n\t\texitCondition\n\t\tNewBody\n\t    'end 'loop\n\t'end\nend function\n\nfunction changeIfStatement\n    replace [statement]\n\t'if '( E [expression] ')\n\t    S [statement]\n\tOE [opt ELSEstatement]\n    construct NewS [repeat statement]\n\tS\n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'if E [changeExpression] 'then\n\t    NewBody\n\tOE [changeElse]\n\t'end 'if\nend function\n\nfunction changeReturnStatement\n    replace [statement]\n\t'return E [expression] ';\n    by\n\t'result E [changeExpression]\nend function\n\nfunction changeBreakStatement\n    replace [statement]\n\t'break ';\n    by\n\t'exit\nend function\n\nrule changeExprStatement\n    replace [statement]\n\tES [expression_statement] \n    construct NewES [expression_statement]\n\tES [removeSemiColon]\n\t   [removeAmpersand]\n\t   [changeAssignment]\n\t   [changeBasicPrintf]\n\t   [changeComplexPrintf]\n\t   [changeBasicScanf]\n\t   [changeStrCopy]\n\t   [changeStrCat]\n\t   [changePrePlusPlus]\n\t   [changePostPlusPlus]\n\t   [changePreMinusMinus]\n\t   [changePostMinusMinus]\n\t   [changeArrayBrackets]\t\t%% changeArrayBrackets defined in expr_t.C\n    deconstruct not NewES\n\tES\n    by\n\tNewES \nend rule\n\nfunction removeBrackets\n    replace [repeat statement]\n\t'{\n\t    RS [repeat statement]\n\t'}\n    by\n\tRS\nend function\n\nrule changeExpression\n    construct COps [repeat binary_operator]\n        '== '!= '&& '|| '%\n    construct TuringOps [repeat binary_operator]\n    \t'= 'not= 'and 'or 'mod\n    replace [expression]\n\tE [expression]\n    construct NewE [expression]\n\tE [changeOp each COps TuringOps]\n\t  [changeArrayBrackets]\n    deconstruct not NewE\n\tE \n    by\n\tNewE \nend rule\n\nrule changeElse\n    replace [ELSEstatement]\n\t'else 'if '( E [expression] ')\n\t    S [statement]\n\tOE [opt ELSEstatement]\n    construct NewS [repeat statement]\n\tS\n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'elsif E [changeExpression] 'then\n\t    NewBody\n\tOE [changeElse]\nend rule\n\nfunction removeSemiColon\n    replace [expression_statement]\n\tE [expression] ';\n    by\n\tE [changeExpression]\nend function\n\nfunction removeAmpersand\n    replace * [cast_expression]\n\t'& CE [cast_expression]\n    by\n\tCE\nend function\n\nfunction changeAssignment\n    replace [expression_statement]\n\tCE1 [cast_expression] '= CE2 [cast_expression] RBO [repeat binary_operation]\n    by\n\tCE1 ':= CE2 RBO\nend function\n\nfunction changeBasicPrintf\n    replace [expression_statement]\n\t'printf '( SL[stringlit] ')\n    by\n\t'put SL '..\nend function\n\nfunction changeComplexPrintf\n    replace [expression_statement]\n\t'printf '( LE [list assignment_expression+] ')\n    construct repeatExpr [repeat assignment_expression]\n\t_ [. each LE]\n    deconstruct repeatExpr\n\tSL [stringlit] Rest [repeat assignment_expression]\n    construct NewArgList [list putArg]\n\t_ [translatePutArgs SL Rest]\t\t\t\n    construct putStatement [expression_statement]\n\t'put NewArgList [removeEmptyArg] '..\n    by\n\tputStatement [removeOptDotDot]\nend function\n\nfunction changeBasicScanf\n    replace [expression_statement]\n\t'scanf '( LE [list assignment_expression+] ')\n    construct repeatExpr [repeat assignment_expression]\n\t_ [. each LE]\n    deconstruct repeatExpr\n\tSL [stringlit] Rest [repeat assignment_expression]\n    construct listExpr [list assignment_expression]\n\t_ [, each Rest]\n    by\n\t'get listExpr\nend function\n\nfunction changeStrCopy\n    replace [expression_statement]\n\tES [expression_statement]\n    by\n\tES [changeCopyWithLiteral]\n\t   [changeCopyWithIdentifier]\nend function\n\nfunction changeStrCat\n    replace [expression_statement]\n\tES [expression_statement]\n    by\n\tES [changeCatWithLiteral]\n\t   [changeCatWithIdentifier]\nend function\n\nfunction changePrePlusPlus\n    replace [expression_statement]\n\t'++ ID [identifier]\n    by\n\tID ':= ID '+ 1\nend function\n\nfunction changePostPlusPlus\n    replace [expression_statement]\n\tID [identifier] '++ \n    by\n\tID ':= ID '+ 1\nend function\n\nfunction changePreMinusMinus\n    replace [expression_statement]\n\t'-- ID [identifier]\n    by\n\tID ':= ID '- 1\nend function\n\nfunction changePostMinusMinus\n    replace [expression_statement]\n\tID [identifier] '-- \n    by\n\tID ':= ID '- 1\nend function\n\nfunction changeArrayBrackets\n    replace * [unary_expression]\n\tPE [primary_expression] '[ E [expression] ']\n    by\n\tPE '( E ')\nend function\n\nfunction changeOp COp [binary_operator] TuringOp [binary_operator]\n    replace * [binary_operator]\n\tCOp\n    by\n\tTuringOp\nend function\n\nfunction translatePutArgs SL [stringlit] RAE [repeat assignment_expression]\t\t\t\n    replace [list putArg]\n\tSoFar [list putArg]\n    construct beforePercent [stringlit]\t\t% get everything before the next percent\n\tSL [before \"%\"] [replaceEmpty SL RAE]\n    construct NewSL [putArg]\n\tbeforePercent\n    where not\t\t\t\t\t% terminating condition\n\tbeforePercent [?replaceEmpty SL RAE]\n    construct afterPercent [stringlit]\t\t% get everything after the percent sign\n\tSL [after \"%\"]\n    construct restSL [stringlit]\t\t% skip the next character\n\tafterPercent [: 2 9999] \t\t% 2nd to last character\n    construct RestAE [repeat assignment_expression]\n\t_ [getRest RAE]\n    construct recurse [list putArg]\n\t_ [translatePutArgs restSL RestAE]  \n    by\n\tSoFar [, NewSL] [addAE RAE] [, recurse]\nend function\n\nfunction removeEmptyArg\n    replace * [list_1_putArg]\n\t\"\" ', Tail [list_1_putArg]\n    by\n\tTail \nend function\n\nfunction removeOptDotDot\n    replace [expression_statement]\n\t'put LPA [list putArg] '..\n    construct NewLPA [list putArg]\n\tLPA [removeNewline]\n    %%deconstruct not NewLPA \n    \t%%LPA\n    by\n\t'put NewLPA\nend function\n\nfunction changeCopyWithLiteral\n    replace [expression_statement]\n\t'strcpy '( N [identifier] ', SL [stringlit] ')\n    by\n\tN ':= SL\nend function\n\nfunction changeCopyWithIdentifier\n    replace [expression_statement]\n\t'strcpy '( N [identifier] ', N2 [identifier] ')\n    by\n\tN ':= N2\nend function\n\nfunction changeCatWithLiteral\n    replace [expression_statement]\n\t'strcat '( N [identifier] ', SL [stringlit] ')\n    by\n\tN ':= N '+ SL\nend function\n\nfunction changeCatWithIdentifier\n    replace [expression_statement]\n\t'strcat '( N [identifier] ', N2 [identifier] ')\n    by\n\tN ':= N '+ N2\nend function\n\nfunction replaceEmpty restSL [stringlit] RAE [repeat assignment_expression]\n    replace [stringlit]\n\t\"\"\n    where not\n\tRAE [?notEmpty]\n    by\n\trestSL\nend function\n\nfunction addAE RAE [repeat assignment_expression]\n    deconstruct RAE\n\tAE [assignment_expression] RestAE [repeat assignment_expression]\n    replace [list putArg]\n\tLPA [list putArg]\n    construct NewPA [putArg]\n\tAE\n    by\n\tLPA [, NewPA]\nend function\n\nfunction getRest RAE [repeat assignment_expression]\n    replace [repeat assignment_expression]\n\tRest [repeat assignment_expression]\n    deconstruct RAE\n\tAE [assignment_expression] RestAE [repeat assignment_expression]\n    by\n\tRestAE\nend function\n\n\n\nfunction after SL [stringlit]\n    replace [stringlit]\n\tScope [stringlit]\n    construct N [number]\n\t_ [index Scope SL]\n    construct NewN [number]\n\tN [+ 1]\n    by\n\tScope [changeNull N]\n\t      [changeNOTNull NewN 9999]\nend function\n\nfunction removeNewline\n    replace * [list putArg]\n\tS [stringlit]\n    by\n\t% nothing\nend function\n\nfunction changeNull N [number]\n    replace [stringlit]\n\tSL [stringlit]\n    where\n\tN [<= 1]\n    by\n\t\"\"\nend function\n\nfunction changeNOTNull N1 [number] N2 [number]\n    replace [stringlit]\n\tSL [stringlit]\n    by\n\tSL [: N1 N2]\nend function\n\n",
        "after": " x := 10\ny := 5\nloop\n    z := x + y\n    if z > 10 then\n        x := x - 1\n    end if\n    put z \n    y := y - 1\n    exit when not (y not= 0)\nend loop\nbegin\n    x := 1\n    loop\n        exit when not (x < 10)\n        z := z + y\n        x := x + 1\n    end loop\nend\n ",
        "before": "\nx := 10\ny := 5\nloop\n    z := x + y\n    if z > 10 then\n        x := x - 1\n    end if\n    put z \n    y := y - 1\n    exit when not (y not= 0)\nend loop\n "
    },
    {
        "hole_rule": "rule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule",
        "context": "function translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\n\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n",
        "after": " internal ColoredPoint (int x, int y, int color) : base (x, y) {\n    this.color = color;\n}\n\n ",
        "before": "\nColoredPoint (int x, int y, int color) {\n    super (x, y);\n    this.color = color;\n}\n\n "
    },
    {
        "hole_rule": "function doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function",
        "context": "function translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\n\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " public static void Main (String [] args) {\n    bool flag = true;\n    const int y = 6;\n    double X = Math.random ();\n    int DAYS_IN_YEAR;\n    if (flag) DAYS_IN_YEAR = 366;\n    else DAYS_IN_YEAR = 365;\n\n}\n\n ",
        "before": "\npublic static void main (String [] args) {\n    boolean flag = true;\n    final int y = 6;\n    final double X = Math.random ();\n    final int DAYS_IN_YEAR;\n    if (flag) DAYS_IN_YEAR = 366;\n    else DAYS_IN_YEAR = 365;\n\n}\n\n "
    },
    {
        "hole_rule": "function addExpToTclCmdList Expr [expression]\n    replace [tcl_cmd_list]\n\tTclExpr [tcl_expr] TclCmdMore [repeat tcl_cmd_more]\n    construct TclCmdMore2 [tcl_cmd_more]\n\t'; Expr\n    by\n\tTclExpr TclCmdMore [. TclCmdMore2]\nend function",
        "context": "function addClassMetaAndClass\n    replace * [package_declaration]\n\tCmts [repeat comment_NL] \n\tPkgHead [opt package_header]\n\tImpDecl [repeat import_declaration] \n\tTypeDecl [repeat type_declaration]\n    deconstruct TypeDecl \n\t_ [repeat modifier] 'class ClassName [id] \n\tExtends [opt extends_clause] Implements [opt implements_clause] \n\t_ [class_body]\n\t_ [repeat type_declaration]\n    construct MetaClassName [id]\n\tClassName [_ 'metapapa]\n    construct ExtendClasses [repeat reference]\n\t_ [^ Extends]\n    construct Parents [repeat reference]\n\tExtendClasses [removeNonIdRef]\n    construct TclParents [repeat tcl_id]\n\t_ [pkgRef2TclId each Parents]\n    by\n\tCmts PkgHead ImpDecl \n\t'Class 'create MetaClassName '-superclass '{ 'Class '} '-slots '{ '}\n\tMetaClassName 'create ClassName '-superclass '{ 'Class TclParents '} \n\t'-slots '{ '}\n\tTypeDecl\nend function\n\nfunction constructorTransforms\n    replace [program]\n\tP [program]\n    by\n\tP [transformThisInConstructor] [transformSuperInConstructors]\nend function\n\nfunction transformExpressions\n    replace [program]\n\tP [program]\n    by\n\tP \n\t  [transformNewExpr]\n\n\t  [transformExceptions]\n\t  [transformConditionalStatements]\n\n\t  [transformVarAssignment]\n\n\n\t  [convertUnaryOpFirst]\n\t  [convertUnaryOpInMultiplicative]\nend function\n\nrule transformDefaultAttributes\n    replace [field_declaration]\n\t_ [repeat modifier] _ [type_specifier] Name [id] _ [opt generic_parameter] \n\t'= Literal [literal] '; \n    by\n\t'Attribute Name '-default Literal \nend rule\n\nrule transformInitAttributesNew\n    replace [field_declaration]\n\t_ [repeat modifier] _ [type_specifier] Name [id] _ [opt generic_parameter] \n\t'= New [class_instance_creation_expression] ';\n    construct NewCmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    by\n\t'Attribute Name '-initcmd '{ NewCmd '}\nend rule\n\nrule teleportClassStaticAttributes\n    replace $ [repeat type_declaration]\n\t%MetaClass\n\tMetaBase [id] MetaCreate [opt 'create] MetaClassName [id] MetaSuper [opt xotcl_class_superclasses]\n\t'-slots '{ '}\n\t%Class\n\tClassBase [id] ClassCreate [opt 'create] ClassName [id] ClassSuper [opt xotcl_class_superclasses]\n\t'-slots '{ '}\n\t%Java Class\n\tJClassHeader [class_header] JBody [class_or_interface_body]\n\t_ [repeat type_declaration]\n    construct JBodyElements [repeat class_body_declaration]\n\t_ [^ JBody]\n    construct JFields [repeat field_declaration]\n\t_ [^ JBody]\n    by\n\tMetaBase MetaCreate MetaClassName MetaSuper '-slots '{ JFields [removeNonStaticField] '}\n\tClassBase ClassCreate ClassName ClassSuper '-slots '{ JFields [removeStaticField] '}\n\tJClassHeader JBody \nend rule\n\nrule teleportClassStaticMethods\n    replace $ [repeat type_declaration]\n\t%Class\n\tClassBase [xotcl_class]\n\t%Java Class\n\tJClass [class_header] JBody [class_or_interface_body]\n\t_ [repeat type_declaration]\n    construct JMethods [repeat method_or_constructor_declaration]\n\t_ [^ JBody]\n    construct InstanceMethods [repeat method_or_constructor_declaration]\n\tJMethods [transformNonStaticMethod2Proc]\n    by\n\tClassBase\n\tJMethods [transformStaticMethod2Proc] [. InstanceMethods]\nend rule\n\nrule transformMethodsHeaders\n    replace $ [xotcl_class_with_methods]\n\tClass [xotcl_class]\n\tMethods [repeat method_or_constructor_declaration]\n    deconstruct Class\n\t_ [id] _ [opt 'create] \n\tName [id] _ [opt xotcl_class_superclasses] _ [opt xotcl_class_slots] \n    by\n\tClass\n\tMethods [transformNonStaticMethodHeader Name] \n\t\t[transformStaticMethodHeader Name]\n\t\t[transformSynchroNonStaticMethodHeader Name] \n\t\t[transformSynchroStaticMethodHeader Name]\n\t\t[transformConstructorHeader]\nend rule\n\nrule transformParameterVarRefs\n    replace $ [repeat method_or_constructor_declaration]\n \tMethod [method_or_constructor_declaration]\n \tMethods [repeat method_or_constructor_declaration]\n    deconstruct Method\n\t_ [id] _ [xotcl_proc_scope] _ [id] '{ VarIds [repeat id] '} _ [tcl_cmd_set]\n    by\n\tMethod [transformJavaVar2TclVar VarIds]\n\tMethods \nend rule\n\nrule transformDotRefs\n    replace [program]\n\tP [program]\n    where \n\tP [?transformRefMethodFirst1]\n\t  [?transformRefMethodFirst1In]\n\t  \n\t  [?transformRefMethodFirst]\n\t  [?transformRefMethod]\n\t  [?transformRefIdFirst]\n\t  [?transformRefId]\n\t  [?transformRefArray]\n    by \n\tP  [transformRefMethodFirst1]\n\t   [transformRefMethodFirst1In]\n  \n\t   [transformRefMethodFirst]\n\t   [transformRefMethod]\n\n\t   [transformRefIdFirst]\n\t   [transformRefId]\n\t   [transformRefArray] \nend rule\n\nrule varRef2TclRef\n    replace $ [reference]\n\tRef [reference]\n    construct RefNew [reference]\n\tRef [varRef2TclClassVar Ref]\n\t    [varRef2TclClassStaticVar Ref]\n\t    [varRef2TclVarSimple Ref]\n\t    [varRefThis2TclThis Ref]\n    by\n\tRefNew\nend rule\n\nrule untransformForUpdate\n    replace $ [tcl_for_cmd]\n\t'for Init [tcl_cmd_set] Cond [tcl_cmd_set] Upd [tcl_cmd_set] Block [tcl_block]\n    by\n\t'for Init Cond Upd [untransformForUpdateMores] Block \nend rule\n\nfunction pkgRef2TclId Ref [reference]\n    replace [repeat tcl_id]\n\t_ [repeat tcl_id]\n    construct RefIds [repeat id]\n\t_ [^ Ref]\n    deconstruct RefIds\n\tFirstId [id] RestId [repeat id]\n    construct TclIdHead [tcl_id_head]\n\tFirstId\n    construct TclIdPart [repeat tcl_id_part]\n\t_ [addTclIdPart each RestId]\n    by\n\tTclIdHead TclIdPart\nend function\n\nrule removeNonIdRef\n    replace [repeat reference]\n\tFirst [reference] Rest [repeat reference]\n    deconstruct First\n\tPrima [primitive_type] _ [repeat dimension] _ [repeat component]\n    by\n\tRest\nend rule\n\nrule transformSuperInConstructors\n    replace $ [constructor_declaration]\n\tConstructor [constructor_declaration]\n    by\n\tConstructor [addSuperInConstructorIfAbsent Constructor]\n\t\t    [transformSuperInConstructor Constructor]\n\t\t    [removeSuperInConstructor]\nend rule\n\nrule transformThisInConstructor \n    replace $ [constructor_declaration]\n\tConstructor [constructor_declaration]\n    by\n\tConstructor [transformThisStatement Constructor]\nend rule\n\nrule transformVarAssignment\n    replace [declaration_or_statement]\n\t Ref [reference] '= Butt [assignment_expression] ';\n    construct TclCmd [repeat tcl_expr_more]\n\t_ [transformJavaLocalScopeVar Ref] \n\n\t  [transformJavaClassVar Ref] \n\t  [transformJavaClassStaticVar Ref] \n\n\t  [transformJavaThisVar Ref] \n\t  [transformJavaThisStaticVar Ref] \n\n\t  [complexRefAssignment Ref]\n\t  [assignToArrayRef Ref]\n    construct TclLit [tcl_expr_more]\n\t_ [transformArithAssExp Butt]\n\t  [transformLiteralAssExp Butt]\n\t  [transformRefAssExp Butt]\n\t  [transformNewAssExp Butt]\n    by\n\tTclCmd [. TclLit] '%\nend rule\n\nrule transformExceptions\n    replace $ [program]\n\tP [program]\n    by\n\tP [transformThrowStmt]\n\t  [transformTryCatch]\nend rule\n\nrule transformConditionalStatements\n    replace $ [program]\n\tP [program]\n    by\n\tP [transformIfElse]\n\t  [transformIf]\n%\t  [transformCondChoice]\n\t  [transformWhile]\n\t  [transformSwitch]\n\t  [transformFor]\n\t  [transformForeach]\nend rule\n\nrule convertUnaryOpInMultiplicative\n    replace $ [multiplicative_expression]\n\tMulti [multiplicative_expression]\n    deconstruct Multi\n\tRef [id] Op [pre_inc_dec]\n    by\n\tMulti [convertUnaryOpMultiMy]\n\t      [convertUnaryOpMultiClass]\n\t      [convertUnaryOpMultiLocal]\nend rule\n\nrule convertUnaryOpFirst\n    replace $ [declaration_or_statement]\n\tDecl [declaration_or_statement]\n    deconstruct Decl\n\tRef [id] Op [pre_inc_dec] ';\n    by\n\tDecl [convertUnaryOpFirstMy]\n\t     [convertUnaryOpFirstClass]\n\t     [convertUnaryOpFirstLocal]\nend rule\n\nrule transformNewExpr\n    replace $ [multiplicative_expression]\n\tNew [class_instance_creation_expression]\n    construct Cmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    deconstruct Cmd\n\t'[ Expr [tcl_expr] ']\n    by\n\t'[ Expr ']\nend rule\n\nfunction convertNewClassInstance New [class_instance_creation_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct New\n\t'new JClassName [reference] '( Args [list argument] ') _ [opt class_body]\n    construct TmpName [repeat tcl_id]\n\t_ [pkgRef2TclId JClassName]\n    deconstruct * TmpName\n\tClassName [tcl_id]\n    construct Args1 [repeat expression]\n\t_ [argumentToExpression each Args]\n    construct TclArgs [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args1]\n    by\n\t'[ ClassName ClassName TclArgs ']\nend function\n\nrule removeStaticField\n    replace [repeat field_declaration]\n\tFirst [field_declaration] Rest [repeat field_declaration]\n    where \n\tFirst [is_static]\n    by\n\tRest\nend rule\n\nrule removeNonStaticField\n    replace [repeat field_declaration]\n\tFirst [field_declaration] Rest [repeat field_declaration]\n    where not\n\tFirst [is_static]\n    by\n\tRest\nend rule\n\nrule transformStaticMethod2Proc\n    replace  [repeat method_or_constructor_declaration]\n\tMethod [method_or_constructor_declaration] \n\tMethods [repeat method_or_constructor_declaration]\n    where not\n\tMethod [is_static]\n    by\n\tMethods\nend rule\n\nrule transformNonStaticMethod2Proc\n    replace  [repeat method_or_constructor_declaration]\n\tMethod [method_or_constructor_declaration] \n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tMethod [is_static]\n    by\n\tMethods\nend rule\n\nrule transformNonStaticMethodHeader ClassName [id]\n    replace [method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n    where not\n\tJModifiers [is_synchronized]\n    where not\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    by\n\tClassName 'instproc JName '{ ParamsNames '}  Body\nend rule\n\nrule transformStaticMethodHeader ClassName [id]\n    replace [method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n    where not\n\tJModifiers [is_synchronized]\n    where\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    by\n\tClassName 'proc JName '{ ParamsNames '}  Body\nend rule\n\nrule transformSynchroNonStaticMethodHeader ClassName [id]\n    replace [repeat method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tJModifiers [is_synchronized]\n    where not\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n    construct JSynchName [id]\n\tJName [_ 'synchrobaby]\n    construct MutexName [id]\n\tClassName [_ JName] [_ 'mutex]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'thread::mutex 'lock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'set 'cought 0 '%\n\t'#call the real method implementation\n\t'if '{ '[ 'catch '{ 'my JSynchName ParamsAsVars '} 'result '] '} '{\n\t'set 'cought 1 '%\n\t'} \n\t'thread::mutex 'unlock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'#transfer exception to the upper level\n\t'if '{ '$cought '} '{ 'error '$result '} \n\t'}\n    by\n\tClassName 'instproc JName '{ ParamsNames '} ProcBody \n\tClassName 'instproc JSynchName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformSynchroStaticMethodHeader ClassName [id]\n    replace [repeat method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tJModifiers [is_synchronized]\n    where\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n    construct JSynchName [id]\n\tJName [_ 'synchrobaby]\n    construct MutexName [id]\n\tClassName [_ JName] [_ 'mutex]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'thread::mutex 'lock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'set 'cought 0 '%\n\t'#call the real method implementation\n\t'if '{ '[ 'catch '{ 'my JSynchName ParamsAsVars '} 'result '] '} '{\n\t'set 'cought 1 '%\n\t'} \n\t'thread::mutex 'unlock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'#transfer exception to the upper level\n\t'if '{ '$cought '} '{ 'error '$result '} \n\t'} \n    by\n\tClassName 'proc JName '{ ParamsNames '} ProcBody \n\tClassName 'proc JSynchName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformConstructorHeader\n    replace [repeat method_or_constructor_declaration]\n \tConstructor [constructor_declaration]\n \tMethods [repeat method_or_constructor_declaration]\n    deconstruct Constructor\n\tJModifiers [repeat modifier] \n\tJClassName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') \n\t_ [opt throws] Body [block]\n\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n\n    construct ParamsString [id]\n\t_ [buildParameterTypeList each Parameters]\n    construct XNew [id]\n\t_ [+ JClassName] \n    construct XNewBody [id]\n\t_ [+ JClassName] [+ \"_body\"]\n    construct XNewName [id]\n\tXNew [+ ParamsString]\n    construct XNewBodyName [id]\n\tXNewBody [+ ParamsString]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'#create new object\n\t'set 'obj '[ JClassName 'new '] '%\n\t'#call the constructor\n\t'$obj XNewBodyName ParamsAsVars '%\n\t'#return new object after constructor's work is done\n\t'return '$obj '%\n\t'} \n    by\n\tJClassName 'proc XNewName '{ ParamsNames '} ProcBody\n\tJClassName 'instproc XNewBodyName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformJavaVar2TclVar VarIds [repeat id]\n    replace $ [reference]\n\tId [id] _ [repeat dimension] Comp [repeat component]\n    construct Len [number]\n\t_ [length Comp]\n    where \n\tLen [= 0]\n    where\n\tId [= each VarIds]\n    by\n\t'$ Id\nend rule\n\nrule transformRefMethodFirst1\n    replace [declaration_or_statement]\n\tId [id] _ [repeat dimension] Comps [repeat component] ';\n    construct CompsLen [number]\n\t_ [length Comps]\n    where \n\tCompsLen [= 1]\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'my Id Exps '%\nend rule\n\nrule transformRefMethodFirst1In\n    replace [reference]\n\tId [id] _ [repeat dimension] Comps [repeat component] \n    construct CompsLen [number]\n\t_ [length Comps]\n    where \n\tCompsLen [= 1]\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'[ 'my Id Exps '] \nend rule\n\nrule transformRefMethodFirst\n    replace [declaration_or_statement]\n\tId [id] Dims [repeat dimension] Comps [repeat component] ';\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct CompsLenFinal [number]\n\t_ [length Comps] [- 2]\n    construct NewCompsTmp [repeat component]\n\tComps [head CompsLen]\n    construct NewComps [repeat component]\n\tComps [head CompsLenFinal]\n    construct RefIds [repeat id]\n\t_ [^ NewCompsTmp]\n    deconstruct * RefIds\n\tMethodName [id]\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\tId [this2my] Dims NewComps MethodName Exps '%\nend rule\n\nrule transformRefMethod\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct CompsLenFinal [number]\n\t_ [length Comps] [- 2]\n    construct NewCompsTmp [repeat component]\n\tComps [head CompsLen]\n    construct NewComps [repeat component]\n\tComps [head CompsLenFinal]\n    construct RefIds [repeat id]\n\t_ [^ NewCompsTmp]\n    deconstruct * RefIds\n\tMethodName [id]\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'[ Id [this2my] Dims NewComps MethodName Exps '] \nend rule\n\nrule transformRefIdFirst\n    replace [declaration_or_statement]\n\tId [id] _ [repeat dimension] Comps [repeat component] '= AssExp [assignment_expression] ';\n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    by\n\tId NewComps 'set VarId AssExp '%\nend rule\n\nrule transformRefId\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps\n    by\n\t'[ NewRef 'set VarId ']\nend rule\n\nrule transformRefArray\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\tDim [dimension]\n\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n\n\n    deconstruct * NewComps\n\t'. VarId [id]\n    construct CompsLen2 [number]\n\t_ [length NewComps] [- 1]\n    construct DimComp [component]\n\tDim\n    construct NewComps2 [repeat component]\n\tNewComps [head CompsLen2] % [. DimComp]\n\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps2 \n\n    construct TmpDims [repeat dimension]\n\tDim\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim TmpDims]\n\n    by\n\t'[ NewRef 'set VarId TclDim ']\nend rule\n\nfunction varRef2TclClassVar Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where \n\tId [is_class_var]\n    by\n\t'[ 'my 'set Id TclDim ']\nend function\n\nfunction varRef2TclClassStaticVar Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ '[ 'my 'class '] 'set Id TclDim ']\nend function\n\nfunction varRef2TclVarSimple Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where all \n\tId [>= 'a] [<= 'z]\n    where not\n\tId [is_staticclass_var]\n\t   [is_class_var]\n    deconstruct not Id\n\t'my\n    by\n\t'$ Id TclDim\nend function\n\nfunction varRefThis2TclThis Ref [reference]\n    deconstruct Ref\n\t'this\n    replace [reference]\n\t_ [reference]\n    by\n\t'[ 'self ']\nend function\n\nrule untransformForUpdateMores\n%    skipping [tcl_expr_more]\n    replace $ [tcl_expr]\n\tExp [tcl_expr]\n    deconstruct Exp\n\tRef [reference]\n    deconstruct Ref\n\t'[ More [tcl_expr] ']\n    by\n\tMore\nend rule\n\nfunction addTclIdPart Id [id]\n    replace [repeat tcl_id_part]\n\tParts [repeat tcl_id_part]\n    construct Part [tcl_id_part]\n\t':: Id\n    by\n\tParts [. Part]\nend function\n\nrule addSuperInConstructorIfAbsent Constructor [constructor_declaration] \n    replace $ [constructor_body]\n\t'{ Decls [repeat declaration_or_statement] '}\n    where not\n\tDecls [?transformSuperInConstructor Constructor]\n    by\n\t'{\n\t'super '( ') ';\n\tDecls '}\nend rule\n\nrule transformSuperInConstructor Constructor [constructor_declaration] \n    replace $ [declaration_or_statement]\n\t'super MethArg [method_argument] ';\n    import JClassOrigin [class_declaration]\n    deconstruct JClassOrigin\n\t_ [repeat modifier] 'class _ [class_name] \n\tExtends [opt extends_clause] \n\t_ [opt implements_clause] _ [class_body]\n    construct ExtendClasses [repeat reference]\n\t_ [^ Extends]\n    construct Parents [repeat reference]\n\tExtendClasses [removeNonIdRef]\n    deconstruct * ExtendClasses \n\tParentName [id]\n    construct Args [repeat expression]\n\t_ [^ MethArg]\n    construct VarIds [repeat id]\n\t_ [^ Args]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    construct TypeString [id]\n\t_ [buildVarsTypeList4Constructor Constructor each VarIds]\n    construct XNewName [id]\n\t_ [+ ParentName] [+ \"_body\"] [+ TypeString]\n    by\n\t'my XNewName Exps '% \nend rule\n\nrule removeSuperInConstructor \n    replace [repeat declaration_or_statement]\n\t'super MethArg [method_argument] ';\n\tDecls [repeat declaration_or_statement]\n    by\n\tDecls\nend rule\n\nrule transformThisStatement Constructor [constructor_declaration] \n    replace $ [declaration_or_statement]\n\t'this MethArg [method_argument] ';\n    deconstruct Constructor\n\t_ [repeat modifier] ClassName [id] _ [opt generic_parameter]\n\t'( _ [list formal_parameter] ')  _ [opt throws] _ [constructor_body]\n    construct Args [repeat expression]\n\t_ [^ MethArg]\n    construct VarIds [repeat id]\n\t_ [^ Args]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    construct TypeString [id]\n\t_ [buildVarsTypeList4Constructor Constructor each VarIds]\n    construct XNewName [id]\n\t_ [+ ClassName] [+ \"_body\"] [+ TypeString]\n    by\n\t'my XNewName Exps '% \nend rule\n\nfunction transformJavaLocalScopeVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    by\n\t'set Id TclDim\nend function\n\nfunction transformJavaClassVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    where \n\tId [is_class_var]\n    by\n\t'my 'set Id TclDim\nend function\n\nfunction transformJavaClassStaticVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ 'my 'class '] 'set Id TclDim\nend function\n\nfunction transformJavaThisVar Ref [reference]\n    deconstruct Ref\n\t'this '. Id [id] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_class_var]\n    by\n\t'my 'set Id \nend function\n\nfunction transformJavaThisStaticVar Ref [reference]\n    deconstruct Ref\n\t'this '. Id [id] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ 'my 'class '] 'set Id \nend function\n\nfunction complexRefAssignment Ref [reference]\n    deconstruct Ref\n\tId [id] Dim [repeat dimension] Comps [repeat component+] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    construct ExprLen [number]\n\t_ [length Expr]\n    where not\n\tExprLen [> 0]\n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    construct NewRef [reference]\n\tId Dim NewComps\n    by\n\tNewRef 'set VarId \nend function\n\nfunction assignToArrayRef Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n\n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    construct ExprLen [number]\n\t_ [length Expr]\n    where not\n\tExprLen [> 0]\n\n    deconstruct * Comps\n\tDim [dimension]\n\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n\n\n    deconstruct * NewComps\n\t'. VarId [id]\n    construct CompsLen2 [number]\n\t_ [length NewComps] [- 1]\n    construct DimComp [component]\n\tDim\n    construct NewComps2 [repeat component]\n\tNewComps [head CompsLen2] % [. DimComp]\n\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps2 \n\n    construct TmpDims [repeat dimension]\n\tDim\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim TmpDims]\n\n    by\n        NewRef 'set VarId TclDim \nend function\n\nfunction transformArithAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    where\n\tButt [is_arithmetic]\n    construct TclRef [tcl_expr_more]\n\t'[ 'expr '{ Butt '} ']\n    by\n\tTclRef\nend function\n\nfunction transformLiteralAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tLiteral [literal]\n    by\n\tLiteral\nend function\n\nfunction transformRefAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tRef [reference]\n    by\n\tRef\nend function\n\nfunction transformNewAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tNew [class_instance_creation_expression]\n    construct NewCmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    by\n\tNewCmd\nend function\n\nrule transformTryCatch\n    replace $ [declaration_or_statement]\n\t'try Block [block] Catches [repeat catch_clause] _ [opt finally_clause]\n    deconstruct Block\n\t'{ BlockStmts [repeat declaration_or_statement] '}\n    construct CatchesStmts [repeat declaration_or_statement]\n\t_ [^ Catches]\n    construct CatchBlock [xotcl_proc_body]\n\tCatchesStmts\n    by\n\t'if '{ '[ 'catch '{ BlockStmts '} 'result '] '} '{\n\tCatchBlock\n\t'} \nend rule\n\nrule transformThrowStmt\n    replace $ [declaration_or_statement]\n\t_ [throw_statement]\t\n    by\n\t'error '$result\nend rule\n\nrule transformIf\n    replace [declaration_or_statement]\n\t'if '( IfExpr [expression] ') _ [repeat comment_NL]\n\tStmt [statement] \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct IfTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    construct TclIf [tcl_if_cmd]\n\t'if '{ IfExpr '} IfTclBlock\n    by\n\tTclIf\nend rule\n\nrule transformIfElse\n    replace [declaration_or_statement]\n\t'if '( IfExpr [expression] ') IfStmt [statement] _ [repeat comment_NL]\n\t'else ElseStmt [statement]\n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct IfTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok IfStmt] \n\t\t      [statementBlockToTclBlock IfStmt]\n    construct ElseTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok ElseStmt] \n\t\t      [statementBlockToTclBlock ElseStmt]\n    deconstruct IfTclBlock\n\t'{ IfBody [opt xotcl_proc_body] '}\n    construct TclIf [tcl_if_cmd]\n\t'if '{ IfExpr '} '{ IfBody '} 'else ElseTclBlock\n    by\n\tTclIf\nend rule\n\nrule transformCondChoice\n    replace $ [assignment_expression]\n\tCond [conditional_expression]\n    deconstruct Cond\n\tUna [unary_expression] '? Exp [expression] ': CondChExp [conditional_expression]\n    by\n\t'[ 'expr '{ Una '? Exp  ': CondChExp '} ']\nend rule\n\nrule transformWhile\n    replace [declaration_or_statement]\n\t'while '( Expr [expression] ') Stmt [statement] \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct WhileTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    construct TclWhile [tcl_while_cmd]\n\t'while '{ Expr '}  WhileTclBlock\n    by\n\tTclWhile\nend rule\n\nrule transformSwitch\n    replace [declaration_or_statement]\n\t'switch '( Expr [expression] ') '{ JAlts [repeat switch_alternative] '}\n    construct Alts [repeat tcl_switch_entry]\n\t_ [transformSwitchAlternatives each JAlts] \n    construct TclSwitch [tcl_switch_cmd]\n\t'switch Expr '{ Alts '} \n    by\n\tTclSwitch\nend rule\n\nrule transformFor\n    replace [declaration_or_statement]\n\t'for '( ForInit [for_init] \n\tForExpr [opt expression] '; \n\tForUpd [list expression] ') \n\tStmt [statement] \n    construct ForUpdSeq [repeat expression]\n\t_ [. each ForUpd]\n    construct TclCmdLists [repeat tcl_cmd_list]\n\t_ [expressionListToTclCmdList ForUpdSeq] \n\t  [transformVarAssignmentFor]\n    construct TclForInit [repeat tcl_cmd_list]\n\t_ [transformForInitStmt1 ForInit] \n\t  [transformForInitStmt2 ForInit]\n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct ForTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    by\n\t'for '{ TclForInit '} \n\t'{ ForExpr '} '{ TclCmdLists '}\n\tForTclBlock\nend rule\n\nrule transformForeach\n    replace [declaration_or_statement]\n\t'for '( \n\t%for_in_init\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t': Expr [expression] ')\n\t\tStmt [statement]        \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct ForTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    by\n\t'foreach '{ Id '} '{ Expr '}\n\tForTclBlock\nend rule\n\nrule convertUnaryOpMultiLocal\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpMultiMy\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    where \n\tRef [is_class_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'my 'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpMultiClass\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    where \n\tRef [is_staticclass_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'[ 'my 'class '] 'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpFirstLocal\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nrule convertUnaryOpFirstMy\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    where \n\tRef [is_class_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'my 'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nrule convertUnaryOpFirstClass\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    where \n\tRef [is_staticclass_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'[ 'my 'class '] 'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nfunction expressionSeq2TclExprMoreSeq Expressions [repeat expression]\n    replace [repeat tcl_expr_more]\n\tEMore [repeat tcl_expr_more]\n    deconstruct Expressions\n\tExpr [expression] Exprs [repeat expression]\n    construct TclEMore [repeat tcl_expr_more]\n\tExpr\n    by\n\tEMore [. TclEMore] [expressionSeq2TclExprMoreSeq Exprs]\nend function\n\nfunction argumentToExpression Argument [argument]\n    replace [repeat expression]\n\tExps [repeat expression]\n    deconstruct Argument\n\tExp [expression]\n    by\n\tExps [. Exp]\nend function\n\nfunction is_static \n    match * [modifier]\n\t'static\nend function\n\nfunction is_synchronized\n    match * [modifier]\n\t'synchronized\nend function\n\nfunction transformId2TclVar Id [id]\n    replace [repeat tcl_expr_more]\n\tCmds [repeat tcl_expr_more]\n    construct Var [tcl_expr_more]\n\t'$ Id\n    by\n\tCmds [. Var]\nend function\n\nfunction buildParameterTypeList Parameter [formal_parameter]\n    replace [id]\n\tParams [id] \n    construct TypeName [id]\n\t_ [extractPrimitiveTypeName Parameter]\n\t  [extractReferenceTypeName Parameter]\n    by\n\tParams [_ TypeName]\nend function\n\nfunction this2my \n    replace [id]\n\t'this\n    by\n\t'my\nend function\n\nfunction dim2TclDim Dims [repeat dimension]\n    construct DimLen [number]\n\t_ [length Dims]\n    where \n\tDimLen [= 1]\n    deconstruct Dims\n\tDim [dimension] _ [repeat dimension]\n    deconstruct Dim\n\t'[ Expr [expression] ']\n    replace [repeat tcl_array_dimension]\n\t_ [repeat tcl_array_dimension]\n    by\n\t'( Expr ')\nend function\n\nfunction is_class_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_nonstatic_var Id]\nend function\n\nfunction is_staticclass_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_static_var Id]\nend function\n\nfunction buildVarsTypeList4Constructor Constructor [constructor_declaration] VarId [id]\n    replace [id]\n\tIds [id]\n    construct Tmp1 [constructor_declaration]\n\tConstructor [findVarTypeInConstructorParams VarId]\n    import TypeName [id]\n    by\n\tIds [+ TypeName]\nend function\n\nrule is_arithmetic\n    match $ [any]\n\tAny [any]\n    where \n\tAny [istype 'add_op]\n\t    [istype 'mult_op]\n\t    [istype 'unary_op]\n\t    [istype 'or_conditional_and_expression]\n\t    [istype 'and_inclusive_or_expression]\n\t    [istype 'or_exclusive_or_expression]\n\t    [istype 'or_and_expression]\n\t    [istype 'and_equality_expression]\n\t    [istype 'equality_op]\n\t    [istype 'relational_op]\n\t    [istype 'shif_op]\n\t    [istype 'conditional_choice]\nend rule\n\nfunction statementOneDeclToTclBlcok Stmt [statement]\n    replace [tcl_block]\n\t_ [tcl_block]\n    deconstruct not Stmt\n\t_ [block]\n    construct Decl [declaration_or_statement]\n\tStmt\n    by\n\t'{ Decl '}\nend function\n\nfunction statementBlockToTclBlock Stmt [statement]\n    replace [tcl_block]\n\t_ [tcl_block]\n    deconstruct Stmt\n\t'{ Decls [repeat declaration_or_statement] '}\n    by\n\t'{ Decls '}\nend function\n\nfunction transformSwitchAlternatives JAlt [switch_alternative]\n    replace [repeat tcl_switch_entry]\n\tEntries [repeat tcl_switch_entry]\n    deconstruct JAlt\n\t'case Label [constant_expression] ': Decls [repeat declaration_or_statement]\n    construct SwitchLabel [tcl_cmd]\n\t_ [switchLabelConvertNum Label] [switchLabelConvertChar Label]\n    construct Entry [tcl_switch_entry]\n\tSwitchLabel '{ Decls '} \t\n    by\n\tEntries [. Entry]\nend function\n\nfunction expressionListToTclCmdList Expressions [repeat expression]\n    replace [repeat tcl_cmd_list]\n\t_  [repeat tcl_cmd_list]\n    deconstruct Expressions\n\tExpr [expression] Exprs [repeat expression]\n    construct TclCmdList [tcl_cmd_list]\n\tExpr\n    by\n\tTclCmdList [addExpToTclCmdList each Exprs]\nend function\n\nfunction transformForInitStmt1 ForInit [for_init]\n    deconstruct ForInit\n\tExprs [list expression] ';\n    replace [repeat tcl_cmd_list]\n\t_ [repeat tcl_cmd_list]\n    construct ExprSeq [repeat expression]\n\t_ [. each Exprs]\n    by\n\t_ [expressionListToTclCmdList ExprSeq] [transformVarAssignmentFor]\nend function\n\nfunction transformForInitStmt2 ForInit [for_init]\n    deconstruct ForInit\n\tLocalDecl [declaration_or_statement] \n    construct TmpDecls [repeat declaration_or_statement]\n\tLocalDecl\n    construct TmpDecls2 [repeat declaration_or_statement]\n\tTmpDecls [splitLocalVarDeclarations] [localVarDecl2Assignment]\n    deconstruct TmpDecls2\n\tDecl1 [declaration_or_statement] _ [repeat declaration_or_statement]\n    replace [repeat tcl_cmd_list]\n\t_ [repeat tcl_cmd_list]\n    by\n%\tLocalDecl\n\tTmpDecls2\nend function\n\nrule transformVarAssignmentFor\n    replace [repeat tcl_expr_more]\n\t Ref [reference] '= Butt [assignment_expression] \n    construct TclCmd [repeat tcl_expr_more]\n\t_ [transformJavaLocalScopeVar Ref] \n\n\t  [transformJavaClassVar Ref] \n\t  [transformJavaClassStaticVar Ref] \n\n\t  [transformJavaThisVar Ref] \n\t  [transformJavaThisStaticVar Ref] \n\n\t  [complexRefAssignment Ref]\n\t  [assignToArrayRef Ref]\n    construct TclLit [tcl_expr_more]\n\t_ [transformArithAssExp Butt]\n\t  [transformLiteralAssExp Butt]\n\t  [transformRefAssExp Butt]\n\t  [transformNewAssExp Butt]\n    by\n\tTclCmd [. TclLit] \nend rule\n\nfunction makeDecrCmdTail Op [pre_inc_dec]\n    deconstruct Op\n\t'--\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    construct Num [tcl_literal]\n\t-1\n    by\n\tNum\nend function\n\nfunction extractPrimitiveTypeName Parameter [formal_parameter]\n    replace [id]\n\t_ [id]\n    construct Primitive [repeat primitive_type]\n\t_ [^ Parameter]\n    deconstruct Primitive\n\tFirst [primitive_type] _ [repeat primitive_type]\n    construct TypeName [id]\n\t_ [quote First]\n    by\n\t_ [+ TypeName]\nend function\n\nfunction extractReferenceTypeName Parameter [formal_parameter]\n    replace [id]\n\t_ [id]\n    construct References [repeat reference]\n\t_ [^ Parameter]\n    deconstruct References\n\t_ [id] _ [repeat dimension] _ [repeat component]\n    construct Ids [repeat id]\n\t_ [^ References]\n    deconstruct * Ids \n\tTypeName [id]\n    by\n\t_ [+ TypeName]\nend function\n\nfunction is_nonstatic_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where\n\tField [has_var Id] \n    where not\n\tField [is_static]\nend function\n\nfunction is_static_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where all\n\tField [has_var Id] [is_static]\nend function\n\nrule findVarTypeInConstructorParams VarId [id]\n    replace $ [formal_parameter]\n\tFP [formal_parameter]\n    deconstruct FP\n\t_ [opt 'final] _ [type_specifier] _ [opt var_arg_specifier] \n\tId  [id] _ [opt generic_parameter] _ [repeat dimension]\n    where \n\tId [= VarId]\n    construct TypeName [id]\n\t_ [buildParameterTypeList FP]\n    export TypeName\n    by\n\tFP\nend rule\n\nfunction switchLabelConvertNum Label [constant_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct Label\n\tNum [number]\n    by\n\tNum\nend function\n\nfunction switchLabelConvertChar Label [constant_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct Label\n\tChars [charlit]\n    construct Unq [id]\n\t_ [unquote Chars]\n    by\n\tUnq\nend function\n\n\n\nrule splitLocalVarDeclarations\n    replace [repeat declaration_or_statement]\n\tModr [repeat modifier] TypSpec [type_specifier] VarDecl [variable_declarator] ', VarDeclRest [list variable_declarator+] '; \n\tRest [repeat declaration_or_statement]\n    by\n\tModr TypSpec VarDecl ';\n\tModr TypSpec VarDeclRest ';\n\tRest\nend rule\n\nrule localVarDecl2Assignment\n    replace $ [declaration_or_statement]\n\tDecl [declaration_or_statement] \n    deconstruct Decl\n\t_ [repeat modifier] _ [type_specifier] _ [variable_declarators] ';\n    by\n\tDecl [localVarDecl2AssignmentExp] [localVarDecl2AssignmentArray] \nend rule\n\nfunction has_var Id [id]\n    match * [variable_name]\n\tVarId [id] _ [opt generic_parameter] _ [repeat dimension]\n    where \n\tVarId [= Id]\nend function\n\nfunction localVarDecl2AssignmentExp\n    replace [declaration_or_statement]\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t'= Exp [conditional_expression] ';\n    construct Ass [assignment_expression]\n\tId '= Exp \n    by\n\tAss ';\nend function\n\nfunction localVarDecl2AssignmentArray\n    replace [declaration_or_statement]\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t'= Exp [array_initializer] ';\n    construct Ass [assignment_expression]\n\tId '= Exp \n    by\n\tAss ';\nend function\n\n",
        "after": " package require XOTcl\nnamespace import ::xotcl::*\n\nClass create UnaryDemo_metapapa -superclass {Class} -slots {\n\n}\n\nUnaryDemo_metapapa create UnaryDemo -superclass {Class} -slots {\n\n}\n\nUnaryDemo proc main {args} {\n    set result [expr {+1}]\n    // result is now 1\n    \n    [System set out] println $result\n    incr result -1\n    // result is now 0\n    \n    [System set out] println $result\n    incr result\n    // result is now 1 \n    \n    [System set out] println $result\n    set result [expr {-$result}]\n    // result is now -1\n    \n    [System set out] println $result\n    set success 0\n    [System set out] println $success\n    // false\n    \n    [System set out] println !$success\n    // true\n    \n}\n\n ",
        "before": "\npackage require XOTcl\nnamespace import ::xotcl::*\n\nclass UnaryDemo {\n\n    public static void main (String [] args) {\n        result = +1;\n        // result is now 1\n        \n        System.out.println (result);\n        result --;\n        // result is now 0\n        \n        System.out.println (result);\n        result ++;\n        // result is now 1 \n        \n        System.out.println (result);\n        result = -result;\n        // result is now -1\n        \n        System.out.println (result);\n        success = 0;\n        System.out.println (success);\n        // false\n        \n        System.out.println (!success);\n        // true\n        \n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function isTransient\n\tmatch [modifier]\n\t\t'transient\nend function",
        "context": "function translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\n\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " internal ColoredPoint (int x, int y) : this (x, y, WHITE) {\n}\n\n ",
        "before": "\nColoredPoint (int x, int y) {\n    this (x, y, WHITE);\n}\n\n "
    },
    {
        "hole_rule": "function translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function",
        "context": "function translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\n\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n",
        "after": " internal ColoredPoint (int x, int y) : this (x, y, WHITE) {\n}\n\ninternal ColoredPoint (int x, int y, int color) : base (x, y) {\n    this.color = color;\n}\n\n ",
        "before": "\nColoredPoint (int x, int y) {\n    this (x, y, WHITE);\n}\n\nColoredPoint (int x, int y, int color) {\n    super (x, y);\n    this.color = color;\n}\n\n "
    },
    {
        "hole_rule": "function translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function",
        "context": "function translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\n\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " Console.WriteLine (\"i is greater than 3.\");\nbreak;\n ",
        "before": "\nSystem.out.println (\"i is greater than 3.\");\nbreak;\n "
    },
    {
        "hole_rule": "function checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function",
        "context": "function translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\n\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n",
        "after": " internal FieldDeclaration () {\n    // unitialized final variable must be initialized in constructor\n    \n    f = 17.21f;\n}\n\n ",
        "before": "\nFieldDeclaration () {\n    // unitialized final variable must be initialized in constructor\n    \n    f = 17.21f;\n}\n\n "
    },
    {
        "hole_rule": "function addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function",
        "context": "function changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\n\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " virtual public void bump () {\n    lock (this) {\n        count ++;\n    }\n}\n\n ",
        "before": "\nvoid bump () {\n    synchronized (this) {\n        count ++;\n    }\n}\n\n "
    },
    {
        "hole_rule": "function checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function",
        "context": "function translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\n\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n",
        "after": " //J2C# NotSupported:Inner classes must be removed manually\nclass Inner {\n\n    void display () {\n        System.out.println (\"display: Inner class in Java \");\n    }\n\n}\n\n ",
        "before": "\nclass Inner {\n\n    void display () {\n        System.out.println (\"display: Inner class in Java \");\n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function",
        "context": "function translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\n\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " static String initInstance () {\n    Console.WriteLine (\"Initializing instance variable\");\n    return \"instance\";\n}\n\n ",
        "before": "\nstatic String initInstance () {\n    System.out.println (\"Initializing instance variable\");\n    return \"instance\";\n}\n\n "
    },
    {
        "hole_rule": "function translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function",
        "context": "function translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n",
        "after": " readonly Object v = new Object ();\n// uninitialized final \n\nreadonly float f;\n\ninternal FieldDeclaration () {\n    // unitialized final variable must be initialized in constructor\n    \n    f = 17.21f;\n}\n\n ",
        "before": "\nreadonly Object v = new Object ();\n// uninitialized final \n\nreadonly float f;\n\nFieldDeclaration () {\n    // unitialized final variable must be initialized in constructor\n    \n    f = 17.21f;\n}\n\n "
    },
    {
        "hole_rule": "function changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function",
        "context": "function changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\n\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " Console.WriteLine (\"Beginning main()\");\n ",
        "before": "\nSystem.out.println (\"Beginning main()\");\n "
    },
    {
        "hole_rule": "function setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function",
        "context": "function changeInterfaceHeader\n% Java: [repeat modifier] 'interface [interface_name] [opt extends_clause] [opt implements_clause]\n% C#:   attributesopt interface-modifiersopt interface identifier interface-baseopt interface-body ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nfunction translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\n\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " class Client : Object, Callback {\n    // Implement Callback's interface\n    \n\n    virtual public void callback (int p) {\n        Console.WriteLine (\"callback called with \" + p);\n    }\n\n}\n\nclass TestIface {\n\n    public static void Main (String [] args) {\n        Callback c = new Client ();\n        c.callback (42);\n    }\n\n}\n\n ",
        "before": "\nclass Client implements Callback {\n    // Implement Callback's interface\n    \n\n    public void callback (int p) {\n        System.out.println (\"callback called with \" + p);\n    }\n\n}\n\nclass TestIface {\n\n    public static void main (String args []) {\n        Callback c = new Client ();\n        c.callback (42);\n    }\n\n}\n\n "
    },
    {
        "hole_rule": "rule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule",
        "context": "function translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\n\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " if (a == b) Console.WriteLine (a);\n\nif ((a > c) || (a == b)) Console.WriteLine (b);\n\nif ((a >= c) && (b <= c)) Console.WriteLine (c);\n\n//for\n\nfor (sbyte v = 0;\na >> 10; a ++) {\n    Console.WriteLine (a);\n}\n//switch\n\na = 2;\nswitch (a) {\n    case 1 :\n        Console.WriteLine (\"One\");\n        break;\n    case 2 :\n        Console.WriteLine (\"Two\");\n        break;\n    default :\n        Console.WriteLine (\"?\");\n        break;\n}\n ",
        "before": "\nif (a == b) System.out.println (a);\n\nif ((a > c) || (a == b)) System.out.println (b);\n\nif ((a >= c) && (b <= c)) System.out.println (c);\n\n//for\n\nfor (byte v = 0;\na >>> 10; a ++) {\n    System.out.println (a);\n}\n//switch\n\na = 2;\nswitch (a) {\n    case 1 :\n        System.out.println (\"One\");\n        break;\n    case 2 :\n        System.out.println (\"Two\");\n        break;\n    default :\n        System.out.println (\"?\");\n}\n "
    },
    {
        "hole_rule": "function after SL [stringlit]\n    replace [stringlit]\n\tScope [stringlit]\n    construct N [number]\n\t_ [index Scope SL]\n    construct NewN [number]\n\tN [+ 1]\n    by\n\tScope [changeNull N]\n\t      [changeNOTNull NewN 9999]\nend function",
        "context": "function translateCConst\n    replace [externaldefinition]\n\t'const T [type_specifier] N [identifier] '= E [expression] ';\n    construct NewType [type_specifier]\n\tT [changeType]\n    by\t\n\t'const N ': NewType ':= E\nend function\n\nfunction translateCType\n    replace [externaldefinition]\n\t'typedef T [type_specifier] OP [opt pointer] N [identifier] OAP [opt array_part] ';\n    construct NewType [type_specifier]\n\tT [changeType]\n    construct NewTuringType [externaldefinition]\n\t'type N : NewType\n    by\n\tNewTuringType\nend function\n\nfunction translateCVar\n    replace [externaldefinition]\n\tT [type_specifier] D [list decl_id_part+] ';\n    construct NewTuringVar [repeat t_var]\n\t_ [translatePointerVarDecl T each D]\n\t  [translateVarDecl T each D]\n    construct NewED [externaldefinition]\n\tNewTuringVar\n    by\n\tNewED\nend function\n\nfunction translateCFunction\n    replace [externaldefinition]\n\tF [function_definition]\n    construct NewTuringFunction [externaldefinition]\n\tF [translateProcedure]\t\t%% must be done before functions\n\t  [translateFunction]\n    by\n\tNewTuringFunction\nend function\n\nfunction changeType\n    construct CTypes [repeat type_specifier]\n    \t'char 'long 'float 'double\n    construct TuringTypes [repeat type_specifier]\n    \t'string(1) 'int 'real 'real\n    replace * [type_specifier]\n        CType [type_specifier]\n    by\n\tCType [$ each CTypes TuringTypes]\nend function\n\nfunction translateVarDecl T [type_specifier] D [decl_id_part]\n    deconstruct D\n\tDI [decl_identifier] OAP [opt array_part] OI [opt initialisation]\n    replace [repeat t_var]\n\tSoFar [repeat t_var]\n    construct TuringVar [t_var]\n\t'var DI ': T\n    construct NewTuringVar [t_var]\n\tTuringVar [addOptArrayPart OAP]\n\t\t  [addOptInit OI]\n\t\t  [changeType]\n    by\n\tSoFar [. NewTuringVar]\t\nend function\n\nfunction translatePointerVarDecl T [type_specifier] D [decl_id_part]\n    deconstruct D\n\t'* DI [decl_identifier] OAP [opt array_part] OI [opt initialisation]\n    deconstruct T\n\t'char\n    replace [repeat t_var]\n\tSoFar [repeat t_var]\n    construct TuringVar [t_var]\n\t'var DI ': 'string\n    construct NewTuringVar [t_var]\n\tTuringVar [addOptArrayPart OAP]\n\t\t  [addOptInit OI]\n    by\n\tSoFar [. NewTuringVar]\t\nend function\n\nfunction translateFunction\n    replace [function_definition]\n\tTS [type_specifier] N [identifier] '( AD [list argument_declaration] ')\n\tCS [compound_statement]\n    construct TuringArgs [list argument_declaration]\n\t_ [translateArg each AD]\n    construct ArgPart [t_paramDecl]\n\t'( TuringArgs ')\n    construct NewFunc [function_definition]\n\t'function N ArgPart ': TS\n\t    CS [changeCompound]\n\t'end N\n    by\n\tNewFunc [removeBeginEndFromFunc] \n\t\t[removeEmptyArgsFromFunc]\nend function\n\nfunction translateProcedure\n    replace [function_definition]\n\t'void N [identifier] '( AD [list argument_declaration] ')\n\tCS [compound_statement]\n    construct TuringArgs [list argument_declaration]\n\t_ [translateArg each AD]\n    construct ArgPart [t_paramDecl]\n\t'( TuringArgs ')\n    construct NewProc [function_definition]\n\t'procedure N ArgPart\n\t    CS [changeCompound]\n\t'end N\n    by\n    NewProc [removeBeginEndFromProc] \n    \t    [removeEmptyArgsFromProc]\nend function\n\nfunction addOptInit OI [opt initialisation]\n    deconstruct OI\n\t'= E [expression]\n    replace [t_var]\n\t'var DI [decl_identifier] ': T [type_specifier]\n    by\n\t'var DI ': T ':= E [changeExpression]\nend function\n\nfunction addOptArrayPart OAP[opt array_part]\n    deconstruct OAP\n\t'[ N [number] ']\n    replace [t_var]\n\t'var DI [decl_identifier] ': T [type_specifier]\n    construct NewN [number]\n\tN [- 1]\n    construct TuringArraySpec [type_specifier]\n\t'array 0 .. NewN 'of T\n    construct NewTuringArraySpec [type_specifier]\n\tTuringArraySpec [changeToStringSpec]\n    by\n\t'var DI ': NewTuringArraySpec\nend function\n\nfunction translateArg AD [argument_declaration]\n    deconstruct AD\n\tT [type_specifier] DI [decl_identifier] OAP [opt array_part] OI [opt initialisation]\n    replace [list argument_declaration]\n\tSoFar [list argument_declaration]\n    construct TuringArg [argument_declaration]\n\tDI ': T\n    construct NewTuringArg [argument_declaration]\n\tTuringArg [changeOptArrayPart OAP]\n\t\t  [changeType]\n    by\n\tSoFar [, NewTuringArg]\t\nend function\n\nfunction removeBeginEndFromFunc\n    replace [function_definition]\n\t'function N [identifier] OA [opt t_paramDecl] ': TS [type_specifier]\n\t    'begin\n\t\tD [repeat externaldefinition]\n\t\tS [repeat statement]\n\t    'end\n\t'end N\n    construct NewType [type_specifier]\n\tTS [changeType]\n    by\n\t'function N OA ': NewType\n\t    D\n\t    S\n\t'end N\nend function\n\nfunction removeEmptyArgsFromFunc\n    replace [function_definition]\n\t'function N [identifier] '( ') ': TS [type_specifier] \n\t    D [repeat externaldefinition]\n\t    S [repeat statement]\n\t'end N\n    by\n\t'function N ': TS\n\t    D\n\t    S\n\t'end N\nend function\n\nrule changeCompound\n    replace [compound_statement]\n\t'{\n\t\tD [repeat declaration] \n\t\tS [repeat statement]\n\t'} OS [opt ';]\n    construct ExtDefs [repeat externaldefinition]\n\t_ [makeExternalDef each D]\n    construct TuringDecls [repeat externaldefinition]\n\t_ [changeExternalDef each ExtDefs]\n    construct TuringStatements [repeat statement]\n\t_ [translateCStatements each S]\n    by\n\t'begin\n\t\tTuringDecls\n\t\tTuringStatements \n\t'end\nend rule\n\nfunction removeBeginEndFromProc\n    replace [function_definition]\n\t'procedure N [identifier] OA [opt t_paramDecl]\n\t    'begin\n\t\tD [repeat externaldefinition]\n\t\tS [repeat statement]\n\t    'end\n\t'end N\n    by\n\t'procedure N OA\n\t    D\n\t    S\n\t'end N\nend function\n\nfunction removeEmptyArgsFromProc\n    replace [function_definition]\n\t'procedure N [identifier] '( ')\n\t    D [repeat externaldefinition]\n\t    S [repeat statement]\n\t'end N\n    by\n\t'procedure N\n\t    D\n\t    S\n\t'end N\nend function\n\nrule changeExpression\n    construct COps [repeat binary_operator]\n        '== '!= '&& '|| '%\n    construct TuringOps [repeat binary_operator]\n    \t'= 'not= 'and 'or 'mod\n    replace [expression]\n\tE [expression]\n    construct NewE [expression]\n\tE [changeOp each COps TuringOps]\n\t  [changeArrayBrackets]\n    deconstruct not NewE\n\tE \n    by\n\tNewE \nend rule\n\nfunction changeToStringSpec\n    replace * [type_specifier]\n\t'array 0 .. N [number] 'of 'char\n    construct NewN [number]\n\tN [+ 1]\n    construct NewTuringTypeSpec [type_specifier]\n\t'string '( NewN ')\n    by\n\tNewTuringTypeSpec\nend function\n\nfunction changeOptArrayPart OAP [opt array_part]\n    deconstruct OAP\n\t'[ N [number] ']\n    replace [argument_declaration]\n\tDI [decl_identifier] ': T [type_specifier]\n    construct NewN [number]\n\tN [- 1]\n    construct TuringArraySpec [type_specifier]\n\t'array 0 .. NewN 'of T\n    construct NewTuringArraySpec [type_specifier]\n\tTuringArraySpec [changeToStringSpec]\n    by\n\tDI ': NewTuringArraySpec\nend function\n\nfunction translateCStatements CStatement [statement]\t\t\t\n    replace [repeat statement]\n\tSoFar [repeat statement]\n    construct NewTuringStatement [statement]\n\tCStatement [changeCStatement]\n    by\n\tSoFar [. NewTuringStatement]\nend function\n\nfunction makeExternalDef D [declaration]\n    replace [repeat externaldefinition]\n\tSoFar [repeat externaldefinition]\n    construct NewExternalDef [externaldefinition]\n\tD\n    by\n\tSoFar [. NewExternalDef]\nend function\n\nfunction changeArrayBrackets\n    replace * [unary_expression]\n\tPE [primary_expression] '[ E [expression] ']\n    by\n\tPE '( E ')\nend function\n\nfunction changeOp COp [binary_operator] TuringOp [binary_operator]\n    replace * [binary_operator]\n\tCOp\n    by\n\tTuringOp\nend function\n\nfunction changeCStatement\n    replace [statement]\n\tS [statement]\n    construct NewS [statement]\n\tS [changeExprStatement]\n\t  [changeIfStatement]\n\t%% Loop statements\n\t  [changeDoWhileStatement]\n\t  [changeWhileStatement]\n\t  [changeForStatement]\n\t%% Jump statements\n\t  [changeReturnStatement]\n\t  [changeBreakStatement]\n    deconstruct not NewS\n\tS\n    by\n\tNewS\nend function\n\nfunction changeDoWhileStatement\n    replace [statement]\n\t'do\n\t    S [statement] \n\t'while '( E [expression] ') ';\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( E [changeExpression] ')\n    construct NewS [repeat statement]\n\tS \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'loop\n\t    NewBody [. exitCondition]\n\t'end 'loop\nend function\n\nfunction changeWhileStatement\n    replace [statement]\n\t'while '( E [expression] ') \n\t    S [statement]\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( E [changeExpression] ')\n    construct NewS [repeat statement]\n\tS \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'loop\n\t    exitCondition \n\t    NewBody\n\t'end 'loop\nend function\n\nfunction changeForStatement\n    replace [statement]\n\t'for '( I [expression] '; C [expression] '; S1 [expression] ') \n\t    S2 [statement]\n    construct InitStatement [statement]\n\tI\n    construct NewInitStatement [statement]\n\tInitStatement [changeCStatement]\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( C [changeExpression] ')\n    construct NewFinalStatement [repeat statement]\n\tS1\n    construct NewS [repeat statement]\n\tS2 \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets] [. NewFinalStatement]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'begin\n\t    NewInitStatement\n\t    'loop\n\t\texitCondition\n\t\tNewBody\n\t    'end 'loop\n\t'end\nend function\n\nfunction changeIfStatement\n    replace [statement]\n\t'if '( E [expression] ')\n\t    S [statement]\n\tOE [opt ELSEstatement]\n    construct NewS [repeat statement]\n\tS\n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'if E [changeExpression] 'then\n\t    NewBody\n\tOE [changeElse]\n\t'end 'if\nend function\n\nfunction changeReturnStatement\n    replace [statement]\n\t'return E [expression] ';\n    by\n\t'result E [changeExpression]\nend function\n\nfunction changeBreakStatement\n    replace [statement]\n\t'break ';\n    by\n\t'exit\nend function\n\nrule changeExprStatement\n    replace [statement]\n\tES [expression_statement] \n    construct NewES [expression_statement]\n\tES [removeSemiColon]\n\t   [removeAmpersand]\n\t   [changeAssignment]\n\t   [changeBasicPrintf]\n\t   [changeComplexPrintf]\n\t   [changeBasicScanf]\n\t   [changeStrCopy]\n\t   [changeStrCat]\n\t   [changePrePlusPlus]\n\t   [changePostPlusPlus]\n\t   [changePreMinusMinus]\n\t   [changePostMinusMinus]\n\t   [changeArrayBrackets]\t\t%% changeArrayBrackets defined in expr_t.C\n    deconstruct not NewES\n\tES\n    by\n\tNewES \nend rule\n\nfunction removeBrackets\n    replace [repeat statement]\n\t'{\n\t    RS [repeat statement]\n\t'}\n    by\n\tRS\nend function\n\nrule changeElse\n    replace [ELSEstatement]\n\t'else 'if '( E [expression] ')\n\t    S [statement]\n\tOE [opt ELSEstatement]\n    construct NewS [repeat statement]\n\tS\n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'elsif E [changeExpression] 'then\n\t    NewBody\n\tOE [changeElse]\nend rule\n\nfunction removeSemiColon\n    replace [expression_statement]\n\tE [expression] ';\n    by\n\tE [changeExpression]\nend function\n\nfunction removeAmpersand\n    replace * [cast_expression]\n\t'& CE [cast_expression]\n    by\n\tCE\nend function\n\nfunction changeAssignment\n    replace [expression_statement]\n\tCE1 [cast_expression] '= CE2 [cast_expression] RBO [repeat binary_operation]\n    by\n\tCE1 ':= CE2 RBO\nend function\n\nfunction changeBasicPrintf\n    replace [expression_statement]\n\t'printf '( SL[stringlit] ')\n    by\n\t'put SL '..\nend function\n\nfunction changeComplexPrintf\n    replace [expression_statement]\n\t'printf '( LE [list assignment_expression+] ')\n    construct repeatExpr [repeat assignment_expression]\n\t_ [. each LE]\n    deconstruct repeatExpr\n\tSL [stringlit] Rest [repeat assignment_expression]\n    construct NewArgList [list putArg]\n\t_ [translatePutArgs SL Rest]\t\t\t\n    construct putStatement [expression_statement]\n\t'put NewArgList [removeEmptyArg] '..\n    by\n\tputStatement [removeOptDotDot]\nend function\n\nfunction changeBasicScanf\n    replace [expression_statement]\n\t'scanf '( LE [list assignment_expression+] ')\n    construct repeatExpr [repeat assignment_expression]\n\t_ [. each LE]\n    deconstruct repeatExpr\n\tSL [stringlit] Rest [repeat assignment_expression]\n    construct listExpr [list assignment_expression]\n\t_ [, each Rest]\n    by\n\t'get listExpr\nend function\n\nfunction changeStrCopy\n    replace [expression_statement]\n\tES [expression_statement]\n    by\n\tES [changeCopyWithLiteral]\n\t   [changeCopyWithIdentifier]\nend function\n\nfunction changeStrCat\n    replace [expression_statement]\n\tES [expression_statement]\n    by\n\tES [changeCatWithLiteral]\n\t   [changeCatWithIdentifier]\nend function\n\nfunction changePrePlusPlus\n    replace [expression_statement]\n\t'++ ID [identifier]\n    by\n\tID ':= ID '+ 1\nend function\n\nfunction changePostPlusPlus\n    replace [expression_statement]\n\tID [identifier] '++ \n    by\n\tID ':= ID '+ 1\nend function\n\nfunction changePreMinusMinus\n    replace [expression_statement]\n\t'-- ID [identifier]\n    by\n\tID ':= ID '- 1\nend function\n\nfunction changePostMinusMinus\n    replace [expression_statement]\n\tID [identifier] '-- \n    by\n\tID ':= ID '- 1\nend function\n\nfunction translatePutArgs SL [stringlit] RAE [repeat assignment_expression]\t\t\t\n    replace [list putArg]\n\tSoFar [list putArg]\n    construct beforePercent [stringlit]\t\t% get everything before the next percent\n\tSL [before \"%\"] [replaceEmpty SL RAE]\n    construct NewSL [putArg]\n\tbeforePercent\n    where not\t\t\t\t\t% terminating condition\n\tbeforePercent [?replaceEmpty SL RAE]\n    construct afterPercent [stringlit]\t\t% get everything after the percent sign\n\tSL [after \"%\"]\n    construct restSL [stringlit]\t\t% skip the next character\n\tafterPercent [: 2 9999] \t\t% 2nd to last character\n    construct RestAE [repeat assignment_expression]\n\t_ [getRest RAE]\n    construct recurse [list putArg]\n\t_ [translatePutArgs restSL RestAE]  \n    by\n\tSoFar [, NewSL] [addAE RAE] [, recurse]\nend function\n\nfunction removeEmptyArg\n    replace * [list_1_putArg]\n\t\"\" ', Tail [list_1_putArg]\n    by\n\tTail \nend function\n\nfunction removeOptDotDot\n    replace [expression_statement]\n\t'put LPA [list putArg] '..\n    construct NewLPA [list putArg]\n\tLPA [removeNewline]\n    %%deconstruct not NewLPA \n    \t%%LPA\n    by\n\t'put NewLPA\nend function\n\nfunction changeCopyWithLiteral\n    replace [expression_statement]\n\t'strcpy '( N [identifier] ', SL [stringlit] ')\n    by\n\tN ':= SL\nend function\n\nfunction changeCopyWithIdentifier\n    replace [expression_statement]\n\t'strcpy '( N [identifier] ', N2 [identifier] ')\n    by\n\tN ':= N2\nend function\n\nfunction changeCatWithLiteral\n    replace [expression_statement]\n\t'strcat '( N [identifier] ', SL [stringlit] ')\n    by\n\tN ':= N '+ SL\nend function\n\nfunction changeCatWithIdentifier\n    replace [expression_statement]\n\t'strcat '( N [identifier] ', N2 [identifier] ')\n    by\n\tN ':= N '+ N2\nend function\n\nfunction replaceEmpty restSL [stringlit] RAE [repeat assignment_expression]\n    replace [stringlit]\n\t\"\"\n    where not\n\tRAE [?notEmpty]\n    by\n\trestSL\nend function\n\nfunction addAE RAE [repeat assignment_expression]\n    deconstruct RAE\n\tAE [assignment_expression] RestAE [repeat assignment_expression]\n    replace [list putArg]\n\tLPA [list putArg]\n    construct NewPA [putArg]\n\tAE\n    by\n\tLPA [, NewPA]\nend function\n\nfunction getRest RAE [repeat assignment_expression]\n    replace [repeat assignment_expression]\n\tRest [repeat assignment_expression]\n    deconstruct RAE\n\tAE [assignment_expression] RestAE [repeat assignment_expression]\n    by\n\tRestAE\nend function\n\nfunction before SL [stringlit]\n    replace [stringlit]\n\tScope [stringlit]\n    construct N [number]\n\t_ [index Scope SL]\n    construct NewN [number]\n\tN [- 1]\n    by\n\tScope [changeNull N]\n\t      [changeNOTNull 1 NewN]\nend function\n\n\n\nfunction removeNewline\n    replace * [list putArg]\n\tS [stringlit]\n    by\n\t% nothing\nend function\n\nfunction changeNull N [number]\n    replace [stringlit]\n\tSL [stringlit]\n    where\n\tN [<= 1]\n    by\n\t\"\"\nend function\n\nfunction changeNOTNull N1 [number] N2 [number]\n    replace [stringlit]\n\tSL [stringlit]\n    by\n\tSL [: N1 N2]\nend function\n\n",
        "after": " var a : array 0..4 of int\n ",
        "before": "\n "
    },
    {
        "hole_rule": "function toRight Pivot [id] N [id]\n    where not \n        N [< Pivot]\n    replace [id *] \n        List [id *]\n    by \n        N List\nend function",
        "context": "function toLeft Pivot [id] N [id]\n    where \n        N [< Pivot]\n    replace [id *] \n        List [id *]\n    by \n        N List\nend function\n\n\n\n",
        "after": " notice notice notice ",
        "before": "\nnotice notice "
    },
    {
        "hole_rule": "function containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function",
        "context": "function addBraces %\nreplace [program] \n\tNewImportDeclaration[repeat import_declaration]\n\tPHeader[package_header]\t    \n\tTypeDeclr[repeat type_declaration]\n\t%construct Length[number]\n\t%\t _[length NewImportDeclaration]\n\t%where Length[> 0]\n\tby\n\tNewImportDeclaration\n\tPHeader\t    \n\t'{\n\t    TypeDeclr\n\t'}\nend function\n\nfunction changeImportToUsing importDec[import_declaration]\n\tdeconstruct importDec\n\t    'import Name[package_or_type_name] DotStar[opt dot_star] '; \n\treplace *[repeat import_declaration]\n\tby\n\t    'using Name ';%remove DotStar\n\t    %decide how to change for proper C# equivelant API\nend function\n\nfunction changePackageToNamespace\n\treplace [opt package_header]\n\t    'package Name[package_name] '; \n\tby\n\t    'namespace Name \nend function\n\nfunction changeClassHeader\n% Java: [repeat modifier] 'class [class_name] [opt extends_clause] [opt implements_clause]\n% C#:   class-modifiersopt   class   identifier   class-base opt   class-body   ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\t\t%to set a constructor if needed\n\t\texport ClassName[class_name]\n\t\t\tName\t\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeInterfaceHeader\n% Java: [repeat modifier] 'interface [interface_name] [opt extends_clause] [opt implements_clause]\n% C#:   attributesopt interface-modifiersopt interface identifier interface-baseopt interface-body ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nfunction translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\n\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " using System;\nusing java.io.IOException;\n\n        class throwsExample {\n            char [] a;\n            int position;\n            // Method explicitly throws an exception\n            \n\n            virtual public int read () {\n                if (position >= a.length) throw new IOException ();\n\n                return a [position ++];\n            }\n\n            // Method implicitly throws an exception\n            \n\n            virtual public String readUpTo (char terminator) {\n                String s = new String ();\n                while (true) {\n                    int c = read ();\n                    // Can throw IOException\n                    \n                    if (c == - 1 || c == terminator) return s.toString ();\n\n                    s = s + c;\n                }\n            }\n\n            // Method catches an exception internally\n            \n\n            virtual public int getLength () {\n                String s;\n                try {\n                    s = readUpTo (':');\n                } catch (IOException e) {\n                    return 0;\n                }\n                return s.length ();\n            }\n\n            // Method can throw a RuntimeException\n            \n\n            virtual public int getAvgLength () {\n                int count = 0;\n                int total = 0;\n                int len;\n                while (true) {\n                    len = getLength ();\n                    if (len == 0) break;\n\n                    count ++;\n                    total += len;\n                }\n                return total / count;\n                // Can throw ArithmeticException\n                \n            }\n\n        }\n\n        /* Throws example\n\n        \n           using java.io.IOException;\n\n        \n           {\n\n        \n           class throwsExample {\n\n        \n           char [] a;\n\n        \n           int position;\n\n        \n           // Method explicitly throws an exception\n\n        \n           \n        \n           virtual public int read () {\n\n        \n           if (position >= a.length) throw new IOException ();\n\n        \n           \n        \n           return a [position ++];\n\n        \n           }\n\n        \n           \n        \n           // Method implicitly throws an exception\n\n        \n           \n        \n           virtual public String readUpTo (char terminator) {\n\n        \n           String s = new String ();\n\n        \n           while (true) {\n\n        \n           int c = read ();\n\n        \n           // Can throw IOException\n\n        \n           if (c == - 1 || c == terminator) return s.toString ();\n\n        \n           \n        \n           s = s + c;\n\n        \n           }\n\n        \n           }\n\n        \n           \n        \n           // Method catches an exception internally\n\n        \n           \n        \n           virtual public int getLength () {\n\n        \n           String s;\n\n        \n           try {\n\n        \n           s = readUpTo (':');\n\n        \n           } catch (IOException e) {\n\n        \n           return 0;\n\n        \n           }\n\n        \n           return s.length ();\n\n        \n           }\n\n        \n           \n        \n           // Method can throw a RuntimeException\n\n        \n           \n        \n           virtual public int getAvgLength () {\n\n        \n           int count = 0;\n\n        \n           int total = 0;\n\n        \n           int len;\n\n        \n           while (true) {\n\n        \n           len = getLength ();\n\n        \n           if (len == 0) break;\n\n        \n           \n        \n           count ++;\n\n        \n           total += len;\n\n        \n           }\n\n        \n           return total / count;\n\n        \n           // Can throw ArithmeticException\n\n        \n           }\n\n        \n           }\n\n        \n           }\n\n        \n           */\n\n ",
        "before": "\nimport java.io.IOException;\n\nclass throwsExample {\n    char [] a;\n    int position;\n    // Method explicitly throws an exception\n    \n\n    int read () throws IOException {\n        if (position >= a.length) throw new IOException ();\n\n        return a [position ++];\n    }\n\n    // Method implicitly throws an exception\n    \n\n    String readUpTo (char terminator) throws IOException {\n        String s = new String ();\n        while (true) {\n            int c = read ();\n            // Can throw IOException\n            \n            if (c == - 1 || c == terminator) return s.toString ();\n\n            s = s + c;\n        }\n    }\n\n    // Method catches an exception internally\n    \n\n    int getLength () {\n        String s;\n        try {\n            s = readUpTo (':');\n        } catch (IOException e) {\n            return 0;\n        }\n        return s.length ();\n    }\n\n    // Method can throw a RuntimeException\n    \n\n    int getAvgLength () {\n        int count = 0;\n        int total = 0;\n        int len;\n        while (true) {\n            len = getLength ();\n            if (len == 0) break;\n\n            count ++;\n            total += len;\n        }\n        return total / count;\n        // Can throw ArithmeticException\n        \n    }\n\n}\n\n/* Throws example\n\n\n   using java.io.IOException;\n\n\n   {\n\n\n   class throwsExample {\n\n\n   char [] a;\n\n\n   int position;\n\n\n   // Method explicitly throws an exception\n\n\n   \n\n   virtual public int read () {\n\n\n   if (position >= a.length) throw new IOException ();\n\n\n   \n\n   return a [position ++];\n\n\n   }\n\n\n   \n\n   // Method implicitly throws an exception\n\n\n   \n\n   virtual public String readUpTo (char terminator) {\n\n\n   String s = new String ();\n\n\n   while (true) {\n\n\n   int c = read ();\n\n\n   // Can throw IOException\n\n\n   if (c == - 1 || c == terminator) return s.toString ();\n\n\n   \n\n   s = s + c;\n\n\n   }\n\n\n   }\n\n\n   \n\n   // Method catches an exception internally\n\n\n   \n\n   virtual public int getLength () {\n\n\n   String s;\n\n\n   try {\n\n\n   s = readUpTo (':');\n\n\n   } catch (IOException e) {\n\n\n   return 0;\n\n\n   }\n\n\n   return s.length ();\n\n\n   }\n\n\n   \n\n   // Method can throw a RuntimeException\n\n\n   \n\n   virtual public int getAvgLength () {\n\n\n   int count = 0;\n\n\n   int total = 0;\n\n\n   int len;\n\n\n   while (true) {\n\n\n   len = getLength ();\n\n\n   if (len == 0) break;\n\n\n   \n\n   count ++;\n\n\n   total += len;\n\n\n   }\n\n\n   return total / count;\n\n\n   // Can throw ArithmeticException\n\n\n   }\n\n\n   }\n\n\n   }\n\n\n\n   */\n "
    },
    {
        "hole_rule": "function changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function",
        "context": "function addBraces %\nreplace [program] \n\tNewImportDeclaration[repeat import_declaration]\n\tPHeader[package_header]\t    \n\tTypeDeclr[repeat type_declaration]\n\t%construct Length[number]\n\t%\t _[length NewImportDeclaration]\n\t%where Length[> 0]\n\tby\n\tNewImportDeclaration\n\tPHeader\t    \n\t'{\n\t    TypeDeclr\n\t'}\nend function\n\nfunction changeImportToUsing importDec[import_declaration]\n\tdeconstruct importDec\n\t    'import Name[package_or_type_name] DotStar[opt dot_star] '; \n\treplace *[repeat import_declaration]\n\tby\n\t    'using Name ';%remove DotStar\n\t    %decide how to change for proper C# equivelant API\nend function\n\nfunction changePackageToNamespace\n\treplace [opt package_header]\n\t    'package Name[package_name] '; \n\tby\n\t    'namespace Name \nend function\n\nfunction changeClassHeader\n% Java: [repeat modifier] 'class [class_name] [opt extends_clause] [opt implements_clause]\n% C#:   class-modifiersopt   class   identifier   class-base opt   class-body   ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\t\t%to set a constructor if needed\n\t\texport ClassName[class_name]\n\t\t\tName\t\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeInterfaceHeader\n% Java: [repeat modifier] 'interface [interface_name] [opt extends_clause] [opt implements_clause]\n% C#:   attributesopt interface-modifiersopt interface identifier interface-baseopt interface-body ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nfunction translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\n\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " using System;\nusing java.util;\n\n        public class FieldDeclaration {\n            // Compile time constants\n            \n            //1-instance variable\n            \n            const int i1 = 10;\n            //2-class variable with different literals\n            \n            const int i2 = 20;\n            const boolean DONE = true;\n            const String SERVER = \"localhost\";\n            // run time constants \n            \n            public static readonly long l1 = new Date ().getTime ();\n            // object reference as constant \n            \n            readonly Object v = new Object ();\n            // uninitialized final \n            \n            readonly float f;\n\n            internal FieldDeclaration () {\n                // unitialized final variable must be initialized in constructor\n                \n                f = 17.21f;\n            }\n\n        }\n\n ",
        "before": "\nimport java.util.*;\n\npublic class FieldDeclaration {\n    // Compile time constants\n    \n    //1-instance variable\n    \n    final int i1 = 10;\n    //2-class variable with different literals\n    \n    static final int i2 = 20;\n    final boolean DONE = true;\n    final String SERVER = \"localhost\";\n    // run time constants \n    \n    public static final long l1 = new Date ().getTime ();\n    // object reference as constant \n    \n    final Object v = new Object ();\n    // uninitialized final \n    \n    final float f;\n\n    FieldDeclaration () {\n        // unitialized final variable must be initialized in constructor\n        \n        f = 17.21f;\n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function isPublic\n\tmatch [modifier]\n\t\t'public\nend function",
        "context": "function addBraces %\nreplace [program] \n\tNewImportDeclaration[repeat import_declaration]\n\tPHeader[package_header]\t    \n\tTypeDeclr[repeat type_declaration]\n\t%construct Length[number]\n\t%\t _[length NewImportDeclaration]\n\t%where Length[> 0]\n\tby\n\tNewImportDeclaration\n\tPHeader\t    \n\t'{\n\t    TypeDeclr\n\t'}\nend function\n\nfunction changeImportToUsing importDec[import_declaration]\n\tdeconstruct importDec\n\t    'import Name[package_or_type_name] DotStar[opt dot_star] '; \n\treplace *[repeat import_declaration]\n\tby\n\t    'using Name ';%remove DotStar\n\t    %decide how to change for proper C# equivelant API\nend function\n\nfunction changePackageToNamespace\n\treplace [opt package_header]\n\t    'package Name[package_name] '; \n\tby\n\t    'namespace Name \nend function\n\nfunction changeClassHeader\n% Java: [repeat modifier] 'class [class_name] [opt extends_clause] [opt implements_clause]\n% C#:   class-modifiersopt   class   identifier   class-base opt   class-body   ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\t\t%to set a constructor if needed\n\t\texport ClassName[class_name]\n\t\t\tName\t\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeInterfaceHeader\n% Java: [repeat modifier] 'interface [interface_name] [opt extends_clause] [opt implements_clause]\n% C#:   attributesopt interface-modifiersopt interface identifier interface-baseopt interface-body ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nfunction translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\n\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " using System;\n\n        interface SharedConstants {\n            //J2C# Unsupported:Interface field must be removed manually\n            int NO = 0;\n            //J2C# Unsupported:Interface field must be removed manually\n            int YES = 1;\n            //J2C# Unsupported:Interface field must be removed manually\n            int MAYBE = 2;\n            //J2C# Unsupported:Interface field must be removed manually\n            int LATER = 3;\n            //J2C# Unsupported:Interface field must be removed manually\n            int SOON = 4;\n            //J2C# Unsupported:Interface field must be removed manually\n            int NEVER = 5;\n        }\n\n        public interface Callback {\n\n            void callback (int param);\n\n        }\n\n        class Client : Object, Callback {\n            // Implement Callback's interface\n            \n\n            virtual public void callback (int p) {\n                Console.WriteLine (\"callback called with \" + p);\n            }\n\n        }\n\n        class TestIface {\n\n            public static void Main (String [] args) {\n                Callback c = new Client ();\n                c.callback (42);\n            }\n\n        }\n\n ",
        "before": "\ninterface SharedConstants {\n    int NO = 0;\n    int YES = 1;\n    int MAYBE = 2;\n    int LATER = 3;\n    int SOON = 4;\n    int NEVER = 5;\n}\n\npublic interface Callback {\n\n    void callback (int param);\n\n}\n\nclass Client implements Callback {\n    // Implement Callback's interface\n    \n\n    public void callback (int p) {\n        System.out.println (\"callback called with \" + p);\n    }\n\n}\n\nclass TestIface {\n\n    public static void main (String args []) {\n        Callback c = new Client ();\n        c.callback (42);\n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function",
        "context": "function translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\n\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n",
        "after": " int position;\n// Method explicitly throws an exception\n\n\nvirtual public int read () {\n    if (position >= a.length) throw new IOException ();\n\n    return a [position ++];\n}\n\n// Method implicitly throws an exception\n\n\nvirtual public String readUpTo (char terminator) {\n    String s = new String ();\n    while (true) {\n        int c = read ();\n        // Can throw IOException\n        \n        if (c == - 1 || c == terminator) return s.toString ();\n\n        s = s + c;\n    }\n}\n\n// Method catches an exception internally\n\n\nvirtual public int getLength () {\n    String s;\n    try {\n        s = readUpTo (':');\n    } catch (IOException e) {\n        return 0;\n    }\n    return s.length ();\n}\n\n// Method can throw a RuntimeException\n\n\nvirtual public int getAvgLength () {\n    int count = 0;\n    int total = 0;\n    int len;\n    while (true) {\n        len = getLength ();\n        if (len == 0) break;\n\n        count ++;\n        total += len;\n    }\n    return total / count;\n    // Can throw ArithmeticException\n    \n}\n\n ",
        "before": "\nint position;\n// Method explicitly throws an exception\n\n\nint read () throws IOException {\n    if (position >= a.length) throw new IOException ();\n\n    return a [position ++];\n}\n\n// Method implicitly throws an exception\n\n\nString readUpTo (char terminator) throws IOException {\n    String s = new String ();\n    while (true) {\n        int c = read ();\n        // Can throw IOException\n        \n        if (c == - 1 || c == terminator) return s.toString ();\n\n        s = s + c;\n    }\n}\n\n// Method catches an exception internally\n\n\nint getLength () {\n    String s;\n    try {\n        s = readUpTo (':');\n    } catch (IOException e) {\n        return 0;\n    }\n    return s.length ();\n}\n\n// Method can throw a RuntimeException\n\n\nint getAvgLength () {\n    int count = 0;\n    int total = 0;\n    int len;\n    while (true) {\n        len = getLength ();\n        if (len == 0) break;\n\n        count ++;\n        total += len;\n    }\n    return total / count;\n    // Can throw ArithmeticException\n    \n}\n\n "
    },
    {
        "hole_rule": "function changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function",
        "context": "function changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\n\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " catch (System.Exception e) {\n} ",
        "before": "\n"
    },
    {
        "hole_rule": "function changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function",
        "context": "function addBraces %\nreplace [program] \n\tNewImportDeclaration[repeat import_declaration]\n\tPHeader[package_header]\t    \n\tTypeDeclr[repeat type_declaration]\n\t%construct Length[number]\n\t%\t _[length NewImportDeclaration]\n\t%where Length[> 0]\n\tby\n\tNewImportDeclaration\n\tPHeader\t    \n\t'{\n\t    TypeDeclr\n\t'}\nend function\n\nfunction changeImportToUsing importDec[import_declaration]\n\tdeconstruct importDec\n\t    'import Name[package_or_type_name] DotStar[opt dot_star] '; \n\treplace *[repeat import_declaration]\n\tby\n\t    'using Name ';%remove DotStar\n\t    %decide how to change for proper C# equivelant API\nend function\n\nfunction changePackageToNamespace\n\treplace [opt package_header]\n\t    'package Name[package_name] '; \n\tby\n\t    'namespace Name \nend function\n\nfunction changeClassHeader\n% Java: [repeat modifier] 'class [class_name] [opt extends_clause] [opt implements_clause]\n% C#:   class-modifiersopt   class   identifier   class-base opt   class-body   ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\t\t%to set a constructor if needed\n\t\texport ClassName[class_name]\n\t\t\tName\t\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeInterfaceHeader\n% Java: [repeat modifier] 'interface [interface_name] [opt extends_clause] [opt implements_clause]\n% C#:   attributesopt interface-modifiersopt interface identifier interface-baseopt interface-body ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nfunction translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\n\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " using System;\n\n        class StaticInitTest {\n            String instMember = initInstance ();\n            String staMember = initStatic ();\n\n            internal StaticInitTest () {\n                Console.WriteLine (\"In instance constructor\");\n            }\n\n            static StaticInitTest () {\n                Console.WriteLine (\"In static constructor\");\n            }\n\n            static String initInstance () {\n                Console.WriteLine (\"Initializing instance variable\");\n                return \"instance\";\n            }\n\n            static String initStatic () {\n                Console.WriteLine (\"Initializing static variable\");\n                return \"static\";\n            }\n\n            static void doStuff () {\n                Console.WriteLine (\"Invoking static DoStuff() method\");\n            }\n\n            public static void Main (String [] args) {\n                Console.WriteLine (\"Beginning main()\");\n                StaticInitTest.doStuff ();\n                StaticInitTest sti = new StaticInitTest ();\n                Console.WriteLine (\"Completed main()\");\n            }\n\n        }\n\n        /* Static initialization block is transformed into static constructor\n\n        \n           */\n\n ",
        "before": "\nclass StaticInitTest {\n    String instMember = initInstance ();\n    String staMember = initStatic ();\n\n    StaticInitTest () {\n        System.out.println (\"In instance constructor\");\n    }\n\n    static {\n        System.out.println (\"In static constructor\");\n    }\n\n    static String initInstance () {\n        System.out.println (\"Initializing instance variable\");\n        return \"instance\";\n    }\n\n    static String initStatic () {\n        System.out.println (\"Initializing static variable\");\n        return \"static\";\n    }\n\n    static void doStuff () {\n        System.out.println (\"Invoking static DoStuff() method\");\n    }\n\n    public static void main (String [] args) {\n        System.out.println (\"Beginning main()\");\n        StaticInitTest.doStuff ();\n        StaticInitTest sti = new StaticInitTest ();\n        System.out.println (\"Completed main()\");\n    }\n\n}\n\n/* Static initialization block is transformed into static constructor\n\n\n   */\n "
    },
    {
        "hole_rule": "function pkgRef2TclId Ref [reference]\n    replace [repeat tcl_id]\n\t_ [repeat tcl_id]\n    construct RefIds [repeat id]\n\t_ [^ Ref]\n    deconstruct RefIds\n\tFirstId [id] RestId [repeat id]\n    construct TclIdHead [tcl_id_head]\n\tFirstId\n    construct TclIdPart [repeat tcl_id_part]\n\t_ [addTclIdPart each RestId]\n    by\n\tTclIdHead TclIdPart\nend function",
        "context": "function addClassMetaAndClass\n    replace * [package_declaration]\n\tCmts [repeat comment_NL] \n\tPkgHead [opt package_header]\n\tImpDecl [repeat import_declaration] \n\tTypeDecl [repeat type_declaration]\n    deconstruct TypeDecl \n\t_ [repeat modifier] 'class ClassName [id] \n\tExtends [opt extends_clause] Implements [opt implements_clause] \n\t_ [class_body]\n\t_ [repeat type_declaration]\n    construct MetaClassName [id]\n\tClassName [_ 'metapapa]\n    construct ExtendClasses [repeat reference]\n\t_ [^ Extends]\n    construct Parents [repeat reference]\n\tExtendClasses [removeNonIdRef]\n    construct TclParents [repeat tcl_id]\n\t_ [pkgRef2TclId each Parents]\n    by\n\tCmts PkgHead ImpDecl \n\t'Class 'create MetaClassName '-superclass '{ 'Class '} '-slots '{ '}\n\tMetaClassName 'create ClassName '-superclass '{ 'Class TclParents '} \n\t'-slots '{ '}\n\tTypeDecl\nend function\n\nfunction constructorTransforms\n    replace [program]\n\tP [program]\n    by\n\tP [transformThisInConstructor] [transformSuperInConstructors]\nend function\n\nfunction transformExpressions\n    replace [program]\n\tP [program]\n    by\n\tP \n\t  [transformNewExpr]\n\n\t  [transformExceptions]\n\t  [transformConditionalStatements]\n\n\t  [transformVarAssignment]\n\n\n\t  [convertUnaryOpFirst]\n\t  [convertUnaryOpInMultiplicative]\nend function\n\nrule transformDefaultAttributes\n    replace [field_declaration]\n\t_ [repeat modifier] _ [type_specifier] Name [id] _ [opt generic_parameter] \n\t'= Literal [literal] '; \n    by\n\t'Attribute Name '-default Literal \nend rule\n\nrule transformInitAttributesNew\n    replace [field_declaration]\n\t_ [repeat modifier] _ [type_specifier] Name [id] _ [opt generic_parameter] \n\t'= New [class_instance_creation_expression] ';\n    construct NewCmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    by\n\t'Attribute Name '-initcmd '{ NewCmd '}\nend rule\n\nrule teleportClassStaticAttributes\n    replace $ [repeat type_declaration]\n\t%MetaClass\n\tMetaBase [id] MetaCreate [opt 'create] MetaClassName [id] MetaSuper [opt xotcl_class_superclasses]\n\t'-slots '{ '}\n\t%Class\n\tClassBase [id] ClassCreate [opt 'create] ClassName [id] ClassSuper [opt xotcl_class_superclasses]\n\t'-slots '{ '}\n\t%Java Class\n\tJClassHeader [class_header] JBody [class_or_interface_body]\n\t_ [repeat type_declaration]\n    construct JBodyElements [repeat class_body_declaration]\n\t_ [^ JBody]\n    construct JFields [repeat field_declaration]\n\t_ [^ JBody]\n    by\n\tMetaBase MetaCreate MetaClassName MetaSuper '-slots '{ JFields [removeNonStaticField] '}\n\tClassBase ClassCreate ClassName ClassSuper '-slots '{ JFields [removeStaticField] '}\n\tJClassHeader JBody \nend rule\n\nrule teleportClassStaticMethods\n    replace $ [repeat type_declaration]\n\t%Class\n\tClassBase [xotcl_class]\n\t%Java Class\n\tJClass [class_header] JBody [class_or_interface_body]\n\t_ [repeat type_declaration]\n    construct JMethods [repeat method_or_constructor_declaration]\n\t_ [^ JBody]\n    construct InstanceMethods [repeat method_or_constructor_declaration]\n\tJMethods [transformNonStaticMethod2Proc]\n    by\n\tClassBase\n\tJMethods [transformStaticMethod2Proc] [. InstanceMethods]\nend rule\n\nrule transformMethodsHeaders\n    replace $ [xotcl_class_with_methods]\n\tClass [xotcl_class]\n\tMethods [repeat method_or_constructor_declaration]\n    deconstruct Class\n\t_ [id] _ [opt 'create] \n\tName [id] _ [opt xotcl_class_superclasses] _ [opt xotcl_class_slots] \n    by\n\tClass\n\tMethods [transformNonStaticMethodHeader Name] \n\t\t[transformStaticMethodHeader Name]\n\t\t[transformSynchroNonStaticMethodHeader Name] \n\t\t[transformSynchroStaticMethodHeader Name]\n\t\t[transformConstructorHeader]\nend rule\n\nrule transformParameterVarRefs\n    replace $ [repeat method_or_constructor_declaration]\n \tMethod [method_or_constructor_declaration]\n \tMethods [repeat method_or_constructor_declaration]\n    deconstruct Method\n\t_ [id] _ [xotcl_proc_scope] _ [id] '{ VarIds [repeat id] '} _ [tcl_cmd_set]\n    by\n\tMethod [transformJavaVar2TclVar VarIds]\n\tMethods \nend rule\n\nrule transformDotRefs\n    replace [program]\n\tP [program]\n    where \n\tP [?transformRefMethodFirst1]\n\t  [?transformRefMethodFirst1In]\n\t  \n\t  [?transformRefMethodFirst]\n\t  [?transformRefMethod]\n\t  [?transformRefIdFirst]\n\t  [?transformRefId]\n\t  [?transformRefArray]\n    by \n\tP  [transformRefMethodFirst1]\n\t   [transformRefMethodFirst1In]\n  \n\t   [transformRefMethodFirst]\n\t   [transformRefMethod]\n\n\t   [transformRefIdFirst]\n\t   [transformRefId]\n\t   [transformRefArray] \nend rule\n\nrule varRef2TclRef\n    replace $ [reference]\n\tRef [reference]\n    construct RefNew [reference]\n\tRef [varRef2TclClassVar Ref]\n\t    [varRef2TclClassStaticVar Ref]\n\t    [varRef2TclVarSimple Ref]\n\t    [varRefThis2TclThis Ref]\n    by\n\tRefNew\nend rule\n\nrule untransformForUpdate\n    replace $ [tcl_for_cmd]\n\t'for Init [tcl_cmd_set] Cond [tcl_cmd_set] Upd [tcl_cmd_set] Block [tcl_block]\n    by\n\t'for Init Cond Upd [untransformForUpdateMores] Block \nend rule\n\n\n\nrule removeNonIdRef\n    replace [repeat reference]\n\tFirst [reference] Rest [repeat reference]\n    deconstruct First\n\tPrima [primitive_type] _ [repeat dimension] _ [repeat component]\n    by\n\tRest\nend rule\n\nrule transformSuperInConstructors\n    replace $ [constructor_declaration]\n\tConstructor [constructor_declaration]\n    by\n\tConstructor [addSuperInConstructorIfAbsent Constructor]\n\t\t    [transformSuperInConstructor Constructor]\n\t\t    [removeSuperInConstructor]\nend rule\n\nrule transformThisInConstructor \n    replace $ [constructor_declaration]\n\tConstructor [constructor_declaration]\n    by\n\tConstructor [transformThisStatement Constructor]\nend rule\n\nrule transformVarAssignment\n    replace [declaration_or_statement]\n\t Ref [reference] '= Butt [assignment_expression] ';\n    construct TclCmd [repeat tcl_expr_more]\n\t_ [transformJavaLocalScopeVar Ref] \n\n\t  [transformJavaClassVar Ref] \n\t  [transformJavaClassStaticVar Ref] \n\n\t  [transformJavaThisVar Ref] \n\t  [transformJavaThisStaticVar Ref] \n\n\t  [complexRefAssignment Ref]\n\t  [assignToArrayRef Ref]\n    construct TclLit [tcl_expr_more]\n\t_ [transformArithAssExp Butt]\n\t  [transformLiteralAssExp Butt]\n\t  [transformRefAssExp Butt]\n\t  [transformNewAssExp Butt]\n    by\n\tTclCmd [. TclLit] '%\nend rule\n\nrule transformExceptions\n    replace $ [program]\n\tP [program]\n    by\n\tP [transformThrowStmt]\n\t  [transformTryCatch]\nend rule\n\nrule transformConditionalStatements\n    replace $ [program]\n\tP [program]\n    by\n\tP [transformIfElse]\n\t  [transformIf]\n%\t  [transformCondChoice]\n\t  [transformWhile]\n\t  [transformSwitch]\n\t  [transformFor]\n\t  [transformForeach]\nend rule\n\nrule convertUnaryOpInMultiplicative\n    replace $ [multiplicative_expression]\n\tMulti [multiplicative_expression]\n    deconstruct Multi\n\tRef [id] Op [pre_inc_dec]\n    by\n\tMulti [convertUnaryOpMultiMy]\n\t      [convertUnaryOpMultiClass]\n\t      [convertUnaryOpMultiLocal]\nend rule\n\nrule convertUnaryOpFirst\n    replace $ [declaration_or_statement]\n\tDecl [declaration_or_statement]\n    deconstruct Decl\n\tRef [id] Op [pre_inc_dec] ';\n    by\n\tDecl [convertUnaryOpFirstMy]\n\t     [convertUnaryOpFirstClass]\n\t     [convertUnaryOpFirstLocal]\nend rule\n\nrule transformNewExpr\n    replace $ [multiplicative_expression]\n\tNew [class_instance_creation_expression]\n    construct Cmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    deconstruct Cmd\n\t'[ Expr [tcl_expr] ']\n    by\n\t'[ Expr ']\nend rule\n\nfunction convertNewClassInstance New [class_instance_creation_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct New\n\t'new JClassName [reference] '( Args [list argument] ') _ [opt class_body]\n    construct TmpName [repeat tcl_id]\n\t_ [pkgRef2TclId JClassName]\n    deconstruct * TmpName\n\tClassName [tcl_id]\n    construct Args1 [repeat expression]\n\t_ [argumentToExpression each Args]\n    construct TclArgs [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args1]\n    by\n\t'[ ClassName ClassName TclArgs ']\nend function\n\nrule removeStaticField\n    replace [repeat field_declaration]\n\tFirst [field_declaration] Rest [repeat field_declaration]\n    where \n\tFirst [is_static]\n    by\n\tRest\nend rule\n\nrule removeNonStaticField\n    replace [repeat field_declaration]\n\tFirst [field_declaration] Rest [repeat field_declaration]\n    where not\n\tFirst [is_static]\n    by\n\tRest\nend rule\n\nrule transformStaticMethod2Proc\n    replace  [repeat method_or_constructor_declaration]\n\tMethod [method_or_constructor_declaration] \n\tMethods [repeat method_or_constructor_declaration]\n    where not\n\tMethod [is_static]\n    by\n\tMethods\nend rule\n\nrule transformNonStaticMethod2Proc\n    replace  [repeat method_or_constructor_declaration]\n\tMethod [method_or_constructor_declaration] \n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tMethod [is_static]\n    by\n\tMethods\nend rule\n\nrule transformNonStaticMethodHeader ClassName [id]\n    replace [method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n    where not\n\tJModifiers [is_synchronized]\n    where not\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    by\n\tClassName 'instproc JName '{ ParamsNames '}  Body\nend rule\n\nrule transformStaticMethodHeader ClassName [id]\n    replace [method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n    where not\n\tJModifiers [is_synchronized]\n    where\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    by\n\tClassName 'proc JName '{ ParamsNames '}  Body\nend rule\n\nrule transformSynchroNonStaticMethodHeader ClassName [id]\n    replace [repeat method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tJModifiers [is_synchronized]\n    where not\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n    construct JSynchName [id]\n\tJName [_ 'synchrobaby]\n    construct MutexName [id]\n\tClassName [_ JName] [_ 'mutex]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'thread::mutex 'lock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'set 'cought 0 '%\n\t'#call the real method implementation\n\t'if '{ '[ 'catch '{ 'my JSynchName ParamsAsVars '} 'result '] '} '{\n\t'set 'cought 1 '%\n\t'} \n\t'thread::mutex 'unlock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'#transfer exception to the upper level\n\t'if '{ '$cought '} '{ 'error '$result '} \n\t'}\n    by\n\tClassName 'instproc JName '{ ParamsNames '} ProcBody \n\tClassName 'instproc JSynchName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformSynchroStaticMethodHeader ClassName [id]\n    replace [repeat method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tJModifiers [is_synchronized]\n    where\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n    construct JSynchName [id]\n\tJName [_ 'synchrobaby]\n    construct MutexName [id]\n\tClassName [_ JName] [_ 'mutex]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'thread::mutex 'lock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'set 'cought 0 '%\n\t'#call the real method implementation\n\t'if '{ '[ 'catch '{ 'my JSynchName ParamsAsVars '} 'result '] '} '{\n\t'set 'cought 1 '%\n\t'} \n\t'thread::mutex 'unlock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'#transfer exception to the upper level\n\t'if '{ '$cought '} '{ 'error '$result '} \n\t'} \n    by\n\tClassName 'proc JName '{ ParamsNames '} ProcBody \n\tClassName 'proc JSynchName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformConstructorHeader\n    replace [repeat method_or_constructor_declaration]\n \tConstructor [constructor_declaration]\n \tMethods [repeat method_or_constructor_declaration]\n    deconstruct Constructor\n\tJModifiers [repeat modifier] \n\tJClassName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') \n\t_ [opt throws] Body [block]\n\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n\n    construct ParamsString [id]\n\t_ [buildParameterTypeList each Parameters]\n    construct XNew [id]\n\t_ [+ JClassName] \n    construct XNewBody [id]\n\t_ [+ JClassName] [+ \"_body\"]\n    construct XNewName [id]\n\tXNew [+ ParamsString]\n    construct XNewBodyName [id]\n\tXNewBody [+ ParamsString]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'#create new object\n\t'set 'obj '[ JClassName 'new '] '%\n\t'#call the constructor\n\t'$obj XNewBodyName ParamsAsVars '%\n\t'#return new object after constructor's work is done\n\t'return '$obj '%\n\t'} \n    by\n\tJClassName 'proc XNewName '{ ParamsNames '} ProcBody\n\tJClassName 'instproc XNewBodyName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformJavaVar2TclVar VarIds [repeat id]\n    replace $ [reference]\n\tId [id] _ [repeat dimension] Comp [repeat component]\n    construct Len [number]\n\t_ [length Comp]\n    where \n\tLen [= 0]\n    where\n\tId [= each VarIds]\n    by\n\t'$ Id\nend rule\n\nrule transformRefMethodFirst1\n    replace [declaration_or_statement]\n\tId [id] _ [repeat dimension] Comps [repeat component] ';\n    construct CompsLen [number]\n\t_ [length Comps]\n    where \n\tCompsLen [= 1]\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'my Id Exps '%\nend rule\n\nrule transformRefMethodFirst1In\n    replace [reference]\n\tId [id] _ [repeat dimension] Comps [repeat component] \n    construct CompsLen [number]\n\t_ [length Comps]\n    where \n\tCompsLen [= 1]\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'[ 'my Id Exps '] \nend rule\n\nrule transformRefMethodFirst\n    replace [declaration_or_statement]\n\tId [id] Dims [repeat dimension] Comps [repeat component] ';\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct CompsLenFinal [number]\n\t_ [length Comps] [- 2]\n    construct NewCompsTmp [repeat component]\n\tComps [head CompsLen]\n    construct NewComps [repeat component]\n\tComps [head CompsLenFinal]\n    construct RefIds [repeat id]\n\t_ [^ NewCompsTmp]\n    deconstruct * RefIds\n\tMethodName [id]\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\tId [this2my] Dims NewComps MethodName Exps '%\nend rule\n\nrule transformRefMethod\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct CompsLenFinal [number]\n\t_ [length Comps] [- 2]\n    construct NewCompsTmp [repeat component]\n\tComps [head CompsLen]\n    construct NewComps [repeat component]\n\tComps [head CompsLenFinal]\n    construct RefIds [repeat id]\n\t_ [^ NewCompsTmp]\n    deconstruct * RefIds\n\tMethodName [id]\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'[ Id [this2my] Dims NewComps MethodName Exps '] \nend rule\n\nrule transformRefIdFirst\n    replace [declaration_or_statement]\n\tId [id] _ [repeat dimension] Comps [repeat component] '= AssExp [assignment_expression] ';\n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    by\n\tId NewComps 'set VarId AssExp '%\nend rule\n\nrule transformRefId\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps\n    by\n\t'[ NewRef 'set VarId ']\nend rule\n\nrule transformRefArray\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\tDim [dimension]\n\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n\n\n    deconstruct * NewComps\n\t'. VarId [id]\n    construct CompsLen2 [number]\n\t_ [length NewComps] [- 1]\n    construct DimComp [component]\n\tDim\n    construct NewComps2 [repeat component]\n\tNewComps [head CompsLen2] % [. DimComp]\n\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps2 \n\n    construct TmpDims [repeat dimension]\n\tDim\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim TmpDims]\n\n    by\n\t'[ NewRef 'set VarId TclDim ']\nend rule\n\nfunction varRef2TclClassVar Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where \n\tId [is_class_var]\n    by\n\t'[ 'my 'set Id TclDim ']\nend function\n\nfunction varRef2TclClassStaticVar Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ '[ 'my 'class '] 'set Id TclDim ']\nend function\n\nfunction varRef2TclVarSimple Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where all \n\tId [>= 'a] [<= 'z]\n    where not\n\tId [is_staticclass_var]\n\t   [is_class_var]\n    deconstruct not Id\n\t'my\n    by\n\t'$ Id TclDim\nend function\n\nfunction varRefThis2TclThis Ref [reference]\n    deconstruct Ref\n\t'this\n    replace [reference]\n\t_ [reference]\n    by\n\t'[ 'self ']\nend function\n\nrule untransformForUpdateMores\n%    skipping [tcl_expr_more]\n    replace $ [tcl_expr]\n\tExp [tcl_expr]\n    deconstruct Exp\n\tRef [reference]\n    deconstruct Ref\n\t'[ More [tcl_expr] ']\n    by\n\tMore\nend rule\n\nfunction addTclIdPart Id [id]\n    replace [repeat tcl_id_part]\n\tParts [repeat tcl_id_part]\n    construct Part [tcl_id_part]\n\t':: Id\n    by\n\tParts [. Part]\nend function\n\nrule addSuperInConstructorIfAbsent Constructor [constructor_declaration] \n    replace $ [constructor_body]\n\t'{ Decls [repeat declaration_or_statement] '}\n    where not\n\tDecls [?transformSuperInConstructor Constructor]\n    by\n\t'{\n\t'super '( ') ';\n\tDecls '}\nend rule\n\nrule transformSuperInConstructor Constructor [constructor_declaration] \n    replace $ [declaration_or_statement]\n\t'super MethArg [method_argument] ';\n    import JClassOrigin [class_declaration]\n    deconstruct JClassOrigin\n\t_ [repeat modifier] 'class _ [class_name] \n\tExtends [opt extends_clause] \n\t_ [opt implements_clause] _ [class_body]\n    construct ExtendClasses [repeat reference]\n\t_ [^ Extends]\n    construct Parents [repeat reference]\n\tExtendClasses [removeNonIdRef]\n    deconstruct * ExtendClasses \n\tParentName [id]\n    construct Args [repeat expression]\n\t_ [^ MethArg]\n    construct VarIds [repeat id]\n\t_ [^ Args]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    construct TypeString [id]\n\t_ [buildVarsTypeList4Constructor Constructor each VarIds]\n    construct XNewName [id]\n\t_ [+ ParentName] [+ \"_body\"] [+ TypeString]\n    by\n\t'my XNewName Exps '% \nend rule\n\nrule removeSuperInConstructor \n    replace [repeat declaration_or_statement]\n\t'super MethArg [method_argument] ';\n\tDecls [repeat declaration_or_statement]\n    by\n\tDecls\nend rule\n\nrule transformThisStatement Constructor [constructor_declaration] \n    replace $ [declaration_or_statement]\n\t'this MethArg [method_argument] ';\n    deconstruct Constructor\n\t_ [repeat modifier] ClassName [id] _ [opt generic_parameter]\n\t'( _ [list formal_parameter] ')  _ [opt throws] _ [constructor_body]\n    construct Args [repeat expression]\n\t_ [^ MethArg]\n    construct VarIds [repeat id]\n\t_ [^ Args]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    construct TypeString [id]\n\t_ [buildVarsTypeList4Constructor Constructor each VarIds]\n    construct XNewName [id]\n\t_ [+ ClassName] [+ \"_body\"] [+ TypeString]\n    by\n\t'my XNewName Exps '% \nend rule\n\nfunction transformJavaLocalScopeVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    by\n\t'set Id TclDim\nend function\n\nfunction transformJavaClassVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    where \n\tId [is_class_var]\n    by\n\t'my 'set Id TclDim\nend function\n\nfunction transformJavaClassStaticVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ 'my 'class '] 'set Id TclDim\nend function\n\nfunction transformJavaThisVar Ref [reference]\n    deconstruct Ref\n\t'this '. Id [id] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_class_var]\n    by\n\t'my 'set Id \nend function\n\nfunction transformJavaThisStaticVar Ref [reference]\n    deconstruct Ref\n\t'this '. Id [id] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ 'my 'class '] 'set Id \nend function\n\nfunction complexRefAssignment Ref [reference]\n    deconstruct Ref\n\tId [id] Dim [repeat dimension] Comps [repeat component+] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    construct ExprLen [number]\n\t_ [length Expr]\n    where not\n\tExprLen [> 0]\n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    construct NewRef [reference]\n\tId Dim NewComps\n    by\n\tNewRef 'set VarId \nend function\n\nfunction assignToArrayRef Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n\n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    construct ExprLen [number]\n\t_ [length Expr]\n    where not\n\tExprLen [> 0]\n\n    deconstruct * Comps\n\tDim [dimension]\n\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n\n\n    deconstruct * NewComps\n\t'. VarId [id]\n    construct CompsLen2 [number]\n\t_ [length NewComps] [- 1]\n    construct DimComp [component]\n\tDim\n    construct NewComps2 [repeat component]\n\tNewComps [head CompsLen2] % [. DimComp]\n\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps2 \n\n    construct TmpDims [repeat dimension]\n\tDim\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim TmpDims]\n\n    by\n        NewRef 'set VarId TclDim \nend function\n\nfunction transformArithAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    where\n\tButt [is_arithmetic]\n    construct TclRef [tcl_expr_more]\n\t'[ 'expr '{ Butt '} ']\n    by\n\tTclRef\nend function\n\nfunction transformLiteralAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tLiteral [literal]\n    by\n\tLiteral\nend function\n\nfunction transformRefAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tRef [reference]\n    by\n\tRef\nend function\n\nfunction transformNewAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tNew [class_instance_creation_expression]\n    construct NewCmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    by\n\tNewCmd\nend function\n\nrule transformTryCatch\n    replace $ [declaration_or_statement]\n\t'try Block [block] Catches [repeat catch_clause] _ [opt finally_clause]\n    deconstruct Block\n\t'{ BlockStmts [repeat declaration_or_statement] '}\n    construct CatchesStmts [repeat declaration_or_statement]\n\t_ [^ Catches]\n    construct CatchBlock [xotcl_proc_body]\n\tCatchesStmts\n    by\n\t'if '{ '[ 'catch '{ BlockStmts '} 'result '] '} '{\n\tCatchBlock\n\t'} \nend rule\n\nrule transformThrowStmt\n    replace $ [declaration_or_statement]\n\t_ [throw_statement]\t\n    by\n\t'error '$result\nend rule\n\nrule transformIf\n    replace [declaration_or_statement]\n\t'if '( IfExpr [expression] ') _ [repeat comment_NL]\n\tStmt [statement] \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct IfTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    construct TclIf [tcl_if_cmd]\n\t'if '{ IfExpr '} IfTclBlock\n    by\n\tTclIf\nend rule\n\nrule transformIfElse\n    replace [declaration_or_statement]\n\t'if '( IfExpr [expression] ') IfStmt [statement] _ [repeat comment_NL]\n\t'else ElseStmt [statement]\n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct IfTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok IfStmt] \n\t\t      [statementBlockToTclBlock IfStmt]\n    construct ElseTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok ElseStmt] \n\t\t      [statementBlockToTclBlock ElseStmt]\n    deconstruct IfTclBlock\n\t'{ IfBody [opt xotcl_proc_body] '}\n    construct TclIf [tcl_if_cmd]\n\t'if '{ IfExpr '} '{ IfBody '} 'else ElseTclBlock\n    by\n\tTclIf\nend rule\n\nrule transformCondChoice\n    replace $ [assignment_expression]\n\tCond [conditional_expression]\n    deconstruct Cond\n\tUna [unary_expression] '? Exp [expression] ': CondChExp [conditional_expression]\n    by\n\t'[ 'expr '{ Una '? Exp  ': CondChExp '} ']\nend rule\n\nrule transformWhile\n    replace [declaration_or_statement]\n\t'while '( Expr [expression] ') Stmt [statement] \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct WhileTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    construct TclWhile [tcl_while_cmd]\n\t'while '{ Expr '}  WhileTclBlock\n    by\n\tTclWhile\nend rule\n\nrule transformSwitch\n    replace [declaration_or_statement]\n\t'switch '( Expr [expression] ') '{ JAlts [repeat switch_alternative] '}\n    construct Alts [repeat tcl_switch_entry]\n\t_ [transformSwitchAlternatives each JAlts] \n    construct TclSwitch [tcl_switch_cmd]\n\t'switch Expr '{ Alts '} \n    by\n\tTclSwitch\nend rule\n\nrule transformFor\n    replace [declaration_or_statement]\n\t'for '( ForInit [for_init] \n\tForExpr [opt expression] '; \n\tForUpd [list expression] ') \n\tStmt [statement] \n    construct ForUpdSeq [repeat expression]\n\t_ [. each ForUpd]\n    construct TclCmdLists [repeat tcl_cmd_list]\n\t_ [expressionListToTclCmdList ForUpdSeq] \n\t  [transformVarAssignmentFor]\n    construct TclForInit [repeat tcl_cmd_list]\n\t_ [transformForInitStmt1 ForInit] \n\t  [transformForInitStmt2 ForInit]\n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct ForTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    by\n\t'for '{ TclForInit '} \n\t'{ ForExpr '} '{ TclCmdLists '}\n\tForTclBlock\nend rule\n\nrule transformForeach\n    replace [declaration_or_statement]\n\t'for '( \n\t%for_in_init\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t': Expr [expression] ')\n\t\tStmt [statement]        \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct ForTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    by\n\t'foreach '{ Id '} '{ Expr '}\n\tForTclBlock\nend rule\n\nrule convertUnaryOpMultiLocal\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpMultiMy\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    where \n\tRef [is_class_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'my 'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpMultiClass\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    where \n\tRef [is_staticclass_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'[ 'my 'class '] 'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpFirstLocal\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nrule convertUnaryOpFirstMy\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    where \n\tRef [is_class_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'my 'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nrule convertUnaryOpFirstClass\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    where \n\tRef [is_staticclass_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'[ 'my 'class '] 'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nfunction expressionSeq2TclExprMoreSeq Expressions [repeat expression]\n    replace [repeat tcl_expr_more]\n\tEMore [repeat tcl_expr_more]\n    deconstruct Expressions\n\tExpr [expression] Exprs [repeat expression]\n    construct TclEMore [repeat tcl_expr_more]\n\tExpr\n    by\n\tEMore [. TclEMore] [expressionSeq2TclExprMoreSeq Exprs]\nend function\n\nfunction argumentToExpression Argument [argument]\n    replace [repeat expression]\n\tExps [repeat expression]\n    deconstruct Argument\n\tExp [expression]\n    by\n\tExps [. Exp]\nend function\n\nfunction is_static \n    match * [modifier]\n\t'static\nend function\n\nfunction is_synchronized\n    match * [modifier]\n\t'synchronized\nend function\n\nfunction transformId2TclVar Id [id]\n    replace [repeat tcl_expr_more]\n\tCmds [repeat tcl_expr_more]\n    construct Var [tcl_expr_more]\n\t'$ Id\n    by\n\tCmds [. Var]\nend function\n\nfunction buildParameterTypeList Parameter [formal_parameter]\n    replace [id]\n\tParams [id] \n    construct TypeName [id]\n\t_ [extractPrimitiveTypeName Parameter]\n\t  [extractReferenceTypeName Parameter]\n    by\n\tParams [_ TypeName]\nend function\n\nfunction this2my \n    replace [id]\n\t'this\n    by\n\t'my\nend function\n\nfunction dim2TclDim Dims [repeat dimension]\n    construct DimLen [number]\n\t_ [length Dims]\n    where \n\tDimLen [= 1]\n    deconstruct Dims\n\tDim [dimension] _ [repeat dimension]\n    deconstruct Dim\n\t'[ Expr [expression] ']\n    replace [repeat tcl_array_dimension]\n\t_ [repeat tcl_array_dimension]\n    by\n\t'( Expr ')\nend function\n\nfunction is_class_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_nonstatic_var Id]\nend function\n\nfunction is_staticclass_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_static_var Id]\nend function\n\nfunction buildVarsTypeList4Constructor Constructor [constructor_declaration] VarId [id]\n    replace [id]\n\tIds [id]\n    construct Tmp1 [constructor_declaration]\n\tConstructor [findVarTypeInConstructorParams VarId]\n    import TypeName [id]\n    by\n\tIds [+ TypeName]\nend function\n\nrule is_arithmetic\n    match $ [any]\n\tAny [any]\n    where \n\tAny [istype 'add_op]\n\t    [istype 'mult_op]\n\t    [istype 'unary_op]\n\t    [istype 'or_conditional_and_expression]\n\t    [istype 'and_inclusive_or_expression]\n\t    [istype 'or_exclusive_or_expression]\n\t    [istype 'or_and_expression]\n\t    [istype 'and_equality_expression]\n\t    [istype 'equality_op]\n\t    [istype 'relational_op]\n\t    [istype 'shif_op]\n\t    [istype 'conditional_choice]\nend rule\n\nfunction statementOneDeclToTclBlcok Stmt [statement]\n    replace [tcl_block]\n\t_ [tcl_block]\n    deconstruct not Stmt\n\t_ [block]\n    construct Decl [declaration_or_statement]\n\tStmt\n    by\n\t'{ Decl '}\nend function\n\nfunction statementBlockToTclBlock Stmt [statement]\n    replace [tcl_block]\n\t_ [tcl_block]\n    deconstruct Stmt\n\t'{ Decls [repeat declaration_or_statement] '}\n    by\n\t'{ Decls '}\nend function\n\nfunction transformSwitchAlternatives JAlt [switch_alternative]\n    replace [repeat tcl_switch_entry]\n\tEntries [repeat tcl_switch_entry]\n    deconstruct JAlt\n\t'case Label [constant_expression] ': Decls [repeat declaration_or_statement]\n    construct SwitchLabel [tcl_cmd]\n\t_ [switchLabelConvertNum Label] [switchLabelConvertChar Label]\n    construct Entry [tcl_switch_entry]\n\tSwitchLabel '{ Decls '} \t\n    by\n\tEntries [. Entry]\nend function\n\nfunction expressionListToTclCmdList Expressions [repeat expression]\n    replace [repeat tcl_cmd_list]\n\t_  [repeat tcl_cmd_list]\n    deconstruct Expressions\n\tExpr [expression] Exprs [repeat expression]\n    construct TclCmdList [tcl_cmd_list]\n\tExpr\n    by\n\tTclCmdList [addExpToTclCmdList each Exprs]\nend function\n\nfunction transformForInitStmt1 ForInit [for_init]\n    deconstruct ForInit\n\tExprs [list expression] ';\n    replace [repeat tcl_cmd_list]\n\t_ [repeat tcl_cmd_list]\n    construct ExprSeq [repeat expression]\n\t_ [. each Exprs]\n    by\n\t_ [expressionListToTclCmdList ExprSeq] [transformVarAssignmentFor]\nend function\n\nfunction transformForInitStmt2 ForInit [for_init]\n    deconstruct ForInit\n\tLocalDecl [declaration_or_statement] \n    construct TmpDecls [repeat declaration_or_statement]\n\tLocalDecl\n    construct TmpDecls2 [repeat declaration_or_statement]\n\tTmpDecls [splitLocalVarDeclarations] [localVarDecl2Assignment]\n    deconstruct TmpDecls2\n\tDecl1 [declaration_or_statement] _ [repeat declaration_or_statement]\n    replace [repeat tcl_cmd_list]\n\t_ [repeat tcl_cmd_list]\n    by\n%\tLocalDecl\n\tTmpDecls2\nend function\n\nrule transformVarAssignmentFor\n    replace [repeat tcl_expr_more]\n\t Ref [reference] '= Butt [assignment_expression] \n    construct TclCmd [repeat tcl_expr_more]\n\t_ [transformJavaLocalScopeVar Ref] \n\n\t  [transformJavaClassVar Ref] \n\t  [transformJavaClassStaticVar Ref] \n\n\t  [transformJavaThisVar Ref] \n\t  [transformJavaThisStaticVar Ref] \n\n\t  [complexRefAssignment Ref]\n\t  [assignToArrayRef Ref]\n    construct TclLit [tcl_expr_more]\n\t_ [transformArithAssExp Butt]\n\t  [transformLiteralAssExp Butt]\n\t  [transformRefAssExp Butt]\n\t  [transformNewAssExp Butt]\n    by\n\tTclCmd [. TclLit] \nend rule\n\nfunction makeDecrCmdTail Op [pre_inc_dec]\n    deconstruct Op\n\t'--\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    construct Num [tcl_literal]\n\t-1\n    by\n\tNum\nend function\n\nfunction extractPrimitiveTypeName Parameter [formal_parameter]\n    replace [id]\n\t_ [id]\n    construct Primitive [repeat primitive_type]\n\t_ [^ Parameter]\n    deconstruct Primitive\n\tFirst [primitive_type] _ [repeat primitive_type]\n    construct TypeName [id]\n\t_ [quote First]\n    by\n\t_ [+ TypeName]\nend function\n\nfunction extractReferenceTypeName Parameter [formal_parameter]\n    replace [id]\n\t_ [id]\n    construct References [repeat reference]\n\t_ [^ Parameter]\n    deconstruct References\n\t_ [id] _ [repeat dimension] _ [repeat component]\n    construct Ids [repeat id]\n\t_ [^ References]\n    deconstruct * Ids \n\tTypeName [id]\n    by\n\t_ [+ TypeName]\nend function\n\nfunction is_nonstatic_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where\n\tField [has_var Id] \n    where not\n\tField [is_static]\nend function\n\nfunction is_static_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where all\n\tField [has_var Id] [is_static]\nend function\n\nrule findVarTypeInConstructorParams VarId [id]\n    replace $ [formal_parameter]\n\tFP [formal_parameter]\n    deconstruct FP\n\t_ [opt 'final] _ [type_specifier] _ [opt var_arg_specifier] \n\tId  [id] _ [opt generic_parameter] _ [repeat dimension]\n    where \n\tId [= VarId]\n    construct TypeName [id]\n\t_ [buildParameterTypeList FP]\n    export TypeName\n    by\n\tFP\nend rule\n\nfunction switchLabelConvertNum Label [constant_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct Label\n\tNum [number]\n    by\n\tNum\nend function\n\nfunction switchLabelConvertChar Label [constant_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct Label\n\tChars [charlit]\n    construct Unq [id]\n\t_ [unquote Chars]\n    by\n\tUnq\nend function\n\nfunction addExpToTclCmdList Expr [expression]\n    replace [tcl_cmd_list]\n\tTclExpr [tcl_expr] TclCmdMore [repeat tcl_cmd_more]\n    construct TclCmdMore2 [tcl_cmd_more]\n\t'; Expr\n    by\n\tTclExpr TclCmdMore [. TclCmdMore2]\nend function\n\nrule splitLocalVarDeclarations\n    replace [repeat declaration_or_statement]\n\tModr [repeat modifier] TypSpec [type_specifier] VarDecl [variable_declarator] ', VarDeclRest [list variable_declarator+] '; \n\tRest [repeat declaration_or_statement]\n    by\n\tModr TypSpec VarDecl ';\n\tModr TypSpec VarDeclRest ';\n\tRest\nend rule\n\nrule localVarDecl2Assignment\n    replace $ [declaration_or_statement]\n\tDecl [declaration_or_statement] \n    deconstruct Decl\n\t_ [repeat modifier] _ [type_specifier] _ [variable_declarators] ';\n    by\n\tDecl [localVarDecl2AssignmentExp] [localVarDecl2AssignmentArray] \nend rule\n\nfunction has_var Id [id]\n    match * [variable_name]\n\tVarId [id] _ [opt generic_parameter] _ [repeat dimension]\n    where \n\tVarId [= Id]\nend function\n\nfunction localVarDecl2AssignmentExp\n    replace [declaration_or_statement]\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t'= Exp [conditional_expression] ';\n    construct Ass [assignment_expression]\n\tId '= Exp \n    by\n\tAss ';\nend function\n\nfunction localVarDecl2AssignmentArray\n    replace [declaration_or_statement]\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t'= Exp [array_initializer] ';\n    construct Ass [assignment_expression]\n\tId '= Exp \n    by\n\tAss ';\nend function\n\n",
        "after": " package require XOTcl\nnamespace import ::xotcl::*\n\nClass create PrePostDemo_metapapa -superclass {Class} -slots {\n\n}\n\nPrePostDemo_metapapa create PrePostDemo -superclass {Class} -slots {\n\n}\n\nPrePostDemo proc main {args} {\n    set i 3\n    incr i\n    [System set out] println $i\n    // \"4\"\n    \n    incr i\n    [System set out] println $i\n    // \"5\"\n    \n    [System set out] println [incr i]\n    // \"6\"\n    \n    [System set out] println [incr i]\n    // \"6\"\n    \n    [System set out] println $i\n    // \"7\"\n    \n}\n\n ",
        "before": "\npackage require XOTcl\nnamespace import ::xotcl::*\n\nclass PrePostDemo {\n\n    public static void main (String [] args) {\n        i = 3;\n        i ++;\n        System.out.println (i);\n        // \"4\"\n        \n        i ++;\n        System.out.println (i);\n        // \"5\"\n        \n        System.out.println (i ++);\n        // \"6\"\n        \n        System.out.println (i ++);\n        // \"6\"\n        \n        System.out.println (i);\n        // \"7\"\n        \n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function",
        "context": "function translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\n\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " for (int i = 0;\ni < 6; i ++) switch (i) {\n    case 0 :\n        Console.WriteLine (\"i is zero.\");\n        goto case 1;\n    case 1 :\n        Console.WriteLine (\"i is one.\");\n        break;\n    case 2 :\n        Console.WriteLine (\"i is two.\");\n        break;\n    case 3 :\n        Console.WriteLine (\"i is three.\");\n        break;\n    default :\n        Console.WriteLine (\"i is greater than 3.\");\n        break;\n}\n\nfor (int i = 0;\ni < 12; i ++) switch (i) {\n    case 0 :\n    case 1 :\n    case 2 :\n    case 3 :\n    case 4 :\n        Console.WriteLine (\"i is less than 5\");\n        break;\n    case 5 :\n    case 6 :\n    case 7 :\n    case 8 :\n    case 9 :\n        Console.WriteLine (\"i is less than 10\");\n        break;\n    default :\n        Console.WriteLine (\"i is 10 or more\");\n        break;\n}\n\nint month = 4;\nString season;\nswitch (month) {\n    case 12 :\n    case 1 :\n    case 2 :\n        season = \"Winter\";\n        break;\n    case 3 :\n    case 4 :\n    case 5 :\n        season = \"Spring\";\n        break;\n    case 6 :\n    case 7 :\n    case 8 :\n        season = \"Summer\";\n        break;\n    case 9 :\n    case 10 :\n    case 11 :\n        season = \"Autumn\";\n        break;\n    default :\n        season = \"Bogus Month\";\n        break;\n}\nConsole.WriteLine (\"April is in the \" + season + \".\");\n//\n\nint count = 1, target = 0;\n// nested switch\n\nswitch (count) {\n    case 1 :\n        switch (target) {\n            case 0 :\n                Console.WriteLine (\"target is zero\");\n                break;\n            case 1 :\n                Console.WriteLine (\"target is one\");\n                break;\n        }\n        break;\n    case 2 :\n        break;\n}\n ",
        "before": "\nfor (int i = 0;\ni < 6; i ++) switch (i) {\n    case 0 :\n        System.out.println (\"i is zero.\");\n    case 1 :\n        System.out.println (\"i is one.\");\n        break;\n    case 2 :\n        System.out.println (\"i is two.\");\n        break;\n    case 3 :\n        System.out.println (\"i is three.\");\n        break;\n    default :\n        System.out.println (\"i is greater than 3.\");\n}\n\nfor (int i = 0;\ni < 12; i ++) switch (i) {\n    case 0 :\n    case 1 :\n    case 2 :\n    case 3 :\n    case 4 :\n        System.out.println (\"i is less than 5\");\n        break;\n    case 5 :\n    case 6 :\n    case 7 :\n    case 8 :\n    case 9 :\n        System.out.println (\"i is less than 10\");\n        break;\n    default :\n        System.out.println (\"i is 10 or more\");\n}\n\nint month = 4;\nString season;\nswitch (month) {\n    case 12 :\n    case 1 :\n    case 2 :\n        season = \"Winter\";\n        break;\n    case 3 :\n    case 4 :\n    case 5 :\n        season = \"Spring\";\n        break;\n    case 6 :\n    case 7 :\n    case 8 :\n        season = \"Summer\";\n        break;\n    case 9 :\n    case 10 :\n    case 11 :\n        season = \"Autumn\";\n        break;\n    default :\n        season = \"Bogus Month\";\n}\nSystem.out.println (\"April is in the \" + season + \".\");\n//\n\nint count = 1, target = 0;\n// nested switch\n\nswitch (count) {\n    case 1 :\n        switch (target) {\n            case 0 :\n                System.out.println (\"target is zero\");\n                break;\n            case 1 :\n                System.out.println (\"target is one\");\n                break;\n        }\n        break;\n    case 2 :\n        break;\n}\n "
    },
    {
        "hole_rule": "function changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function",
        "context": "function translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\n\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n",
        "after": " const int WHITE = 0, BLACK = 1;\nint color;\n\ninternal ColoredPoint (int x, int y) : this (x, y, WHITE) {\n}\n\ninternal ColoredPoint (int x, int y, int color) : base (x, y) {\n    this.color = color;\n}\n\n ",
        "before": "\nconst int WHITE = 0, BLACK = 1;\nint color;\n\nColoredPoint (int x, int y) {\n    this (x, y, WHITE);\n}\n\nColoredPoint (int x, int y, int color) {\n    super (x, y);\n    this.color = color;\n}\n\n "
    },
    {
        "hole_rule": "function checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function",
        "context": "function translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\n\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n",
        "after": " internal StaticInitTest () {\n    Console.WriteLine (\"In instance constructor\");\n}\n\nstatic StaticInitTest () {\n    Console.WriteLine (\"In static constructor\");\n}\n\nstatic String initInstance () {\n    Console.WriteLine (\"Initializing instance variable\");\n    return \"instance\";\n}\n\nstatic String initStatic () {\n    Console.WriteLine (\"Initializing static variable\");\n    return \"static\";\n}\n\nstatic void doStuff () {\n    Console.WriteLine (\"Invoking static DoStuff() method\");\n}\n\npublic static void Main (String [] args) {\n    Console.WriteLine (\"Beginning main()\");\n    StaticInitTest.doStuff ();\n    StaticInitTest sti = new StaticInitTest ();\n    Console.WriteLine (\"Completed main()\");\n}\n\n ",
        "before": "\nStaticInitTest () {\n    System.out.println (\"In instance constructor\");\n}\n\nstatic StaticInitTest () {\n    System.out.println (\"In static constructor\");\n}\n\nstatic String initInstance () {\n    System.out.println (\"Initializing instance variable\");\n    return \"instance\";\n}\n\nstatic String initStatic () {\n    System.out.println (\"Initializing static variable\");\n    return \"static\";\n}\n\nstatic void doStuff () {\n    System.out.println (\"Invoking static DoStuff() method\");\n}\n\npublic static void main (String [] args) {\n    System.out.println (\"Beginning main()\");\n    StaticInitTest.doStuff ();\n    StaticInitTest sti = new StaticInitTest ();\n    System.out.println (\"Completed main()\");\n}\n\n "
    },
    {
        "hole_rule": "function changePreMinusMinus\n    replace [expression_statement]\n\t'-- ID [identifier]\n    by\n\tID ':= ID '- 1\nend function",
        "context": "function translateCConst\n    replace [externaldefinition]\n\t'const T [type_specifier] N [identifier] '= E [expression] ';\n    construct NewType [type_specifier]\n\tT [changeType]\n    by\t\n\t'const N ': NewType ':= E\nend function\n\nfunction translateCType\n    replace [externaldefinition]\n\t'typedef T [type_specifier] OP [opt pointer] N [identifier] OAP [opt array_part] ';\n    construct NewType [type_specifier]\n\tT [changeType]\n    construct NewTuringType [externaldefinition]\n\t'type N : NewType\n    by\n\tNewTuringType\nend function\n\nfunction translateCVar\n    replace [externaldefinition]\n\tT [type_specifier] D [list decl_id_part+] ';\n    construct NewTuringVar [repeat t_var]\n\t_ [translatePointerVarDecl T each D]\n\t  [translateVarDecl T each D]\n    construct NewED [externaldefinition]\n\tNewTuringVar\n    by\n\tNewED\nend function\n\nfunction translateCFunction\n    replace [externaldefinition]\n\tF [function_definition]\n    construct NewTuringFunction [externaldefinition]\n\tF [translateProcedure]\t\t%% must be done before functions\n\t  [translateFunction]\n    by\n\tNewTuringFunction\nend function\n\nfunction changeType\n    construct CTypes [repeat type_specifier]\n    \t'char 'long 'float 'double\n    construct TuringTypes [repeat type_specifier]\n    \t'string(1) 'int 'real 'real\n    replace * [type_specifier]\n        CType [type_specifier]\n    by\n\tCType [$ each CTypes TuringTypes]\nend function\n\nfunction translateVarDecl T [type_specifier] D [decl_id_part]\n    deconstruct D\n\tDI [decl_identifier] OAP [opt array_part] OI [opt initialisation]\n    replace [repeat t_var]\n\tSoFar [repeat t_var]\n    construct TuringVar [t_var]\n\t'var DI ': T\n    construct NewTuringVar [t_var]\n\tTuringVar [addOptArrayPart OAP]\n\t\t  [addOptInit OI]\n\t\t  [changeType]\n    by\n\tSoFar [. NewTuringVar]\t\nend function\n\nfunction translatePointerVarDecl T [type_specifier] D [decl_id_part]\n    deconstruct D\n\t'* DI [decl_identifier] OAP [opt array_part] OI [opt initialisation]\n    deconstruct T\n\t'char\n    replace [repeat t_var]\n\tSoFar [repeat t_var]\n    construct TuringVar [t_var]\n\t'var DI ': 'string\n    construct NewTuringVar [t_var]\n\tTuringVar [addOptArrayPart OAP]\n\t\t  [addOptInit OI]\n    by\n\tSoFar [. NewTuringVar]\t\nend function\n\nfunction translateFunction\n    replace [function_definition]\n\tTS [type_specifier] N [identifier] '( AD [list argument_declaration] ')\n\tCS [compound_statement]\n    construct TuringArgs [list argument_declaration]\n\t_ [translateArg each AD]\n    construct ArgPart [t_paramDecl]\n\t'( TuringArgs ')\n    construct NewFunc [function_definition]\n\t'function N ArgPart ': TS\n\t    CS [changeCompound]\n\t'end N\n    by\n\tNewFunc [removeBeginEndFromFunc] \n\t\t[removeEmptyArgsFromFunc]\nend function\n\nfunction translateProcedure\n    replace [function_definition]\n\t'void N [identifier] '( AD [list argument_declaration] ')\n\tCS [compound_statement]\n    construct TuringArgs [list argument_declaration]\n\t_ [translateArg each AD]\n    construct ArgPart [t_paramDecl]\n\t'( TuringArgs ')\n    construct NewProc [function_definition]\n\t'procedure N ArgPart\n\t    CS [changeCompound]\n\t'end N\n    by\n    NewProc [removeBeginEndFromProc] \n    \t    [removeEmptyArgsFromProc]\nend function\n\nfunction addOptInit OI [opt initialisation]\n    deconstruct OI\n\t'= E [expression]\n    replace [t_var]\n\t'var DI [decl_identifier] ': T [type_specifier]\n    by\n\t'var DI ': T ':= E [changeExpression]\nend function\n\nfunction addOptArrayPart OAP[opt array_part]\n    deconstruct OAP\n\t'[ N [number] ']\n    replace [t_var]\n\t'var DI [decl_identifier] ': T [type_specifier]\n    construct NewN [number]\n\tN [- 1]\n    construct TuringArraySpec [type_specifier]\n\t'array 0 .. NewN 'of T\n    construct NewTuringArraySpec [type_specifier]\n\tTuringArraySpec [changeToStringSpec]\n    by\n\t'var DI ': NewTuringArraySpec\nend function\n\nfunction translateArg AD [argument_declaration]\n    deconstruct AD\n\tT [type_specifier] DI [decl_identifier] OAP [opt array_part] OI [opt initialisation]\n    replace [list argument_declaration]\n\tSoFar [list argument_declaration]\n    construct TuringArg [argument_declaration]\n\tDI ': T\n    construct NewTuringArg [argument_declaration]\n\tTuringArg [changeOptArrayPart OAP]\n\t\t  [changeType]\n    by\n\tSoFar [, NewTuringArg]\t\nend function\n\nfunction removeBeginEndFromFunc\n    replace [function_definition]\n\t'function N [identifier] OA [opt t_paramDecl] ': TS [type_specifier]\n\t    'begin\n\t\tD [repeat externaldefinition]\n\t\tS [repeat statement]\n\t    'end\n\t'end N\n    construct NewType [type_specifier]\n\tTS [changeType]\n    by\n\t'function N OA ': NewType\n\t    D\n\t    S\n\t'end N\nend function\n\nfunction removeEmptyArgsFromFunc\n    replace [function_definition]\n\t'function N [identifier] '( ') ': TS [type_specifier] \n\t    D [repeat externaldefinition]\n\t    S [repeat statement]\n\t'end N\n    by\n\t'function N ': TS\n\t    D\n\t    S\n\t'end N\nend function\n\nrule changeCompound\n    replace [compound_statement]\n\t'{\n\t\tD [repeat declaration] \n\t\tS [repeat statement]\n\t'} OS [opt ';]\n    construct ExtDefs [repeat externaldefinition]\n\t_ [makeExternalDef each D]\n    construct TuringDecls [repeat externaldefinition]\n\t_ [changeExternalDef each ExtDefs]\n    construct TuringStatements [repeat statement]\n\t_ [translateCStatements each S]\n    by\n\t'begin\n\t\tTuringDecls\n\t\tTuringStatements \n\t'end\nend rule\n\nfunction removeBeginEndFromProc\n    replace [function_definition]\n\t'procedure N [identifier] OA [opt t_paramDecl]\n\t    'begin\n\t\tD [repeat externaldefinition]\n\t\tS [repeat statement]\n\t    'end\n\t'end N\n    by\n\t'procedure N OA\n\t    D\n\t    S\n\t'end N\nend function\n\nfunction removeEmptyArgsFromProc\n    replace [function_definition]\n\t'procedure N [identifier] '( ')\n\t    D [repeat externaldefinition]\n\t    S [repeat statement]\n\t'end N\n    by\n\t'procedure N\n\t    D\n\t    S\n\t'end N\nend function\n\nrule changeExpression\n    construct COps [repeat binary_operator]\n        '== '!= '&& '|| '%\n    construct TuringOps [repeat binary_operator]\n    \t'= 'not= 'and 'or 'mod\n    replace [expression]\n\tE [expression]\n    construct NewE [expression]\n\tE [changeOp each COps TuringOps]\n\t  [changeArrayBrackets]\n    deconstruct not NewE\n\tE \n    by\n\tNewE \nend rule\n\nfunction changeToStringSpec\n    replace * [type_specifier]\n\t'array 0 .. N [number] 'of 'char\n    construct NewN [number]\n\tN [+ 1]\n    construct NewTuringTypeSpec [type_specifier]\n\t'string '( NewN ')\n    by\n\tNewTuringTypeSpec\nend function\n\nfunction changeOptArrayPart OAP [opt array_part]\n    deconstruct OAP\n\t'[ N [number] ']\n    replace [argument_declaration]\n\tDI [decl_identifier] ': T [type_specifier]\n    construct NewN [number]\n\tN [- 1]\n    construct TuringArraySpec [type_specifier]\n\t'array 0 .. NewN 'of T\n    construct NewTuringArraySpec [type_specifier]\n\tTuringArraySpec [changeToStringSpec]\n    by\n\tDI ': NewTuringArraySpec\nend function\n\nfunction translateCStatements CStatement [statement]\t\t\t\n    replace [repeat statement]\n\tSoFar [repeat statement]\n    construct NewTuringStatement [statement]\n\tCStatement [changeCStatement]\n    by\n\tSoFar [. NewTuringStatement]\nend function\n\nfunction makeExternalDef D [declaration]\n    replace [repeat externaldefinition]\n\tSoFar [repeat externaldefinition]\n    construct NewExternalDef [externaldefinition]\n\tD\n    by\n\tSoFar [. NewExternalDef]\nend function\n\nfunction changeArrayBrackets\n    replace * [unary_expression]\n\tPE [primary_expression] '[ E [expression] ']\n    by\n\tPE '( E ')\nend function\n\nfunction changeOp COp [binary_operator] TuringOp [binary_operator]\n    replace * [binary_operator]\n\tCOp\n    by\n\tTuringOp\nend function\n\nfunction changeCStatement\n    replace [statement]\n\tS [statement]\n    construct NewS [statement]\n\tS [changeExprStatement]\n\t  [changeIfStatement]\n\t%% Loop statements\n\t  [changeDoWhileStatement]\n\t  [changeWhileStatement]\n\t  [changeForStatement]\n\t%% Jump statements\n\t  [changeReturnStatement]\n\t  [changeBreakStatement]\n    deconstruct not NewS\n\tS\n    by\n\tNewS\nend function\n\nfunction changeDoWhileStatement\n    replace [statement]\n\t'do\n\t    S [statement] \n\t'while '( E [expression] ') ';\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( E [changeExpression] ')\n    construct NewS [repeat statement]\n\tS \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'loop\n\t    NewBody [. exitCondition]\n\t'end 'loop\nend function\n\nfunction changeWhileStatement\n    replace [statement]\n\t'while '( E [expression] ') \n\t    S [statement]\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( E [changeExpression] ')\n    construct NewS [repeat statement]\n\tS \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'loop\n\t    exitCondition \n\t    NewBody\n\t'end 'loop\nend function\n\nfunction changeForStatement\n    replace [statement]\n\t'for '( I [expression] '; C [expression] '; S1 [expression] ') \n\t    S2 [statement]\n    construct InitStatement [statement]\n\tI\n    construct NewInitStatement [statement]\n\tInitStatement [changeCStatement]\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( C [changeExpression] ')\n    construct NewFinalStatement [repeat statement]\n\tS1\n    construct NewS [repeat statement]\n\tS2 \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets] [. NewFinalStatement]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'begin\n\t    NewInitStatement\n\t    'loop\n\t\texitCondition\n\t\tNewBody\n\t    'end 'loop\n\t'end\nend function\n\nfunction changeIfStatement\n    replace [statement]\n\t'if '( E [expression] ')\n\t    S [statement]\n\tOE [opt ELSEstatement]\n    construct NewS [repeat statement]\n\tS\n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'if E [changeExpression] 'then\n\t    NewBody\n\tOE [changeElse]\n\t'end 'if\nend function\n\nfunction changeReturnStatement\n    replace [statement]\n\t'return E [expression] ';\n    by\n\t'result E [changeExpression]\nend function\n\nfunction changeBreakStatement\n    replace [statement]\n\t'break ';\n    by\n\t'exit\nend function\n\nrule changeExprStatement\n    replace [statement]\n\tES [expression_statement] \n    construct NewES [expression_statement]\n\tES [removeSemiColon]\n\t   [removeAmpersand]\n\t   [changeAssignment]\n\t   [changeBasicPrintf]\n\t   [changeComplexPrintf]\n\t   [changeBasicScanf]\n\t   [changeStrCopy]\n\t   [changeStrCat]\n\t   [changePrePlusPlus]\n\t   [changePostPlusPlus]\n\t   [changePreMinusMinus]\n\t   [changePostMinusMinus]\n\t   [changeArrayBrackets]\t\t%% changeArrayBrackets defined in expr_t.C\n    deconstruct not NewES\n\tES\n    by\n\tNewES \nend rule\n\nfunction removeBrackets\n    replace [repeat statement]\n\t'{\n\t    RS [repeat statement]\n\t'}\n    by\n\tRS\nend function\n\nrule changeElse\n    replace [ELSEstatement]\n\t'else 'if '( E [expression] ')\n\t    S [statement]\n\tOE [opt ELSEstatement]\n    construct NewS [repeat statement]\n\tS\n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'elsif E [changeExpression] 'then\n\t    NewBody\n\tOE [changeElse]\nend rule\n\nfunction removeSemiColon\n    replace [expression_statement]\n\tE [expression] ';\n    by\n\tE [changeExpression]\nend function\n\nfunction removeAmpersand\n    replace * [cast_expression]\n\t'& CE [cast_expression]\n    by\n\tCE\nend function\n\nfunction changeAssignment\n    replace [expression_statement]\n\tCE1 [cast_expression] '= CE2 [cast_expression] RBO [repeat binary_operation]\n    by\n\tCE1 ':= CE2 RBO\nend function\n\nfunction changeBasicPrintf\n    replace [expression_statement]\n\t'printf '( SL[stringlit] ')\n    by\n\t'put SL '..\nend function\n\nfunction changeComplexPrintf\n    replace [expression_statement]\n\t'printf '( LE [list assignment_expression+] ')\n    construct repeatExpr [repeat assignment_expression]\n\t_ [. each LE]\n    deconstruct repeatExpr\n\tSL [stringlit] Rest [repeat assignment_expression]\n    construct NewArgList [list putArg]\n\t_ [translatePutArgs SL Rest]\t\t\t\n    construct putStatement [expression_statement]\n\t'put NewArgList [removeEmptyArg] '..\n    by\n\tputStatement [removeOptDotDot]\nend function\n\nfunction changeBasicScanf\n    replace [expression_statement]\n\t'scanf '( LE [list assignment_expression+] ')\n    construct repeatExpr [repeat assignment_expression]\n\t_ [. each LE]\n    deconstruct repeatExpr\n\tSL [stringlit] Rest [repeat assignment_expression]\n    construct listExpr [list assignment_expression]\n\t_ [, each Rest]\n    by\n\t'get listExpr\nend function\n\nfunction changeStrCopy\n    replace [expression_statement]\n\tES [expression_statement]\n    by\n\tES [changeCopyWithLiteral]\n\t   [changeCopyWithIdentifier]\nend function\n\nfunction changeStrCat\n    replace [expression_statement]\n\tES [expression_statement]\n    by\n\tES [changeCatWithLiteral]\n\t   [changeCatWithIdentifier]\nend function\n\nfunction changePrePlusPlus\n    replace [expression_statement]\n\t'++ ID [identifier]\n    by\n\tID ':= ID '+ 1\nend function\n\nfunction changePostPlusPlus\n    replace [expression_statement]\n\tID [identifier] '++ \n    by\n\tID ':= ID '+ 1\nend function\n\n\n\nfunction changePostMinusMinus\n    replace [expression_statement]\n\tID [identifier] '-- \n    by\n\tID ':= ID '- 1\nend function\n\nfunction translatePutArgs SL [stringlit] RAE [repeat assignment_expression]\t\t\t\n    replace [list putArg]\n\tSoFar [list putArg]\n    construct beforePercent [stringlit]\t\t% get everything before the next percent\n\tSL [before \"%\"] [replaceEmpty SL RAE]\n    construct NewSL [putArg]\n\tbeforePercent\n    where not\t\t\t\t\t% terminating condition\n\tbeforePercent [?replaceEmpty SL RAE]\n    construct afterPercent [stringlit]\t\t% get everything after the percent sign\n\tSL [after \"%\"]\n    construct restSL [stringlit]\t\t% skip the next character\n\tafterPercent [: 2 9999] \t\t% 2nd to last character\n    construct RestAE [repeat assignment_expression]\n\t_ [getRest RAE]\n    construct recurse [list putArg]\n\t_ [translatePutArgs restSL RestAE]  \n    by\n\tSoFar [, NewSL] [addAE RAE] [, recurse]\nend function\n\nfunction removeEmptyArg\n    replace * [list_1_putArg]\n\t\"\" ', Tail [list_1_putArg]\n    by\n\tTail \nend function\n\nfunction removeOptDotDot\n    replace [expression_statement]\n\t'put LPA [list putArg] '..\n    construct NewLPA [list putArg]\n\tLPA [removeNewline]\n    %%deconstruct not NewLPA \n    \t%%LPA\n    by\n\t'put NewLPA\nend function\n\nfunction changeCopyWithLiteral\n    replace [expression_statement]\n\t'strcpy '( N [identifier] ', SL [stringlit] ')\n    by\n\tN ':= SL\nend function\n\nfunction changeCopyWithIdentifier\n    replace [expression_statement]\n\t'strcpy '( N [identifier] ', N2 [identifier] ')\n    by\n\tN ':= N2\nend function\n\nfunction changeCatWithLiteral\n    replace [expression_statement]\n\t'strcat '( N [identifier] ', SL [stringlit] ')\n    by\n\tN ':= N '+ SL\nend function\n\nfunction changeCatWithIdentifier\n    replace [expression_statement]\n\t'strcat '( N [identifier] ', N2 [identifier] ')\n    by\n\tN ':= N '+ N2\nend function\n\nfunction replaceEmpty restSL [stringlit] RAE [repeat assignment_expression]\n    replace [stringlit]\n\t\"\"\n    where not\n\tRAE [?notEmpty]\n    by\n\trestSL\nend function\n\nfunction addAE RAE [repeat assignment_expression]\n    deconstruct RAE\n\tAE [assignment_expression] RestAE [repeat assignment_expression]\n    replace [list putArg]\n\tLPA [list putArg]\n    construct NewPA [putArg]\n\tAE\n    by\n\tLPA [, NewPA]\nend function\n\nfunction getRest RAE [repeat assignment_expression]\n    replace [repeat assignment_expression]\n\tRest [repeat assignment_expression]\n    deconstruct RAE\n\tAE [assignment_expression] RestAE [repeat assignment_expression]\n    by\n\tRestAE\nend function\n\nfunction before SL [stringlit]\n    replace [stringlit]\n\tScope [stringlit]\n    construct N [number]\n\t_ [index Scope SL]\n    construct NewN [number]\n\tN [- 1]\n    by\n\tScope [changeNull N]\n\t      [changeNOTNull 1 NewN]\nend function\n\nfunction after SL [stringlit]\n    replace [stringlit]\n\tScope [stringlit]\n    construct N [number]\n\t_ [index Scope SL]\n    construct NewN [number]\n\tN [+ 1]\n    by\n\tScope [changeNull N]\n\t      [changeNOTNull NewN 9999]\nend function\n\nfunction removeNewline\n    replace * [list putArg]\n\tS [stringlit]\n    by\n\t% nothing\nend function\n\nfunction changeNull N [number]\n    replace [stringlit]\n\tSL [stringlit]\n    where\n\tN [<= 1]\n    by\n\t\"\"\nend function\n\nfunction changeNOTNull N1 [number] N2 [number]\n    replace [stringlit]\n\tSL [stringlit]\n    by\n\tSL [: N1 N2]\nend function\n\n",
        "after": " var m : int := - 999999999\nvar i : int\n ",
        "before": "\nvar m : int := - 999999999\n "
    },
    {
        "hole_rule": "function addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function",
        "context": "function translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\n\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " {\n\n    internal InstanceInit1 () {\n        initialMethod1 ();\n        initialMethod2 ();\n    }\n\n    private void initialMethod1 () {\n        int tmp = 1;\n        int x = 2;\n        int y = 10;\n    }\n\n    private void initialMethod2 () {\n        bool flag = false;\n    }\n\n}\n\n ",
        "before": "\n{\n\n    {\n        int tmp = 1;\n        int x = 2;\n        int y = 10;\n    }\n\n    {\n        boolean flag = false;\n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function constructorTransforms\n    replace [program]\n\tP [program]\n    by\n\tP [transformThisInConstructor] [transformSuperInConstructors]\nend function",
        "context": "function preparationTransformations\n    replace [program]\n\tP [program]\n    by\n\tP [exportClass]\n\t  [removeCastExpressions]\n\t  [expandJavaSwitch]\n\t  [javaPreUnary2PostUnary]\n\t  [convertJavaSelfAssignments]\n\t  \n\t  [transformVariables]\n\n\t  [localVarDecl2Assignment]\n\n\t  [removeArrayCreation]\n\n\t  [transformLiterals]\nend function\n\nfunction finalTransformations\n    replace [program]\n\tP [program]\n    by\n\tP [systemOutPrintln2Puts]\n   \t  [systemOutPrint2Puts]\nend function\n\nfunction transformImpEx\n    replace [program]\n\tP [program]\n    by\t\n\tP [addXOTclImport] [addXOTclImportIfNoPH] [removeImports]\nend function\n\nfunction classTransforms\n    replace [program]\n\tP [program]\n    by\n\tP [constructorTransforms]\n\t  [addClassMetaAndClass]\n\n\t  [teleportClassStaticAttributes]\n\t  [teleportClassStaticMethods]\n\n\t  [transformMethodsHeaders]\n\n\t  [transformDefaultAttributes]\n\t  [transformInitAttributesNew]\n\n\t  [transformExpressions]\n\n\t  [transformParameterVarRefs]\n\n\t  [transformDotRefs] \n\n\t  [untransformForUpdate]\n\n\t  [varRef2TclRef]\nend function\n\nfunction transformVariables\n    replace [program]\n\tP [program]\n    by\n\tP [splitVarDeclarations] [sortAllVarsUp]\n\t  [splitLocalVarDeclarations]\n\t  [removeEmptyLocalVarDeclarations]\nend function\n\nfunction exportClass\n    replace * [class_declaration]\n\tCD [class_declaration]\n    export JClassOrigin [class_declaration]\n\tCD\n    by\n\tCD\nend function\n\nrule transformLiterals\n    replace $ [literal]\n\tL [literal]\n    by\n\tL [transformBooleanTrue] [transformBooleanFalse]\nend rule\n\nrule removeCastExpressions\n    replace [unary_expression]\n\t'( _ [type_specifier] ') Unary [unary_expression]\n    by\n\tUnary\nend rule\n\nrule expandJavaSwitch\n    replace $ [switch_block]\n\tBlock [switch_block]\n    by\n\tBlock [removeSwitchBreak]\n\t      [convertSwitchDefaultLabel] \n\t      [expandJavaSwitchAlts]\nend rule\n\nrule javaPreUnary2PostUnary\n    replace [unary_expression]\n\tOp [pre_inc_dec] Una [primary]\n    by\n\tUna Op\nend rule\n\nrule convertJavaSelfAssignments\n    replace [assignment_expression]\n\tAss [assignment_expression]\n    deconstruct Ass\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct not Op\n\t_ [forbidden_self_assignments]\n    by\n\tAss [convertJavaSelfAssPlus]\n\t    [convertJavaSelfAssMinus]\n\t    [convertJavaSelfAssDiv]\n\t    [convertJavaSelfAssMul]\n\t    [convertJavaSelfAssDivLeft]\nend rule\n\nrule localVarDecl2Assignment\n    replace $ [declaration_or_statement]\n\tDecl [declaration_or_statement] \n    deconstruct Decl\n\t_ [repeat modifier] _ [type_specifier] _ [variable_declarators] ';\n    by\n\tDecl [localVarDecl2AssignmentExp] [localVarDecl2AssignmentArray] \nend rule\n\nrule removeArrayCreation\n    replace [repeat declaration_or_statement]\n\t_ [reference] '= _ [array_creation_expression] ';\t\n\tRest [repeat declaration_or_statement]\n    by\n\tRest\nend rule\n\nrule systemOutPrintln2Puts\n    replace $ [repeat tcl_expr_more]\n\t Cmd1 [reference] 'println More [repeat tcl_expr_more]\n    deconstruct Cmd1\n\t'[ Sys [reference] 'set 'out ']\n    deconstruct Sys\n\t'System\n    by\n\t'puts More [expandPrintlnParams]\nend rule\n\nrule systemOutPrint2Puts\n    replace $ [repeat tcl_expr_more]\n\t Cmd1 [reference] 'print More [repeat tcl_expr_more]\n    deconstruct Cmd1\n\t'[ Sys [reference] 'set 'out ']\n    deconstruct Sys\n\t'System\n    by\n\t'puts '-nonewline More [expandPrintlnParams]\nend rule\n\nfunction addXOTclImport\n    replace * [package_header]\n\tAnn [repeat annotation]\n\t'package Ref [package_name] ';\n    by\n%\tAnn \n\t'package 'provide Ref\n\t'package 'require 'XOTcl\n        'namespace 'import '::xotcl::*\nend function\n\nfunction addXOTclImportIfNoPH\n    replace * [package_declaration]\n\t_ [repeat comment_NL]\n%\tPH [opt package_header]\n\tImps [repeat import_declaration] \n\tDecls [repeat type_declaration]\n    construct OHead [package_header] \n%\t'package 'provide 'SampleTransform\n\t'package 'require 'XOTcl\n        'namespace 'import '::xotcl::*\n    by\n\tOHead\n\tImps\n\tDecls\nend function\n\nfunction removeImports\n    replace * [package_declaration]\n\tCmts [repeat comment_NL] \n\tPkgHead [opt package_header]\n\tImpDecl [repeat import_declaration] \n\tTypeDecl [repeat type_declaration]\n    by\n\tCmts PkgHead TypeDecl\nend function\n\nfunction addClassMetaAndClass\n    replace * [package_declaration]\n\tCmts [repeat comment_NL] \n\tPkgHead [opt package_header]\n\tImpDecl [repeat import_declaration] \n\tTypeDecl [repeat type_declaration]\n    deconstruct TypeDecl \n\t_ [repeat modifier] 'class ClassName [id] \n\tExtends [opt extends_clause] Implements [opt implements_clause] \n\t_ [class_body]\n\t_ [repeat type_declaration]\n    construct MetaClassName [id]\n\tClassName [_ 'metapapa]\n    construct ExtendClasses [repeat reference]\n\t_ [^ Extends]\n    construct Parents [repeat reference]\n\tExtendClasses [removeNonIdRef]\n    construct TclParents [repeat tcl_id]\n\t_ [pkgRef2TclId each Parents]\n    by\n\tCmts PkgHead ImpDecl \n\t'Class 'create MetaClassName '-superclass '{ 'Class '} '-slots '{ '}\n\tMetaClassName 'create ClassName '-superclass '{ 'Class TclParents '} \n\t'-slots '{ '}\n\tTypeDecl\nend function\n\n\n\nfunction transformExpressions\n    replace [program]\n\tP [program]\n    by\n\tP \n\t  [transformNewExpr]\n\n\t  [transformExceptions]\n\t  [transformConditionalStatements]\n\n\t  [transformVarAssignment]\n\n\n\t  [convertUnaryOpFirst]\n\t  [convertUnaryOpInMultiplicative]\nend function\n\nrule transformDefaultAttributes\n    replace [field_declaration]\n\t_ [repeat modifier] _ [type_specifier] Name [id] _ [opt generic_parameter] \n\t'= Literal [literal] '; \n    by\n\t'Attribute Name '-default Literal \nend rule\n\nrule transformInitAttributesNew\n    replace [field_declaration]\n\t_ [repeat modifier] _ [type_specifier] Name [id] _ [opt generic_parameter] \n\t'= New [class_instance_creation_expression] ';\n    construct NewCmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    by\n\t'Attribute Name '-initcmd '{ NewCmd '}\nend rule\n\nrule teleportClassStaticAttributes\n    replace $ [repeat type_declaration]\n\t%MetaClass\n\tMetaBase [id] MetaCreate [opt 'create] MetaClassName [id] MetaSuper [opt xotcl_class_superclasses]\n\t'-slots '{ '}\n\t%Class\n\tClassBase [id] ClassCreate [opt 'create] ClassName [id] ClassSuper [opt xotcl_class_superclasses]\n\t'-slots '{ '}\n\t%Java Class\n\tJClassHeader [class_header] JBody [class_or_interface_body]\n\t_ [repeat type_declaration]\n    construct JBodyElements [repeat class_body_declaration]\n\t_ [^ JBody]\n    construct JFields [repeat field_declaration]\n\t_ [^ JBody]\n    by\n\tMetaBase MetaCreate MetaClassName MetaSuper '-slots '{ JFields [removeNonStaticField] '}\n\tClassBase ClassCreate ClassName ClassSuper '-slots '{ JFields [removeStaticField] '}\n\tJClassHeader JBody \nend rule\n\nrule teleportClassStaticMethods\n    replace $ [repeat type_declaration]\n\t%Class\n\tClassBase [xotcl_class]\n\t%Java Class\n\tJClass [class_header] JBody [class_or_interface_body]\n\t_ [repeat type_declaration]\n    construct JMethods [repeat method_or_constructor_declaration]\n\t_ [^ JBody]\n    construct InstanceMethods [repeat method_or_constructor_declaration]\n\tJMethods [transformNonStaticMethod2Proc]\n    by\n\tClassBase\n\tJMethods [transformStaticMethod2Proc] [. InstanceMethods]\nend rule\n\nrule transformMethodsHeaders\n    replace $ [xotcl_class_with_methods]\n\tClass [xotcl_class]\n\tMethods [repeat method_or_constructor_declaration]\n    deconstruct Class\n\t_ [id] _ [opt 'create] \n\tName [id] _ [opt xotcl_class_superclasses] _ [opt xotcl_class_slots] \n    by\n\tClass\n\tMethods [transformNonStaticMethodHeader Name] \n\t\t[transformStaticMethodHeader Name]\n\t\t[transformSynchroNonStaticMethodHeader Name] \n\t\t[transformSynchroStaticMethodHeader Name]\n\t\t[transformConstructorHeader]\nend rule\n\nrule transformParameterVarRefs\n    replace $ [repeat method_or_constructor_declaration]\n \tMethod [method_or_constructor_declaration]\n \tMethods [repeat method_or_constructor_declaration]\n    deconstruct Method\n\t_ [id] _ [xotcl_proc_scope] _ [id] '{ VarIds [repeat id] '} _ [tcl_cmd_set]\n    by\n\tMethod [transformJavaVar2TclVar VarIds]\n\tMethods \nend rule\n\nrule transformDotRefs\n    replace [program]\n\tP [program]\n    where \n\tP [?transformRefMethodFirst1]\n\t  [?transformRefMethodFirst1In]\n\t  \n\t  [?transformRefMethodFirst]\n\t  [?transformRefMethod]\n\t  [?transformRefIdFirst]\n\t  [?transformRefId]\n\t  [?transformRefArray]\n    by \n\tP  [transformRefMethodFirst1]\n\t   [transformRefMethodFirst1In]\n  \n\t   [transformRefMethodFirst]\n\t   [transformRefMethod]\n\n\t   [transformRefIdFirst]\n\t   [transformRefId]\n\t   [transformRefArray] \nend rule\n\nrule varRef2TclRef\n    replace $ [reference]\n\tRef [reference]\n    construct RefNew [reference]\n\tRef [varRef2TclClassVar Ref]\n\t    [varRef2TclClassStaticVar Ref]\n\t    [varRef2TclVarSimple Ref]\n\t    [varRefThis2TclThis Ref]\n    by\n\tRefNew\nend rule\n\nrule untransformForUpdate\n    replace $ [tcl_for_cmd]\n\t'for Init [tcl_cmd_set] Cond [tcl_cmd_set] Upd [tcl_cmd_set] Block [tcl_block]\n    by\n\t'for Init Cond Upd [untransformForUpdateMores] Block \nend rule\n\nrule splitVarDeclarations\n    replace [repeat class_body_declaration]\n\tModr [repeat modifier] TypSpec [type_specifier] VarDecl [variable_declarator] ', VarDeclRest [list variable_declarator+] '; \n\tRest [repeat class_body_declaration]\n    by\n\tModr TypSpec VarDecl ';\n\tModr TypSpec VarDeclRest ';\n\tRest \nend rule\n\nrule splitLocalVarDeclarations\n    replace [repeat declaration_or_statement]\n\tModr [repeat modifier] TypSpec [type_specifier] VarDecl [variable_declarator] ', VarDeclRest [list variable_declarator+] '; \n\tRest [repeat declaration_or_statement]\n    by\n\tModr TypSpec VarDecl ';\n\tModr TypSpec VarDeclRest ';\n\tRest\nend rule\n\nrule removeEmptyLocalVarDeclarations\n    replace [repeat declaration_or_statement]\n\t_ [repeat modifier] _ [type_specifier] _ [id] _ [opt generic_parameter] '; \n\tRest [repeat declaration_or_statement]\n    by\n\tRest\nend rule\n\nrule sortAllVarsUp\n    replace [repeat class_body_declaration]\n\tNonVar [class_body_declaration_wo_field]\n\tVar [field_declaration]\n\tRest [repeat class_body_declaration]\n    by\n\tVar NonVar Rest\nend rule\n\nrule transformBooleanTrue\n    replace [literal]\n\t'true\n    by\n\t1\nend rule\n\nrule transformBooleanFalse\n    replace [literal]\n\t'false\n    by\n\t0\nend rule\n\nfunction expandJavaSwitchAlts\n    replace * [repeat switch_alternative]\n\tAlts [repeat switch_alternative]\n    deconstruct * Alts\n\tLastAlt [switch_alternative]\n    construct AltsLen [number]\n\t_ [length Alts] [- 1]\n    construct FirstAlts [repeat switch_alternative]\n\tAlts [head AltsLen]\n    construct LastAltConverted [switch_alternative]\n\tLastAlt [processJavaSwitchAltEmptyEntry] [processJavaSwitchAltCommentEntry] [processJavaSwitchAltEntry] \n    by\n\tFirstAlts [expandJavaSwitchAlts] [. LastAltConverted]\nend function\n\nrule convertSwitchDefaultLabel\n    replace $ [switch_alternative]\n\t'default ': Decls [repeat declaration_or_statement]\n    by\n\t'case ''default' ': Decls\nend rule\n\nrule removeSwitchBreak\n    replace [repeat declaration_or_statement]\n\t'break '; Decls [repeat declaration_or_statement]\n    by\n\tDecls\nend rule\n\nfunction convertJavaSelfAssPlus\n    replace [assignment_expression]\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct Op\n\t'+=\n    by\n\tUna '= Una '+ '( AssExp ')\nend function\n\nfunction convertJavaSelfAssMinus\n    replace [assignment_expression]\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct Op\n\t'-=\n    by\n\tUna '= Una '- '( AssExp ')\nend function\n\nfunction convertJavaSelfAssDiv\n    replace [assignment_expression]\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct Op\n\t'/=\n    by\n\tUna '= Una '/ '( AssExp ')\nend function\n\nfunction convertJavaSelfAssMul\n    replace [assignment_expression]\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct Op\n\t'*=\n    by\n\tUna '= Una '* '( AssExp ')\nend function\n\nfunction convertJavaSelfAssDivLeft\n    replace [assignment_expression]\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct Op\n\t'%=\n    by\n\tUna '= Una '% '( AssExp ')\nend function\n\nfunction localVarDecl2AssignmentExp\n    replace [declaration_or_statement]\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t'= Exp [conditional_expression] ';\n    construct Ass [assignment_expression]\n\tId '= Exp \n    by\n\tAss ';\nend function\n\nfunction localVarDecl2AssignmentArray\n    replace [declaration_or_statement]\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t'= Exp [array_initializer] ';\n    construct Ass [assignment_expression]\n\tId '= Exp \n    by\n\tAss ';\nend function\n\nfunction expandPrintlnParams\n    replace [repeat tcl_expr_more]\n\tMores [repeat tcl_expr_more]\n    export PutsUnas [repeat unary_expression]\n\t_\n    construct Dumb [repeat tcl_expr_more]\n\tMores [collectUnaries]\n    import PutsUnas\n\n    construct Len [number]\n\t_ [length PutsUnas]\n    where \n\tLen [> 1]\n    construct Cmds [repeat tcl_expr_more]\n\t_ [addUnaryToTclExprs each PutsUnas]\n    by\n\t'[ 'concat Cmds ']\nend function\n\nfunction pkgRef2TclId Ref [reference]\n    replace [repeat tcl_id]\n\t_ [repeat tcl_id]\n    construct RefIds [repeat id]\n\t_ [^ Ref]\n    deconstruct RefIds\n\tFirstId [id] RestId [repeat id]\n    construct TclIdHead [tcl_id_head]\n\tFirstId\n    construct TclIdPart [repeat tcl_id_part]\n\t_ [addTclIdPart each RestId]\n    by\n\tTclIdHead TclIdPart\nend function\n\nrule removeNonIdRef\n    replace [repeat reference]\n\tFirst [reference] Rest [repeat reference]\n    deconstruct First\n\tPrima [primitive_type] _ [repeat dimension] _ [repeat component]\n    by\n\tRest\nend rule\n\nrule transformSuperInConstructors\n    replace $ [constructor_declaration]\n\tConstructor [constructor_declaration]\n    by\n\tConstructor [addSuperInConstructorIfAbsent Constructor]\n\t\t    [transformSuperInConstructor Constructor]\n\t\t    [removeSuperInConstructor]\nend rule\n\nrule transformThisInConstructor \n    replace $ [constructor_declaration]\n\tConstructor [constructor_declaration]\n    by\n\tConstructor [transformThisStatement Constructor]\nend rule\n\nrule transformVarAssignment\n    replace [declaration_or_statement]\n\t Ref [reference] '= Butt [assignment_expression] ';\n    construct TclCmd [repeat tcl_expr_more]\n\t_ [transformJavaLocalScopeVar Ref] \n\n\t  [transformJavaClassVar Ref] \n\t  [transformJavaClassStaticVar Ref] \n\n\t  [transformJavaThisVar Ref] \n\t  [transformJavaThisStaticVar Ref] \n\n\t  [complexRefAssignment Ref]\n\t  [assignToArrayRef Ref]\n    construct TclLit [tcl_expr_more]\n\t_ [transformArithAssExp Butt]\n\t  [transformLiteralAssExp Butt]\n\t  [transformRefAssExp Butt]\n\t  [transformNewAssExp Butt]\n    by\n\tTclCmd [. TclLit] '%\nend rule\n\nrule transformExceptions\n    replace $ [program]\n\tP [program]\n    by\n\tP [transformThrowStmt]\n\t  [transformTryCatch]\nend rule\n\nrule transformConditionalStatements\n    replace $ [program]\n\tP [program]\n    by\n\tP [transformIfElse]\n\t  [transformIf]\n%\t  [transformCondChoice]\n\t  [transformWhile]\n\t  [transformSwitch]\n\t  [transformFor]\n\t  [transformForeach]\nend rule\n\nrule convertUnaryOpInMultiplicative\n    replace $ [multiplicative_expression]\n\tMulti [multiplicative_expression]\n    deconstruct Multi\n\tRef [id] Op [pre_inc_dec]\n    by\n\tMulti [convertUnaryOpMultiMy]\n\t      [convertUnaryOpMultiClass]\n\t      [convertUnaryOpMultiLocal]\nend rule\n\nrule convertUnaryOpFirst\n    replace $ [declaration_or_statement]\n\tDecl [declaration_or_statement]\n    deconstruct Decl\n\tRef [id] Op [pre_inc_dec] ';\n    by\n\tDecl [convertUnaryOpFirstMy]\n\t     [convertUnaryOpFirstClass]\n\t     [convertUnaryOpFirstLocal]\nend rule\n\nrule transformNewExpr\n    replace $ [multiplicative_expression]\n\tNew [class_instance_creation_expression]\n    construct Cmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    deconstruct Cmd\n\t'[ Expr [tcl_expr] ']\n    by\n\t'[ Expr ']\nend rule\n\nfunction convertNewClassInstance New [class_instance_creation_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct New\n\t'new JClassName [reference] '( Args [list argument] ') _ [opt class_body]\n    construct TmpName [repeat tcl_id]\n\t_ [pkgRef2TclId JClassName]\n    deconstruct * TmpName\n\tClassName [tcl_id]\n    construct Args1 [repeat expression]\n\t_ [argumentToExpression each Args]\n    construct TclArgs [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args1]\n    by\n\t'[ ClassName ClassName TclArgs ']\nend function\n\nrule removeStaticField\n    replace [repeat field_declaration]\n\tFirst [field_declaration] Rest [repeat field_declaration]\n    where \n\tFirst [is_static]\n    by\n\tRest\nend rule\n\nrule removeNonStaticField\n    replace [repeat field_declaration]\n\tFirst [field_declaration] Rest [repeat field_declaration]\n    where not\n\tFirst [is_static]\n    by\n\tRest\nend rule\n\nrule transformStaticMethod2Proc\n    replace  [repeat method_or_constructor_declaration]\n\tMethod [method_or_constructor_declaration] \n\tMethods [repeat method_or_constructor_declaration]\n    where not\n\tMethod [is_static]\n    by\n\tMethods\nend rule\n\nrule transformNonStaticMethod2Proc\n    replace  [repeat method_or_constructor_declaration]\n\tMethod [method_or_constructor_declaration] \n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tMethod [is_static]\n    by\n\tMethods\nend rule\n\nrule transformNonStaticMethodHeader ClassName [id]\n    replace [method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n    where not\n\tJModifiers [is_synchronized]\n    where not\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    by\n\tClassName 'instproc JName '{ ParamsNames '}  Body\nend rule\n\nrule transformStaticMethodHeader ClassName [id]\n    replace [method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n    where not\n\tJModifiers [is_synchronized]\n    where\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    by\n\tClassName 'proc JName '{ ParamsNames '}  Body\nend rule\n\nrule transformSynchroNonStaticMethodHeader ClassName [id]\n    replace [repeat method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tJModifiers [is_synchronized]\n    where not\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n    construct JSynchName [id]\n\tJName [_ 'synchrobaby]\n    construct MutexName [id]\n\tClassName [_ JName] [_ 'mutex]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'thread::mutex 'lock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'set 'cought 0 '%\n\t'#call the real method implementation\n\t'if '{ '[ 'catch '{ 'my JSynchName ParamsAsVars '} 'result '] '} '{\n\t'set 'cought 1 '%\n\t'} \n\t'thread::mutex 'unlock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'#transfer exception to the upper level\n\t'if '{ '$cought '} '{ 'error '$result '} \n\t'}\n    by\n\tClassName 'instproc JName '{ ParamsNames '} ProcBody \n\tClassName 'instproc JSynchName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformSynchroStaticMethodHeader ClassName [id]\n    replace [repeat method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tJModifiers [is_synchronized]\n    where\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n    construct JSynchName [id]\n\tJName [_ 'synchrobaby]\n    construct MutexName [id]\n\tClassName [_ JName] [_ 'mutex]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'thread::mutex 'lock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'set 'cought 0 '%\n\t'#call the real method implementation\n\t'if '{ '[ 'catch '{ 'my JSynchName ParamsAsVars '} 'result '] '} '{\n\t'set 'cought 1 '%\n\t'} \n\t'thread::mutex 'unlock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'#transfer exception to the upper level\n\t'if '{ '$cought '} '{ 'error '$result '} \n\t'} \n    by\n\tClassName 'proc JName '{ ParamsNames '} ProcBody \n\tClassName 'proc JSynchName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformConstructorHeader\n    replace [repeat method_or_constructor_declaration]\n \tConstructor [constructor_declaration]\n \tMethods [repeat method_or_constructor_declaration]\n    deconstruct Constructor\n\tJModifiers [repeat modifier] \n\tJClassName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') \n\t_ [opt throws] Body [block]\n\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n\n    construct ParamsString [id]\n\t_ [buildParameterTypeList each Parameters]\n    construct XNew [id]\n\t_ [+ JClassName] \n    construct XNewBody [id]\n\t_ [+ JClassName] [+ \"_body\"]\n    construct XNewName [id]\n\tXNew [+ ParamsString]\n    construct XNewBodyName [id]\n\tXNewBody [+ ParamsString]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'#create new object\n\t'set 'obj '[ JClassName 'new '] '%\n\t'#call the constructor\n\t'$obj XNewBodyName ParamsAsVars '%\n\t'#return new object after constructor's work is done\n\t'return '$obj '%\n\t'} \n    by\n\tJClassName 'proc XNewName '{ ParamsNames '} ProcBody\n\tJClassName 'instproc XNewBodyName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformJavaVar2TclVar VarIds [repeat id]\n    replace $ [reference]\n\tId [id] _ [repeat dimension] Comp [repeat component]\n    construct Len [number]\n\t_ [length Comp]\n    where \n\tLen [= 0]\n    where\n\tId [= each VarIds]\n    by\n\t'$ Id\nend rule\n\nrule transformRefMethodFirst1\n    replace [declaration_or_statement]\n\tId [id] _ [repeat dimension] Comps [repeat component] ';\n    construct CompsLen [number]\n\t_ [length Comps]\n    where \n\tCompsLen [= 1]\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'my Id Exps '%\nend rule\n\nrule transformRefMethodFirst1In\n    replace [reference]\n\tId [id] _ [repeat dimension] Comps [repeat component] \n    construct CompsLen [number]\n\t_ [length Comps]\n    where \n\tCompsLen [= 1]\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'[ 'my Id Exps '] \nend rule\n\nrule transformRefMethodFirst\n    replace [declaration_or_statement]\n\tId [id] Dims [repeat dimension] Comps [repeat component] ';\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct CompsLenFinal [number]\n\t_ [length Comps] [- 2]\n    construct NewCompsTmp [repeat component]\n\tComps [head CompsLen]\n    construct NewComps [repeat component]\n\tComps [head CompsLenFinal]\n    construct RefIds [repeat id]\n\t_ [^ NewCompsTmp]\n    deconstruct * RefIds\n\tMethodName [id]\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\tId [this2my] Dims NewComps MethodName Exps '%\nend rule\n\nrule transformRefMethod\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct CompsLenFinal [number]\n\t_ [length Comps] [- 2]\n    construct NewCompsTmp [repeat component]\n\tComps [head CompsLen]\n    construct NewComps [repeat component]\n\tComps [head CompsLenFinal]\n    construct RefIds [repeat id]\n\t_ [^ NewCompsTmp]\n    deconstruct * RefIds\n\tMethodName [id]\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'[ Id [this2my] Dims NewComps MethodName Exps '] \nend rule\n\nrule transformRefIdFirst\n    replace [declaration_or_statement]\n\tId [id] _ [repeat dimension] Comps [repeat component] '= AssExp [assignment_expression] ';\n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    by\n\tId NewComps 'set VarId AssExp '%\nend rule\n\nrule transformRefId\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps\n    by\n\t'[ NewRef 'set VarId ']\nend rule\n\nrule transformRefArray\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\tDim [dimension]\n\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n\n\n    deconstruct * NewComps\n\t'. VarId [id]\n    construct CompsLen2 [number]\n\t_ [length NewComps] [- 1]\n    construct DimComp [component]\n\tDim\n    construct NewComps2 [repeat component]\n\tNewComps [head CompsLen2] % [. DimComp]\n\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps2 \n\n    construct TmpDims [repeat dimension]\n\tDim\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim TmpDims]\n\n    by\n\t'[ NewRef 'set VarId TclDim ']\nend rule\n\nfunction varRef2TclClassVar Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where \n\tId [is_class_var]\n    by\n\t'[ 'my 'set Id TclDim ']\nend function\n\nfunction varRef2TclClassStaticVar Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ '[ 'my 'class '] 'set Id TclDim ']\nend function\n\nfunction varRef2TclVarSimple Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where all \n\tId [>= 'a] [<= 'z]\n    where not\n\tId [is_staticclass_var]\n\t   [is_class_var]\n    deconstruct not Id\n\t'my\n    by\n\t'$ Id TclDim\nend function\n\nfunction varRefThis2TclThis Ref [reference]\n    deconstruct Ref\n\t'this\n    replace [reference]\n\t_ [reference]\n    by\n\t'[ 'self ']\nend function\n\nrule untransformForUpdateMores\n%    skipping [tcl_expr_more]\n    replace $ [tcl_expr]\n\tExp [tcl_expr]\n    deconstruct Exp\n\tRef [reference]\n    deconstruct Ref\n\t'[ More [tcl_expr] ']\n    by\n\tMore\nend rule\n\nfunction processJavaSwitchAltEntry\n    replace [switch_alternative]\n\tLabel [switch_label] Decls [repeat declaration_or_statement+] \n    export SwitchAltDecls [repeat declaration_or_statement+]\n\tDecls \n    by\n\tLabel Decls \nend function\n\nfunction processJavaSwitchAltCommentEntry\n    replace [switch_alternative]\n\tLabel [switch_label] Decls [repeat declaration_or_statement+]\n    deconstruct Decls\n\t_ [comment_NL]\n    import SwitchAltDecls [repeat declaration_or_statement+]\n    by\n\tLabel Decls [. SwitchAltDecls]\nend function\n\nfunction processJavaSwitchAltEmptyEntry\n    replace [switch_alternative]\n\tLabel [switch_label] \n    import SwitchAltDecls [repeat declaration_or_statement+]\n    by\n\tLabel SwitchAltDecls \nend function\n\nfunction addUnaryToTclExprs Una [unary_expression]\n    replace [repeat tcl_expr_more]\n\tMores [repeat tcl_expr_more]\n    construct Cmd [tcl_expr_more]\n\tUna\n    by\n\tMores [. Cmd]\nend function\n\nrule collectUnaries\n    skipping [unary_expression]\n    replace $ [unary_expression]\n\tUna [unary_expression]\n    import PutsUnas [repeat unary_expression]\n    construct NewPutsUnas [repeat unary_expression]\n\tPutsUnas [. Una]\n    export PutsUnas\n\tNewPutsUnas\n    by\n\tUna\nend rule\n\nfunction addTclIdPart Id [id]\n    replace [repeat tcl_id_part]\n\tParts [repeat tcl_id_part]\n    construct Part [tcl_id_part]\n\t':: Id\n    by\n\tParts [. Part]\nend function\n\nrule addSuperInConstructorIfAbsent Constructor [constructor_declaration] \n    replace $ [constructor_body]\n\t'{ Decls [repeat declaration_or_statement] '}\n    where not\n\tDecls [?transformSuperInConstructor Constructor]\n    by\n\t'{\n\t'super '( ') ';\n\tDecls '}\nend rule\n\nrule transformSuperInConstructor Constructor [constructor_declaration] \n    replace $ [declaration_or_statement]\n\t'super MethArg [method_argument] ';\n    import JClassOrigin [class_declaration]\n    deconstruct JClassOrigin\n\t_ [repeat modifier] 'class _ [class_name] \n\tExtends [opt extends_clause] \n\t_ [opt implements_clause] _ [class_body]\n    construct ExtendClasses [repeat reference]\n\t_ [^ Extends]\n    construct Parents [repeat reference]\n\tExtendClasses [removeNonIdRef]\n    deconstruct * ExtendClasses \n\tParentName [id]\n    construct Args [repeat expression]\n\t_ [^ MethArg]\n    construct VarIds [repeat id]\n\t_ [^ Args]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    construct TypeString [id]\n\t_ [buildVarsTypeList4Constructor Constructor each VarIds]\n    construct XNewName [id]\n\t_ [+ ParentName] [+ \"_body\"] [+ TypeString]\n    by\n\t'my XNewName Exps '% \nend rule\n\nrule removeSuperInConstructor \n    replace [repeat declaration_or_statement]\n\t'super MethArg [method_argument] ';\n\tDecls [repeat declaration_or_statement]\n    by\n\tDecls\nend rule\n\nrule transformThisStatement Constructor [constructor_declaration] \n    replace $ [declaration_or_statement]\n\t'this MethArg [method_argument] ';\n    deconstruct Constructor\n\t_ [repeat modifier] ClassName [id] _ [opt generic_parameter]\n\t'( _ [list formal_parameter] ')  _ [opt throws] _ [constructor_body]\n    construct Args [repeat expression]\n\t_ [^ MethArg]\n    construct VarIds [repeat id]\n\t_ [^ Args]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    construct TypeString [id]\n\t_ [buildVarsTypeList4Constructor Constructor each VarIds]\n    construct XNewName [id]\n\t_ [+ ClassName] [+ \"_body\"] [+ TypeString]\n    by\n\t'my XNewName Exps '% \nend rule\n\nfunction transformJavaLocalScopeVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    by\n\t'set Id TclDim\nend function\n\nfunction transformJavaClassVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    where \n\tId [is_class_var]\n    by\n\t'my 'set Id TclDim\nend function\n\nfunction transformJavaClassStaticVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ 'my 'class '] 'set Id TclDim\nend function\n\nfunction transformJavaThisVar Ref [reference]\n    deconstruct Ref\n\t'this '. Id [id] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_class_var]\n    by\n\t'my 'set Id \nend function\n\nfunction transformJavaThisStaticVar Ref [reference]\n    deconstruct Ref\n\t'this '. Id [id] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ 'my 'class '] 'set Id \nend function\n\nfunction complexRefAssignment Ref [reference]\n    deconstruct Ref\n\tId [id] Dim [repeat dimension] Comps [repeat component+] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    construct ExprLen [number]\n\t_ [length Expr]\n    where not\n\tExprLen [> 0]\n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    construct NewRef [reference]\n\tId Dim NewComps\n    by\n\tNewRef 'set VarId \nend function\n\nfunction assignToArrayRef Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n\n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    construct ExprLen [number]\n\t_ [length Expr]\n    where not\n\tExprLen [> 0]\n\n    deconstruct * Comps\n\tDim [dimension]\n\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n\n\n    deconstruct * NewComps\n\t'. VarId [id]\n    construct CompsLen2 [number]\n\t_ [length NewComps] [- 1]\n    construct DimComp [component]\n\tDim\n    construct NewComps2 [repeat component]\n\tNewComps [head CompsLen2] % [. DimComp]\n\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps2 \n\n    construct TmpDims [repeat dimension]\n\tDim\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim TmpDims]\n\n    by\n        NewRef 'set VarId TclDim \nend function\n\nfunction transformArithAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    where\n\tButt [is_arithmetic]\n    construct TclRef [tcl_expr_more]\n\t'[ 'expr '{ Butt '} ']\n    by\n\tTclRef\nend function\n\nfunction transformLiteralAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tLiteral [literal]\n    by\n\tLiteral\nend function\n\nfunction transformRefAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tRef [reference]\n    by\n\tRef\nend function\n\nfunction transformNewAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tNew [class_instance_creation_expression]\n    construct NewCmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    by\n\tNewCmd\nend function\n\nrule transformTryCatch\n    replace $ [declaration_or_statement]\n\t'try Block [block] Catches [repeat catch_clause] _ [opt finally_clause]\n    deconstruct Block\n\t'{ BlockStmts [repeat declaration_or_statement] '}\n    construct CatchesStmts [repeat declaration_or_statement]\n\t_ [^ Catches]\n    construct CatchBlock [xotcl_proc_body]\n\tCatchesStmts\n    by\n\t'if '{ '[ 'catch '{ BlockStmts '} 'result '] '} '{\n\tCatchBlock\n\t'} \nend rule\n\nrule transformThrowStmt\n    replace $ [declaration_or_statement]\n\t_ [throw_statement]\t\n    by\n\t'error '$result\nend rule\n\nrule transformIf\n    replace [declaration_or_statement]\n\t'if '( IfExpr [expression] ') _ [repeat comment_NL]\n\tStmt [statement] \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct IfTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    construct TclIf [tcl_if_cmd]\n\t'if '{ IfExpr '} IfTclBlock\n    by\n\tTclIf\nend rule\n\nrule transformIfElse\n    replace [declaration_or_statement]\n\t'if '( IfExpr [expression] ') IfStmt [statement] _ [repeat comment_NL]\n\t'else ElseStmt [statement]\n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct IfTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok IfStmt] \n\t\t      [statementBlockToTclBlock IfStmt]\n    construct ElseTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok ElseStmt] \n\t\t      [statementBlockToTclBlock ElseStmt]\n    deconstruct IfTclBlock\n\t'{ IfBody [opt xotcl_proc_body] '}\n    construct TclIf [tcl_if_cmd]\n\t'if '{ IfExpr '} '{ IfBody '} 'else ElseTclBlock\n    by\n\tTclIf\nend rule\n\nrule transformCondChoice\n    replace $ [assignment_expression]\n\tCond [conditional_expression]\n    deconstruct Cond\n\tUna [unary_expression] '? Exp [expression] ': CondChExp [conditional_expression]\n    by\n\t'[ 'expr '{ Una '? Exp  ': CondChExp '} ']\nend rule\n\nrule transformWhile\n    replace [declaration_or_statement]\n\t'while '( Expr [expression] ') Stmt [statement] \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct WhileTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    construct TclWhile [tcl_while_cmd]\n\t'while '{ Expr '}  WhileTclBlock\n    by\n\tTclWhile\nend rule\n\nrule transformSwitch\n    replace [declaration_or_statement]\n\t'switch '( Expr [expression] ') '{ JAlts [repeat switch_alternative] '}\n    construct Alts [repeat tcl_switch_entry]\n\t_ [transformSwitchAlternatives each JAlts] \n    construct TclSwitch [tcl_switch_cmd]\n\t'switch Expr '{ Alts '} \n    by\n\tTclSwitch\nend rule\n\nrule transformFor\n    replace [declaration_or_statement]\n\t'for '( ForInit [for_init] \n\tForExpr [opt expression] '; \n\tForUpd [list expression] ') \n\tStmt [statement] \n    construct ForUpdSeq [repeat expression]\n\t_ [. each ForUpd]\n    construct TclCmdLists [repeat tcl_cmd_list]\n\t_ [expressionListToTclCmdList ForUpdSeq] \n\t  [transformVarAssignmentFor]\n    construct TclForInit [repeat tcl_cmd_list]\n\t_ [transformForInitStmt1 ForInit] \n\t  [transformForInitStmt2 ForInit]\n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct ForTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    by\n\t'for '{ TclForInit '} \n\t'{ ForExpr '} '{ TclCmdLists '}\n\tForTclBlock\nend rule\n\nrule transformForeach\n    replace [declaration_or_statement]\n\t'for '( \n\t%for_in_init\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t': Expr [expression] ')\n\t\tStmt [statement]        \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct ForTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    by\n\t'foreach '{ Id '} '{ Expr '}\n\tForTclBlock\nend rule\n\nrule convertUnaryOpMultiLocal\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpMultiMy\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    where \n\tRef [is_class_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'my 'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpMultiClass\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    where \n\tRef [is_staticclass_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'[ 'my 'class '] 'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpFirstLocal\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nrule convertUnaryOpFirstMy\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    where \n\tRef [is_class_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'my 'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nrule convertUnaryOpFirstClass\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    where \n\tRef [is_staticclass_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'[ 'my 'class '] 'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nfunction expressionSeq2TclExprMoreSeq Expressions [repeat expression]\n    replace [repeat tcl_expr_more]\n\tEMore [repeat tcl_expr_more]\n    deconstruct Expressions\n\tExpr [expression] Exprs [repeat expression]\n    construct TclEMore [repeat tcl_expr_more]\n\tExpr\n    by\n\tEMore [. TclEMore] [expressionSeq2TclExprMoreSeq Exprs]\nend function\n\nfunction argumentToExpression Argument [argument]\n    replace [repeat expression]\n\tExps [repeat expression]\n    deconstruct Argument\n\tExp [expression]\n    by\n\tExps [. Exp]\nend function\n\nfunction is_static \n    match * [modifier]\n\t'static\nend function\n\nfunction is_synchronized\n    match * [modifier]\n\t'synchronized\nend function\n\nfunction transformId2TclVar Id [id]\n    replace [repeat tcl_expr_more]\n\tCmds [repeat tcl_expr_more]\n    construct Var [tcl_expr_more]\n\t'$ Id\n    by\n\tCmds [. Var]\nend function\n\nfunction buildParameterTypeList Parameter [formal_parameter]\n    replace [id]\n\tParams [id] \n    construct TypeName [id]\n\t_ [extractPrimitiveTypeName Parameter]\n\t  [extractReferenceTypeName Parameter]\n    by\n\tParams [_ TypeName]\nend function\n\nfunction this2my \n    replace [id]\n\t'this\n    by\n\t'my\nend function\n\nfunction dim2TclDim Dims [repeat dimension]\n    construct DimLen [number]\n\t_ [length Dims]\n    where \n\tDimLen [= 1]\n    deconstruct Dims\n\tDim [dimension] _ [repeat dimension]\n    deconstruct Dim\n\t'[ Expr [expression] ']\n    replace [repeat tcl_array_dimension]\n\t_ [repeat tcl_array_dimension]\n    by\n\t'( Expr ')\nend function\n\nfunction is_class_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_nonstatic_var Id]\nend function\n\nfunction is_staticclass_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_static_var Id]\nend function\n\nfunction buildVarsTypeList4Constructor Constructor [constructor_declaration] VarId [id]\n    replace [id]\n\tIds [id]\n    construct Tmp1 [constructor_declaration]\n\tConstructor [findVarTypeInConstructorParams VarId]\n    import TypeName [id]\n    by\n\tIds [+ TypeName]\nend function\n\nrule is_arithmetic\n    match $ [any]\n\tAny [any]\n    where \n\tAny [istype 'add_op]\n\t    [istype 'mult_op]\n\t    [istype 'unary_op]\n\t    [istype 'or_conditional_and_expression]\n\t    [istype 'and_inclusive_or_expression]\n\t    [istype 'or_exclusive_or_expression]\n\t    [istype 'or_and_expression]\n\t    [istype 'and_equality_expression]\n\t    [istype 'equality_op]\n\t    [istype 'relational_op]\n\t    [istype 'shif_op]\n\t    [istype 'conditional_choice]\nend rule\n\nfunction statementOneDeclToTclBlcok Stmt [statement]\n    replace [tcl_block]\n\t_ [tcl_block]\n    deconstruct not Stmt\n\t_ [block]\n    construct Decl [declaration_or_statement]\n\tStmt\n    by\n\t'{ Decl '}\nend function\n\nfunction statementBlockToTclBlock Stmt [statement]\n    replace [tcl_block]\n\t_ [tcl_block]\n    deconstruct Stmt\n\t'{ Decls [repeat declaration_or_statement] '}\n    by\n\t'{ Decls '}\nend function\n\nfunction transformSwitchAlternatives JAlt [switch_alternative]\n    replace [repeat tcl_switch_entry]\n\tEntries [repeat tcl_switch_entry]\n    deconstruct JAlt\n\t'case Label [constant_expression] ': Decls [repeat declaration_or_statement]\n    construct SwitchLabel [tcl_cmd]\n\t_ [switchLabelConvertNum Label] [switchLabelConvertChar Label]\n    construct Entry [tcl_switch_entry]\n\tSwitchLabel '{ Decls '} \t\n    by\n\tEntries [. Entry]\nend function\n\nfunction expressionListToTclCmdList Expressions [repeat expression]\n    replace [repeat tcl_cmd_list]\n\t_  [repeat tcl_cmd_list]\n    deconstruct Expressions\n\tExpr [expression] Exprs [repeat expression]\n    construct TclCmdList [tcl_cmd_list]\n\tExpr\n    by\n\tTclCmdList [addExpToTclCmdList each Exprs]\nend function\n\nfunction transformForInitStmt1 ForInit [for_init]\n    deconstruct ForInit\n\tExprs [list expression] ';\n    replace [repeat tcl_cmd_list]\n\t_ [repeat tcl_cmd_list]\n    construct ExprSeq [repeat expression]\n\t_ [. each Exprs]\n    by\n\t_ [expressionListToTclCmdList ExprSeq] [transformVarAssignmentFor]\nend function\n\nfunction transformForInitStmt2 ForInit [for_init]\n    deconstruct ForInit\n\tLocalDecl [declaration_or_statement] \n    construct TmpDecls [repeat declaration_or_statement]\n\tLocalDecl\n    construct TmpDecls2 [repeat declaration_or_statement]\n\tTmpDecls [splitLocalVarDeclarations] [localVarDecl2Assignment]\n    deconstruct TmpDecls2\n\tDecl1 [declaration_or_statement] _ [repeat declaration_or_statement]\n    replace [repeat tcl_cmd_list]\n\t_ [repeat tcl_cmd_list]\n    by\n%\tLocalDecl\n\tTmpDecls2\nend function\n\nrule transformVarAssignmentFor\n    replace [repeat tcl_expr_more]\n\t Ref [reference] '= Butt [assignment_expression] \n    construct TclCmd [repeat tcl_expr_more]\n\t_ [transformJavaLocalScopeVar Ref] \n\n\t  [transformJavaClassVar Ref] \n\t  [transformJavaClassStaticVar Ref] \n\n\t  [transformJavaThisVar Ref] \n\t  [transformJavaThisStaticVar Ref] \n\n\t  [complexRefAssignment Ref]\n\t  [assignToArrayRef Ref]\n    construct TclLit [tcl_expr_more]\n\t_ [transformArithAssExp Butt]\n\t  [transformLiteralAssExp Butt]\n\t  [transformRefAssExp Butt]\n\t  [transformNewAssExp Butt]\n    by\n\tTclCmd [. TclLit] \nend rule\n\nfunction makeDecrCmdTail Op [pre_inc_dec]\n    deconstruct Op\n\t'--\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    construct Num [tcl_literal]\n\t-1\n    by\n\tNum\nend function\n\nfunction extractPrimitiveTypeName Parameter [formal_parameter]\n    replace [id]\n\t_ [id]\n    construct Primitive [repeat primitive_type]\n\t_ [^ Parameter]\n    deconstruct Primitive\n\tFirst [primitive_type] _ [repeat primitive_type]\n    construct TypeName [id]\n\t_ [quote First]\n    by\n\t_ [+ TypeName]\nend function\n\nfunction extractReferenceTypeName Parameter [formal_parameter]\n    replace [id]\n\t_ [id]\n    construct References [repeat reference]\n\t_ [^ Parameter]\n    deconstruct References\n\t_ [id] _ [repeat dimension] _ [repeat component]\n    construct Ids [repeat id]\n\t_ [^ References]\n    deconstruct * Ids \n\tTypeName [id]\n    by\n\t_ [+ TypeName]\nend function\n\nfunction is_nonstatic_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where\n\tField [has_var Id] \n    where not\n\tField [is_static]\nend function\n\nfunction is_static_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where all\n\tField [has_var Id] [is_static]\nend function\n\nrule findVarTypeInConstructorParams VarId [id]\n    replace $ [formal_parameter]\n\tFP [formal_parameter]\n    deconstruct FP\n\t_ [opt 'final] _ [type_specifier] _ [opt var_arg_specifier] \n\tId  [id] _ [opt generic_parameter] _ [repeat dimension]\n    where \n\tId [= VarId]\n    construct TypeName [id]\n\t_ [buildParameterTypeList FP]\n    export TypeName\n    by\n\tFP\nend rule\n\nfunction switchLabelConvertNum Label [constant_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct Label\n\tNum [number]\n    by\n\tNum\nend function\n\nfunction switchLabelConvertChar Label [constant_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct Label\n\tChars [charlit]\n    construct Unq [id]\n\t_ [unquote Chars]\n    by\n\tUnq\nend function\n\nfunction addExpToTclCmdList Expr [expression]\n    replace [tcl_cmd_list]\n\tTclExpr [tcl_expr] TclCmdMore [repeat tcl_cmd_more]\n    construct TclCmdMore2 [tcl_cmd_more]\n\t'; Expr\n    by\n\tTclExpr TclCmdMore [. TclCmdMore2]\nend function\n\nfunction has_var Id [id]\n    match * [variable_name]\n\tVarId [id] _ [opt generic_parameter] _ [repeat dimension]\n    where \n\tVarId [= Id]\nend function\n\n",
        "after": " package require XOTcl\nnamespace import ::xotcl::*\n\nClass create ArithmeticDemo_metapapa -superclass {Class} -slots {\n\n}\n\nArithmeticDemo_metapapa create ArithmeticDemo -superclass {Class} -slots {\n\n}\n\nArithmeticDemo proc main {args} {\n    set result [expr {1 + 2}]\n    // result is now 3\n    \n    puts $result\n    set result [expr {$result - 1}]\n    // result is now 2\n    \n    puts $result\n    set result [expr {$result * 2}]\n    // result is now 4\n    \n    puts $result\n    set result [expr {$result / 2}]\n    // result is now 2\n    \n    puts $result\n    set result [expr {$result + 8}]\n    // result is now 10\n    \n    set result [expr {$result % 7}]\n    // result is now 3\n    \n    puts $result\n}\n\n ",
        "before": "\n// Copyright (c) 1995 - 2008 Sun Microsystems, Inc.  All rights reserved.\n\nclass ArithmeticDemo {\n\n    public static void main (String [] args) {\n        int result = 1 + 2;\n        // result is now 3\n        \n        System.out.println (result);\n        result = result - 1;\n        // result is now 2\n        \n        System.out.println (result);\n        result = result * 2;\n        // result is now 4\n        \n        System.out.println (result);\n        result = result / 2;\n        // result is now 2\n        \n        System.out.println (result);\n        result = result + 8;\n        // result is now 10\n        \n        result = result % 7;\n        // result is now 3\n        \n        System.out.println (result);\n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function",
        "context": "function changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\n\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " virtual public int getAvgLength () {\n    int count = 0;\n    int total = 0;\n    int len;\n    while (true) {\n        len = getLength ();\n        if (len == 0) break;\n\n        count ++;\n        total += len;\n    }\n    return total / count;\n    // Can throw ArithmeticException\n    \n}\n\n ",
        "before": "\nint getAvgLength () {\n    int count = 0;\n    int total = 0;\n    int len;\n    while (true) {\n        len = getLength ();\n        if (len == 0) break;\n\n        count ++;\n        total += len;\n    }\n    return total / count;\n    // Can throw ArithmeticException\n    \n}\n\n "
    },
    {
        "hole_rule": "function addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function",
        "context": "function translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\n\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " {\n    bool flag = true;\n    const int y = 6;\n    double X = Math.random ();\n    int DAYS_IN_YEAR;\n    if (flag) DAYS_IN_YEAR = 366;\n    else DAYS_IN_YEAR = 365;\n\n} ",
        "before": "\n{\n    boolean flag = true;\n    final int y = 6;\n    final double X = Math.random ();\n    final int DAYS_IN_YEAR;\n    if (flag) DAYS_IN_YEAR = 366;\n    else DAYS_IN_YEAR = 365;\n\n} "
    },
    {
        "hole_rule": "function changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function",
        "context": "function translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\n\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " {\n    int tmp = 1;\n    int x = 2;\n    int y = 10;\n} ",
        "before": "\n{\n    int tmp = 1;\n    int x = 2;\n    int y = 10;\n} "
    },
    {
        "hole_rule": "function translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function",
        "context": "function translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\n\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " case 9 :\n    Console.WriteLine (\"i is less than 10\");\n    break;\ndefault :\n    Console.WriteLine (\"i is 10 or more\");\n    break;\n ",
        "before": "\ncase 9 :\n    System.out.println (\"i is less than 10\");\n    break;\ndefault :\n    System.out.println (\"i is 10 or more\");\n    break;\n "
    },
    {
        "hole_rule": "function changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function",
        "context": "function changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\n\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " virtual public void test () {\n}\n\n ",
        "before": "\nvoid test () {\n}\n\n "
    },
    {
        "hole_rule": "rule deductiveelimination3\n    replace [formula]\n        ( - - ( - P [formula] '| - Q [formula] ) '| Q )\n    by\n        P\nend rule",
        "context": "function inference\n    replace [formula]\n        S [formula]\n    by\n        S [inference1a]\n          [inference1b]\nend function\n\nfunction simplifynot\n    replace [formula]\n        S [formula]\n    by\n        S [simplifynottrue]\n          [simplifynotfalse]\nend function\n\nfunction simplifyor\n    replace [formula]\n        S [formula]\n    by\n        S [simplifyor1]\n          [simplifyor2]\n          [simplifyor3]\n          [simplifyor4]\nend function\n\nfunction theorem10\n    replace [formula]\n        S [formula]\n    by\n        S [theorem10a]\n          [theorem10b]\nend function\n\nfunction theorem12\n    replace [formula]\n        S [formula]\n    by\n        S [theorem12a]\n          [theorem12b]\nend function\n\nfunction transitiveelimination\n    replace [formula]\n        S [formula]\n    by\n        S [transitiveelimination1]\n          [transitiveelimination2]\n          [transitiveelimination3]\n          [transitiveelimination4]\nend function\n\nfunction distributiveelimination\n    replace [formula]\n        S [formula]\n    by\n        S [distributiveelimination1]\n          [distributiveelimination2]\nend function\n\nfunction deductiveelimination\n    replace [formula]\n        S [formula]\n    by\n        S [deductiveelimination1]\n          [deductiveelimination2]\n          [deductiveelimination3]\n          [deductiveelimination4]\nend function\n\nrule axiom1\n    replace [formula]\n        ( - P [formula] '| - ( - P '| - P ) ) \n    by\n        true\nend rule\n\nrule axiom2\n    replace [formula]\n        ( ( - P [formula] '| - Q [formula] ) '| P ) \n    by\n        true\nend rule\n\nrule axiom3\n    replace [formula]\n        ( - ( - P [formula] '| Q [formula] ) '| ( - ( - Q '| - R [formula] ) '| ( - R '| - P ) ) ) \n    by\n        true\nend rule\n\nrule theorem1\n    replace [formula]\n        ( S [formula] '| - S )\n    by\n        true\nend rule\n\nrule theorem2\n    replace [formula]\n        ( - S [formula] '| S )\n    by\n        true\nend rule\n\nrule theorem3\n    replace [formula]\n        ( - ( Q [formula] '| R [formula] ) '| ( R '| Q ) ) \n    by\n        true\nend rule\n\nrule theorem4\n    replace [formula]\n        ( S [formula] '| - S )\n    by\n        true\nend rule\n\nrule theorem5\n    replace [formula]\n        ( - ( - Q [formula] '| P [formula] ) '| ( P '| - Q ) ) \n    by\n        true\nend rule\n\nrule theorem6\n    replace [formula]\n        ( ( - R [formula] '| - P [formula] ) '| - ( - P '| - R ) ) \n    by\n        true\nend rule\n\nrule theorem7\n    replace [formula]\n        ( - P [formula] '| P )\n    by\n        true\nend rule\n\nrule theorem8\n    replace [formula]\n        ( ( - R [formula] '| - P [formula] ) '| - ( - P '| - R ) ) \n    by\n        true\nend rule\n\nrule theorem9\n    replace [formula]\n        ( - ( - P [formula] '| - R [formula] ) '| ( - R '| - P ) ) \n    by\n        true\nend rule\n\nrule theorem11\n    replace [formula]\n        ( - ( P [formula] '| Q [formula] ) '| ( Q '| P ) ) \n    by\n        true\nend rule\n\nrule theorem13\n    replace [formula]\n        ( - ( - P [formula] '| ( - Q [formula] '| R [formula] ) ) '| ( ( - P '| - Q ) '| R ) ) \n    by\n        true\nend rule\n\nrule theorem14\n    replace [formula]\n        ( - ( ( - P [formula] '| - Q [formula] ) '| R [formula] ) '| ( - P '| ( - Q '| R ) ) ) \n    by\n        true\nend rule\n\nrule theorem15\n    replace [formula]\n        ( - P [formula] '| ( - Q [formula] '| - ( - P '| - Q ) ) ) \n    by\n        true\nend rule\n\nrule theorem16\n    replace [formula]\n        ( - P [formula] '| ( - Q [formula] '| P ) ) \n    by\n        true\nend rule\n\nrule theorem17\n    replace [formula]\n        ( ( - ( - P [formula] '| Q [formula] ) '| - ( - Q '| R [formula] ) ) '| ( - P '| R ) ) \n    by\n        true\nend rule\n\nrule theorem18\n    replace [formula]\n        ( ( - S [formula] '| R [formula] ) '| ( - R '| S ) ) \n    by\n        true\nend rule\n\nrule theorem19\n    replace [formula]\n        - ( - ( P [formula] '| Q [formula] ) '| - P )\n    by\n        true\nend rule\n\nrule theorem20\n    replace [formula]\n        - ( - ( Q [formula] '| P [formula] ) '| - P )\n    by\n        true\nend rule\n\nrule redundancyelimination\n    replace [formula]\n        ( P [formula] '| P )\n    by\n        P\nend rule\n\nrule doublenotelimination\n    replace [formula]\n        - - P [formula]\n    by\n        P\nend rule\n\nrule inference1a\n    replace [formula]\n        - ( - S [formula] '| - ( - S '| R [formula] ) ) \n    by\n        R\nend rule\n\nrule inference1b\n    replace [formula]\n        - ( - ( - S [formula] '| R [formula] ) '| - S ) \n    by\n        R\nend rule\n\nrule simplifynottrue\n    replace [formula]\n        - true\n    by\n        false\nend rule\n\nrule simplifynotfalse\n    replace [formula]\n        - false\n    by\n        true\nend rule\n\nrule simplifyor1\n    replace [formula]\n        ( false '| P [formula] )\n    by\n        P\nend rule\n\nrule simplifyor2\n    replace [formula]\n        ( P [formula] '| false )\n    by\n        P\nend rule\n\nrule simplifyor3\n    replace [formula]\n        ( true '| P [formula] )\n    by\n        true\nend rule\n\nrule simplifyor4\n    replace [formula]\n        ( P [formula] '| true )\n    by\n        true\nend rule\n\nrule theorem10a\n    replace [formula]\n        ( ( ( - P [formula] '| - Q [formula] ) '| - R [formula] ) '| - ( - P '| ( - Q '| - R ) ) ) \n    by\n        true\nend rule\n\nrule theorem10b\n    replace [formula]\n        ( ( - P [formula] '| ( - Q [formula] '| - R [formula] ) ) '| - ( ( - P '| - Q ) '| - R ) ) \n    by\n        true\nend rule\n\nrule theorem12a\n    replace [formula]\n        ( - ( ( P [formula] '| Q [formula] ) '| R [formula] ) '| ( P '| ( Q '| R ) ) ) \n    by\n        true\nend rule\n\nrule theorem12b\n    replace [formula]\n        ( - ( P [formula] '| ( Q [formula] '| R [formula] ) ) '| ( ( P '| Q ) '| R ) ) \n    by\n        true\nend rule\n\nrule transitiveelimination1\n    replace [formula]\n        - ( - ( - P [formula] '| Q [formula] ) '| - ( - Q '| R [formula] ) ) \n    where not\n        P [= R]\n    by\n        ( - P '| R )\nend rule\n\nrule transitiveelimination2\n    replace [formula]\n        - ( - ( - P [formula] '| Q [formula] ) '| - ( R [formula] '| - Q ) ) \n    where not\n        P [= R]\n    by\n        ( - P '| R )\nend rule\n\nrule transitiveelimination3\n    replace [formula]\n        - ( - ( Q [formula] '| - P [formula] ) '| - ( - Q '| R [formula] ) ) \n    where not\n        P [= R]\n    by\n        ( - P '| R )\nend rule\n\nrule transitiveelimination4\n    replace [formula]\n        - ( - ( Q [formula] '| - P [formula] ) '| - ( R [formula] '| - Q ) ) \n    where not\n        P [= R]\n    by\n        ( - P '| R )\nend rule\n\nrule distributiveelimination1\n    replace [formula]\n        - ( - - ( - P [formula] '| - Q [formula] ) '| - ( - Q '| R [formula] ) )\n    by\n        - ( - P '| - R )\nend rule\n\nrule distributiveelimination2\n    replace [formula]\n        - ( - - ( - Q [formula] '| - P [formula] ) '| - ( - Q '| R [formula] ) )\n    by\n        - ( - P '| - R )\nend rule\n\nrule deductiveelimination1\n    replace [formula]\n        ( - P [formula] '| - ( - P '| R [formula] ) ) \n    by\n        - R\nend rule\n\nrule deductiveelimination2\n    replace [formula]\n        ( - ( - P [formula] '| R [formula] ) '| - P ) \n    by\n        - R\nend rule\n\n\n\nrule deductiveelimination4\n    replace [formula]\n        ( - - ( - Q [formula] '| - P [formula] ) '| Q )\n    by\n        P\nend rule\n\n",
        "after": " (- R | R) ",
        "before": "\n(- - (- P | - - (- (- P | Q) | - (- Q | R))) | R) "
    },
    {
        "hole_rule": "function changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function",
        "context": "function translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\n\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n",
        "after": " // Method implicitly throws an exception\n\n\nvirtual public String readUpTo (char terminator) {\n    String s = new String ();\n    while (true) {\n        int c = read ();\n        // Can throw IOException\n        \n\n        if (c == - 1 || c == terminator) return s.toString ();\n\n        s = s + c;\n    }\n}\n\n// Method catches an exception internally\n\n\nvirtual public int getLength () {\n    String s;\n    try {\n        s = readUpTo (':');\n    } catch (IOException e) {\n        return 0;\n    }\n    return s.length ();\n}\n\n// Method can throw a RuntimeException\n\n\nvirtual public int getAvgLength () {\n    int count = 0;\n    int total = 0;\n    int len;\n    while (true) {\n        len = getLength ();\n        if (len == 0) break;\n\n        count ++;\n        total += len;\n    }\n    return total / count;\n    // Can throw ArithmeticException\n    \n}\n\n ",
        "before": "\n// Method implicitly throws an exception\n\n\nString readUpTo (char terminator) throws IOException {\n    String s = new String ();\n    while (true) {\n        int c = read ();\n        // Can throw IOException\n        \n        if (c == - 1 || c == terminator) return s.toString ();\n\n        s = s + c;\n    }\n}\n\n// Method catches an exception internally\n\n\nint getLength () {\n    String s;\n    try {\n        s = readUpTo (':');\n    } catch (IOException e) {\n        return 0;\n    }\n    return s.length ();\n}\n\n// Method can throw a RuntimeException\n\n\nint getAvgLength () {\n    int count = 0;\n    int total = 0;\n    int len;\n    while (true) {\n        len = getLength ();\n        if (len == 0) break;\n\n        count ++;\n        total += len;\n    }\n    return total / count;\n    // Can throw ArithmeticException\n    \n}\n\n "
    },
    {
        "hole_rule": "function changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function",
        "context": "function changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\n\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " private void initialMethod2 () {\n    bool flag = false;\n}\n\n ",
        "before": "\nprivate void initialMethod2 () {\n    boolean flag = false;\n}\n\n "
    },
    {
        "hole_rule": "function changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function",
        "context": "function changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\n\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " Console.WriteLine (\"i is zero.\");\n ",
        "before": "\nSystem.out.println (\"i is zero.\");\n "
    },
    {
        "hole_rule": "function changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function",
        "context": "function translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\n\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " {\n    lock (this) {\n        count ++;\n    }\n} ",
        "before": "\n{\n    synchronized (this) {\n        count ++;\n    }\n} "
    },
    {
        "hole_rule": "function changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function",
        "context": "function translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\n\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " Console.WriteLine (\"Initializing instance variable\");\nreturn \"instance\";\n ",
        "before": "\nSystem.out.println (\"Initializing instance variable\");\nreturn \"instance\";\n "
    },
    {
        "hole_rule": "function changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function",
        "context": "function translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\n\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " private void initialMethod1 () {\n    int tmp = 1;\n    int x = 2;\n    int y = 10;\n}\n\n ",
        "before": "\nprivate void initialMethod1 () {\n    int tmp = 1;\n    int x = 2;\n    int y = 10;\n}\n\n "
    },
    {
        "hole_rule": "function toRight Pivot [id] N [id]\n    where not \n        N [< Pivot]\n    replace [id *] \n        List [id *]\n    by \n        N List\nend function",
        "context": "function partition N [id]\n    replace [range] \n        Left [id *] Pivot [id] Right [id *]\n    by \n        Left [toLeft Pivot N] \n        Pivot \n        Right [toRight Pivot N]\nend function\n\nfunction toLeft Pivot [id] N [id]\n    where \n        N [< Pivot]\n    replace [id *] \n        List [id *]\n    by \n        N List\nend function\n\n\n\n",
        "after": " depending depending ",
        "before": "\ndepending depending "
    },
    {
        "hole_rule": "rule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule",
        "context": "function translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\n\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n",
        "after": " // run time constants \n\npublic static readonly long l1 = new Date ().getTime ();\n\n// object reference as constant \n\nreadonly Object v = new Object ();\n// uninitialized final \n\nreadonly float f;\n\ninternal FieldDeclaration () {\n    // unitialized final variable must be initialized in constructor\n    \n    f = 17.21f;\n}\n\n ",
        "before": "\n// run time constants \n\npublic static readonly long l1 = new Date ().getTime ();\n// object reference as constant \n\nreadonly Object v = new Object ();\n// uninitialized final \n\nreadonly float f;\n\nFieldDeclaration () {\n    // unitialized final variable must be initialized in constructor\n    \n    f = 17.21f;\n}\n\n "
    },
    {
        "hole_rule": "function checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function",
        "context": "function translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\n\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " {\n\n    public static void Main (String [] args) {\n        int r = 3;\n        Console.WriteLine (0x0F1234567 >> 4);\n        if (j == 4) {\n            if (x > 0) {\n                x *= 7;\n            } else {\n                x *= - 7;\n            }\n        }\n        int i = 3;\n        //case 1 fall through case 2, and default option has no break\n        \n        switch (i) {\n            case 0 :\n                Console.WriteLine (\"i is zero.\");\n                break;\n            case 1 :\n                Console.WriteLine (\"i is one.\");\n                goto case 2;\n            case 2 :\n                Console.WriteLine (\"i is two.\");\n                break;\n            case 3 :\n                Console.WriteLine (\"i is three.\");\n                break;\n            default :\n                Console.WriteLine (\"i is greater than 3.\");\n                break;\n        }\n        //valid in C# and Java\n        \n        switch (i) {\n            case 0 :\n            case 1 :\n            case 2 :\n            case 3 :\n            case 4 :\n                Console.WriteLine (\"i is less than 5\");\n                break;\n            case 5 :\n            case 6 :\n            case 7 :\n            case 8 :\n            case 9 :\n                Console.WriteLine (\"i is less than 10\");\n                break;\n            default :\n                Console.WriteLine (\"i is 10 or more\");\n                break;\n        }\n    }\n\n    //main\n    \n}\n\n ",
        "before": "\n{\n\n    public static void main (String args []) {\n        int r = 3;\n        System.out.println (0x0F1234567 >>> 4);\n        if (j == 4) {\n            if (x > 0) {\n                x *= 7;\n            } else {\n                x *= - 7;\n            }\n        }\n        int i = 3;\n        //case 1 fall through case 2, and default option has no break\n        \n        switch (i) {\n            case 0 :\n                System.out.println (\"i is zero.\");\n                break;\n            case 1 :\n                System.out.println (\"i is one.\");\n            case 2 :\n                System.out.println (\"i is two.\");\n                break;\n            case 3 :\n                System.out.println (\"i is three.\");\n                break;\n            default :\n                System.out.println (\"i is greater than 3.\");\n        }\n        //valid in C# and Java\n        \n        switch (i) {\n            case 0 :\n            case 1 :\n            case 2 :\n            case 3 :\n            case 4 :\n                System.out.println (\"i is less than 5\");\n                break;\n            case 5 :\n            case 6 :\n            case 7 :\n            case 8 :\n            case 9 :\n                System.out.println (\"i is less than 10\");\n                break;\n            default :\n                System.out.println (\"i is 10 or more\");\n        }\n    }\n\n    //main\n    \n}\n\n "
    },
    {
        "hole_rule": "rule untransformForUpdate\n    replace $ [tcl_for_cmd]\n\t'for Init [tcl_cmd_set] Cond [tcl_cmd_set] Upd [tcl_cmd_set] Block [tcl_block]\n    by\n\t'for Init Cond Upd [untransformForUpdateMores] Block \nend rule",
        "context": "function addClassMetaAndClass\n    replace * [package_declaration]\n\tCmts [repeat comment_NL] \n\tPkgHead [opt package_header]\n\tImpDecl [repeat import_declaration] \n\tTypeDecl [repeat type_declaration]\n    deconstruct TypeDecl \n\t_ [repeat modifier] 'class ClassName [id] \n\tExtends [opt extends_clause] Implements [opt implements_clause] \n\t_ [class_body]\n\t_ [repeat type_declaration]\n    construct MetaClassName [id]\n\tClassName [_ 'metapapa]\n    construct ExtendClasses [repeat reference]\n\t_ [^ Extends]\n    construct Parents [repeat reference]\n\tExtendClasses [removeNonIdRef]\n    construct TclParents [repeat tcl_id]\n\t_ [pkgRef2TclId each Parents]\n    by\n\tCmts PkgHead ImpDecl \n\t'Class 'create MetaClassName '-superclass '{ 'Class '} '-slots '{ '}\n\tMetaClassName 'create ClassName '-superclass '{ 'Class TclParents '} \n\t'-slots '{ '}\n\tTypeDecl\nend function\n\nfunction constructorTransforms\n    replace [program]\n\tP [program]\n    by\n\tP [transformThisInConstructor] [transformSuperInConstructors]\nend function\n\nfunction transformExpressions\n    replace [program]\n\tP [program]\n    by\n\tP \n\t  [transformNewExpr]\n\n\t  [transformExceptions]\n\t  [transformConditionalStatements]\n\n\t  [transformVarAssignment]\n\n\n\t  [convertUnaryOpFirst]\n\t  [convertUnaryOpInMultiplicative]\nend function\n\nrule transformDefaultAttributes\n    replace [field_declaration]\n\t_ [repeat modifier] _ [type_specifier] Name [id] _ [opt generic_parameter] \n\t'= Literal [literal] '; \n    by\n\t'Attribute Name '-default Literal \nend rule\n\nrule transformInitAttributesNew\n    replace [field_declaration]\n\t_ [repeat modifier] _ [type_specifier] Name [id] _ [opt generic_parameter] \n\t'= New [class_instance_creation_expression] ';\n    construct NewCmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    by\n\t'Attribute Name '-initcmd '{ NewCmd '}\nend rule\n\nrule teleportClassStaticAttributes\n    replace $ [repeat type_declaration]\n\t%MetaClass\n\tMetaBase [id] MetaCreate [opt 'create] MetaClassName [id] MetaSuper [opt xotcl_class_superclasses]\n\t'-slots '{ '}\n\t%Class\n\tClassBase [id] ClassCreate [opt 'create] ClassName [id] ClassSuper [opt xotcl_class_superclasses]\n\t'-slots '{ '}\n\t%Java Class\n\tJClassHeader [class_header] JBody [class_or_interface_body]\n\t_ [repeat type_declaration]\n    construct JBodyElements [repeat class_body_declaration]\n\t_ [^ JBody]\n    construct JFields [repeat field_declaration]\n\t_ [^ JBody]\n    by\n\tMetaBase MetaCreate MetaClassName MetaSuper '-slots '{ JFields [removeNonStaticField] '}\n\tClassBase ClassCreate ClassName ClassSuper '-slots '{ JFields [removeStaticField] '}\n\tJClassHeader JBody \nend rule\n\nrule teleportClassStaticMethods\n    replace $ [repeat type_declaration]\n\t%Class\n\tClassBase [xotcl_class]\n\t%Java Class\n\tJClass [class_header] JBody [class_or_interface_body]\n\t_ [repeat type_declaration]\n    construct JMethods [repeat method_or_constructor_declaration]\n\t_ [^ JBody]\n    construct InstanceMethods [repeat method_or_constructor_declaration]\n\tJMethods [transformNonStaticMethod2Proc]\n    by\n\tClassBase\n\tJMethods [transformStaticMethod2Proc] [. InstanceMethods]\nend rule\n\nrule transformMethodsHeaders\n    replace $ [xotcl_class_with_methods]\n\tClass [xotcl_class]\n\tMethods [repeat method_or_constructor_declaration]\n    deconstruct Class\n\t_ [id] _ [opt 'create] \n\tName [id] _ [opt xotcl_class_superclasses] _ [opt xotcl_class_slots] \n    by\n\tClass\n\tMethods [transformNonStaticMethodHeader Name] \n\t\t[transformStaticMethodHeader Name]\n\t\t[transformSynchroNonStaticMethodHeader Name] \n\t\t[transformSynchroStaticMethodHeader Name]\n\t\t[transformConstructorHeader]\nend rule\n\nrule transformParameterVarRefs\n    replace $ [repeat method_or_constructor_declaration]\n \tMethod [method_or_constructor_declaration]\n \tMethods [repeat method_or_constructor_declaration]\n    deconstruct Method\n\t_ [id] _ [xotcl_proc_scope] _ [id] '{ VarIds [repeat id] '} _ [tcl_cmd_set]\n    by\n\tMethod [transformJavaVar2TclVar VarIds]\n\tMethods \nend rule\n\nrule transformDotRefs\n    replace [program]\n\tP [program]\n    where \n\tP [?transformRefMethodFirst1]\n\t  [?transformRefMethodFirst1In]\n\t  \n\t  [?transformRefMethodFirst]\n\t  [?transformRefMethod]\n\t  [?transformRefIdFirst]\n\t  [?transformRefId]\n\t  [?transformRefArray]\n    by \n\tP  [transformRefMethodFirst1]\n\t   [transformRefMethodFirst1In]\n  \n\t   [transformRefMethodFirst]\n\t   [transformRefMethod]\n\n\t   [transformRefIdFirst]\n\t   [transformRefId]\n\t   [transformRefArray] \nend rule\n\nrule varRef2TclRef\n    replace $ [reference]\n\tRef [reference]\n    construct RefNew [reference]\n\tRef [varRef2TclClassVar Ref]\n\t    [varRef2TclClassStaticVar Ref]\n\t    [varRef2TclVarSimple Ref]\n\t    [varRefThis2TclThis Ref]\n    by\n\tRefNew\nend rule\n\n\n\nfunction pkgRef2TclId Ref [reference]\n    replace [repeat tcl_id]\n\t_ [repeat tcl_id]\n    construct RefIds [repeat id]\n\t_ [^ Ref]\n    deconstruct RefIds\n\tFirstId [id] RestId [repeat id]\n    construct TclIdHead [tcl_id_head]\n\tFirstId\n    construct TclIdPart [repeat tcl_id_part]\n\t_ [addTclIdPart each RestId]\n    by\n\tTclIdHead TclIdPart\nend function\n\nrule removeNonIdRef\n    replace [repeat reference]\n\tFirst [reference] Rest [repeat reference]\n    deconstruct First\n\tPrima [primitive_type] _ [repeat dimension] _ [repeat component]\n    by\n\tRest\nend rule\n\nrule transformSuperInConstructors\n    replace $ [constructor_declaration]\n\tConstructor [constructor_declaration]\n    by\n\tConstructor [addSuperInConstructorIfAbsent Constructor]\n\t\t    [transformSuperInConstructor Constructor]\n\t\t    [removeSuperInConstructor]\nend rule\n\nrule transformThisInConstructor \n    replace $ [constructor_declaration]\n\tConstructor [constructor_declaration]\n    by\n\tConstructor [transformThisStatement Constructor]\nend rule\n\nrule transformVarAssignment\n    replace [declaration_or_statement]\n\t Ref [reference] '= Butt [assignment_expression] ';\n    construct TclCmd [repeat tcl_expr_more]\n\t_ [transformJavaLocalScopeVar Ref] \n\n\t  [transformJavaClassVar Ref] \n\t  [transformJavaClassStaticVar Ref] \n\n\t  [transformJavaThisVar Ref] \n\t  [transformJavaThisStaticVar Ref] \n\n\t  [complexRefAssignment Ref]\n\t  [assignToArrayRef Ref]\n    construct TclLit [tcl_expr_more]\n\t_ [transformArithAssExp Butt]\n\t  [transformLiteralAssExp Butt]\n\t  [transformRefAssExp Butt]\n\t  [transformNewAssExp Butt]\n    by\n\tTclCmd [. TclLit] '%\nend rule\n\nrule transformExceptions\n    replace $ [program]\n\tP [program]\n    by\n\tP [transformThrowStmt]\n\t  [transformTryCatch]\nend rule\n\nrule transformConditionalStatements\n    replace $ [program]\n\tP [program]\n    by\n\tP [transformIfElse]\n\t  [transformIf]\n%\t  [transformCondChoice]\n\t  [transformWhile]\n\t  [transformSwitch]\n\t  [transformFor]\n\t  [transformForeach]\nend rule\n\nrule convertUnaryOpInMultiplicative\n    replace $ [multiplicative_expression]\n\tMulti [multiplicative_expression]\n    deconstruct Multi\n\tRef [id] Op [pre_inc_dec]\n    by\n\tMulti [convertUnaryOpMultiMy]\n\t      [convertUnaryOpMultiClass]\n\t      [convertUnaryOpMultiLocal]\nend rule\n\nrule convertUnaryOpFirst\n    replace $ [declaration_or_statement]\n\tDecl [declaration_or_statement]\n    deconstruct Decl\n\tRef [id] Op [pre_inc_dec] ';\n    by\n\tDecl [convertUnaryOpFirstMy]\n\t     [convertUnaryOpFirstClass]\n\t     [convertUnaryOpFirstLocal]\nend rule\n\nrule transformNewExpr\n    replace $ [multiplicative_expression]\n\tNew [class_instance_creation_expression]\n    construct Cmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    deconstruct Cmd\n\t'[ Expr [tcl_expr] ']\n    by\n\t'[ Expr ']\nend rule\n\nfunction convertNewClassInstance New [class_instance_creation_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct New\n\t'new JClassName [reference] '( Args [list argument] ') _ [opt class_body]\n    construct TmpName [repeat tcl_id]\n\t_ [pkgRef2TclId JClassName]\n    deconstruct * TmpName\n\tClassName [tcl_id]\n    construct Args1 [repeat expression]\n\t_ [argumentToExpression each Args]\n    construct TclArgs [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args1]\n    by\n\t'[ ClassName ClassName TclArgs ']\nend function\n\nrule removeStaticField\n    replace [repeat field_declaration]\n\tFirst [field_declaration] Rest [repeat field_declaration]\n    where \n\tFirst [is_static]\n    by\n\tRest\nend rule\n\nrule removeNonStaticField\n    replace [repeat field_declaration]\n\tFirst [field_declaration] Rest [repeat field_declaration]\n    where not\n\tFirst [is_static]\n    by\n\tRest\nend rule\n\nrule transformStaticMethod2Proc\n    replace  [repeat method_or_constructor_declaration]\n\tMethod [method_or_constructor_declaration] \n\tMethods [repeat method_or_constructor_declaration]\n    where not\n\tMethod [is_static]\n    by\n\tMethods\nend rule\n\nrule transformNonStaticMethod2Proc\n    replace  [repeat method_or_constructor_declaration]\n\tMethod [method_or_constructor_declaration] \n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tMethod [is_static]\n    by\n\tMethods\nend rule\n\nrule transformNonStaticMethodHeader ClassName [id]\n    replace [method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n    where not\n\tJModifiers [is_synchronized]\n    where not\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    by\n\tClassName 'instproc JName '{ ParamsNames '}  Body\nend rule\n\nrule transformStaticMethodHeader ClassName [id]\n    replace [method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n    where not\n\tJModifiers [is_synchronized]\n    where\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    by\n\tClassName 'proc JName '{ ParamsNames '}  Body\nend rule\n\nrule transformSynchroNonStaticMethodHeader ClassName [id]\n    replace [repeat method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tJModifiers [is_synchronized]\n    where not\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n    construct JSynchName [id]\n\tJName [_ 'synchrobaby]\n    construct MutexName [id]\n\tClassName [_ JName] [_ 'mutex]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'thread::mutex 'lock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'set 'cought 0 '%\n\t'#call the real method implementation\n\t'if '{ '[ 'catch '{ 'my JSynchName ParamsAsVars '} 'result '] '} '{\n\t'set 'cought 1 '%\n\t'} \n\t'thread::mutex 'unlock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'#transfer exception to the upper level\n\t'if '{ '$cought '} '{ 'error '$result '} \n\t'}\n    by\n\tClassName 'instproc JName '{ ParamsNames '} ProcBody \n\tClassName 'instproc JSynchName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformSynchroStaticMethodHeader ClassName [id]\n    replace [repeat method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tJModifiers [is_synchronized]\n    where\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n    construct JSynchName [id]\n\tJName [_ 'synchrobaby]\n    construct MutexName [id]\n\tClassName [_ JName] [_ 'mutex]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'thread::mutex 'lock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'set 'cought 0 '%\n\t'#call the real method implementation\n\t'if '{ '[ 'catch '{ 'my JSynchName ParamsAsVars '} 'result '] '} '{\n\t'set 'cought 1 '%\n\t'} \n\t'thread::mutex 'unlock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'#transfer exception to the upper level\n\t'if '{ '$cought '} '{ 'error '$result '} \n\t'} \n    by\n\tClassName 'proc JName '{ ParamsNames '} ProcBody \n\tClassName 'proc JSynchName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformConstructorHeader\n    replace [repeat method_or_constructor_declaration]\n \tConstructor [constructor_declaration]\n \tMethods [repeat method_or_constructor_declaration]\n    deconstruct Constructor\n\tJModifiers [repeat modifier] \n\tJClassName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') \n\t_ [opt throws] Body [block]\n\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n\n    construct ParamsString [id]\n\t_ [buildParameterTypeList each Parameters]\n    construct XNew [id]\n\t_ [+ JClassName] \n    construct XNewBody [id]\n\t_ [+ JClassName] [+ \"_body\"]\n    construct XNewName [id]\n\tXNew [+ ParamsString]\n    construct XNewBodyName [id]\n\tXNewBody [+ ParamsString]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'#create new object\n\t'set 'obj '[ JClassName 'new '] '%\n\t'#call the constructor\n\t'$obj XNewBodyName ParamsAsVars '%\n\t'#return new object after constructor's work is done\n\t'return '$obj '%\n\t'} \n    by\n\tJClassName 'proc XNewName '{ ParamsNames '} ProcBody\n\tJClassName 'instproc XNewBodyName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformJavaVar2TclVar VarIds [repeat id]\n    replace $ [reference]\n\tId [id] _ [repeat dimension] Comp [repeat component]\n    construct Len [number]\n\t_ [length Comp]\n    where \n\tLen [= 0]\n    where\n\tId [= each VarIds]\n    by\n\t'$ Id\nend rule\n\nrule transformRefMethodFirst1\n    replace [declaration_or_statement]\n\tId [id] _ [repeat dimension] Comps [repeat component] ';\n    construct CompsLen [number]\n\t_ [length Comps]\n    where \n\tCompsLen [= 1]\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'my Id Exps '%\nend rule\n\nrule transformRefMethodFirst1In\n    replace [reference]\n\tId [id] _ [repeat dimension] Comps [repeat component] \n    construct CompsLen [number]\n\t_ [length Comps]\n    where \n\tCompsLen [= 1]\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'[ 'my Id Exps '] \nend rule\n\nrule transformRefMethodFirst\n    replace [declaration_or_statement]\n\tId [id] Dims [repeat dimension] Comps [repeat component] ';\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct CompsLenFinal [number]\n\t_ [length Comps] [- 2]\n    construct NewCompsTmp [repeat component]\n\tComps [head CompsLen]\n    construct NewComps [repeat component]\n\tComps [head CompsLenFinal]\n    construct RefIds [repeat id]\n\t_ [^ NewCompsTmp]\n    deconstruct * RefIds\n\tMethodName [id]\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\tId [this2my] Dims NewComps MethodName Exps '%\nend rule\n\nrule transformRefMethod\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct CompsLenFinal [number]\n\t_ [length Comps] [- 2]\n    construct NewCompsTmp [repeat component]\n\tComps [head CompsLen]\n    construct NewComps [repeat component]\n\tComps [head CompsLenFinal]\n    construct RefIds [repeat id]\n\t_ [^ NewCompsTmp]\n    deconstruct * RefIds\n\tMethodName [id]\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'[ Id [this2my] Dims NewComps MethodName Exps '] \nend rule\n\nrule transformRefIdFirst\n    replace [declaration_or_statement]\n\tId [id] _ [repeat dimension] Comps [repeat component] '= AssExp [assignment_expression] ';\n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    by\n\tId NewComps 'set VarId AssExp '%\nend rule\n\nrule transformRefId\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps\n    by\n\t'[ NewRef 'set VarId ']\nend rule\n\nrule transformRefArray\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\tDim [dimension]\n\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n\n\n    deconstruct * NewComps\n\t'. VarId [id]\n    construct CompsLen2 [number]\n\t_ [length NewComps] [- 1]\n    construct DimComp [component]\n\tDim\n    construct NewComps2 [repeat component]\n\tNewComps [head CompsLen2] % [. DimComp]\n\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps2 \n\n    construct TmpDims [repeat dimension]\n\tDim\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim TmpDims]\n\n    by\n\t'[ NewRef 'set VarId TclDim ']\nend rule\n\nfunction varRef2TclClassVar Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where \n\tId [is_class_var]\n    by\n\t'[ 'my 'set Id TclDim ']\nend function\n\nfunction varRef2TclClassStaticVar Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ '[ 'my 'class '] 'set Id TclDim ']\nend function\n\nfunction varRef2TclVarSimple Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where all \n\tId [>= 'a] [<= 'z]\n    where not\n\tId [is_staticclass_var]\n\t   [is_class_var]\n    deconstruct not Id\n\t'my\n    by\n\t'$ Id TclDim\nend function\n\nfunction varRefThis2TclThis Ref [reference]\n    deconstruct Ref\n\t'this\n    replace [reference]\n\t_ [reference]\n    by\n\t'[ 'self ']\nend function\n\nrule untransformForUpdateMores\n%    skipping [tcl_expr_more]\n    replace $ [tcl_expr]\n\tExp [tcl_expr]\n    deconstruct Exp\n\tRef [reference]\n    deconstruct Ref\n\t'[ More [tcl_expr] ']\n    by\n\tMore\nend rule\n\nfunction addTclIdPart Id [id]\n    replace [repeat tcl_id_part]\n\tParts [repeat tcl_id_part]\n    construct Part [tcl_id_part]\n\t':: Id\n    by\n\tParts [. Part]\nend function\n\nrule addSuperInConstructorIfAbsent Constructor [constructor_declaration] \n    replace $ [constructor_body]\n\t'{ Decls [repeat declaration_or_statement] '}\n    where not\n\tDecls [?transformSuperInConstructor Constructor]\n    by\n\t'{\n\t'super '( ') ';\n\tDecls '}\nend rule\n\nrule transformSuperInConstructor Constructor [constructor_declaration] \n    replace $ [declaration_or_statement]\n\t'super MethArg [method_argument] ';\n    import JClassOrigin [class_declaration]\n    deconstruct JClassOrigin\n\t_ [repeat modifier] 'class _ [class_name] \n\tExtends [opt extends_clause] \n\t_ [opt implements_clause] _ [class_body]\n    construct ExtendClasses [repeat reference]\n\t_ [^ Extends]\n    construct Parents [repeat reference]\n\tExtendClasses [removeNonIdRef]\n    deconstruct * ExtendClasses \n\tParentName [id]\n    construct Args [repeat expression]\n\t_ [^ MethArg]\n    construct VarIds [repeat id]\n\t_ [^ Args]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    construct TypeString [id]\n\t_ [buildVarsTypeList4Constructor Constructor each VarIds]\n    construct XNewName [id]\n\t_ [+ ParentName] [+ \"_body\"] [+ TypeString]\n    by\n\t'my XNewName Exps '% \nend rule\n\nrule removeSuperInConstructor \n    replace [repeat declaration_or_statement]\n\t'super MethArg [method_argument] ';\n\tDecls [repeat declaration_or_statement]\n    by\n\tDecls\nend rule\n\nrule transformThisStatement Constructor [constructor_declaration] \n    replace $ [declaration_or_statement]\n\t'this MethArg [method_argument] ';\n    deconstruct Constructor\n\t_ [repeat modifier] ClassName [id] _ [opt generic_parameter]\n\t'( _ [list formal_parameter] ')  _ [opt throws] _ [constructor_body]\n    construct Args [repeat expression]\n\t_ [^ MethArg]\n    construct VarIds [repeat id]\n\t_ [^ Args]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    construct TypeString [id]\n\t_ [buildVarsTypeList4Constructor Constructor each VarIds]\n    construct XNewName [id]\n\t_ [+ ClassName] [+ \"_body\"] [+ TypeString]\n    by\n\t'my XNewName Exps '% \nend rule\n\nfunction transformJavaLocalScopeVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    by\n\t'set Id TclDim\nend function\n\nfunction transformJavaClassVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    where \n\tId [is_class_var]\n    by\n\t'my 'set Id TclDim\nend function\n\nfunction transformJavaClassStaticVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ 'my 'class '] 'set Id TclDim\nend function\n\nfunction transformJavaThisVar Ref [reference]\n    deconstruct Ref\n\t'this '. Id [id] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_class_var]\n    by\n\t'my 'set Id \nend function\n\nfunction transformJavaThisStaticVar Ref [reference]\n    deconstruct Ref\n\t'this '. Id [id] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ 'my 'class '] 'set Id \nend function\n\nfunction complexRefAssignment Ref [reference]\n    deconstruct Ref\n\tId [id] Dim [repeat dimension] Comps [repeat component+] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    construct ExprLen [number]\n\t_ [length Expr]\n    where not\n\tExprLen [> 0]\n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    construct NewRef [reference]\n\tId Dim NewComps\n    by\n\tNewRef 'set VarId \nend function\n\nfunction assignToArrayRef Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n\n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    construct ExprLen [number]\n\t_ [length Expr]\n    where not\n\tExprLen [> 0]\n\n    deconstruct * Comps\n\tDim [dimension]\n\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n\n\n    deconstruct * NewComps\n\t'. VarId [id]\n    construct CompsLen2 [number]\n\t_ [length NewComps] [- 1]\n    construct DimComp [component]\n\tDim\n    construct NewComps2 [repeat component]\n\tNewComps [head CompsLen2] % [. DimComp]\n\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps2 \n\n    construct TmpDims [repeat dimension]\n\tDim\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim TmpDims]\n\n    by\n        NewRef 'set VarId TclDim \nend function\n\nfunction transformArithAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    where\n\tButt [is_arithmetic]\n    construct TclRef [tcl_expr_more]\n\t'[ 'expr '{ Butt '} ']\n    by\n\tTclRef\nend function\n\nfunction transformLiteralAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tLiteral [literal]\n    by\n\tLiteral\nend function\n\nfunction transformRefAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tRef [reference]\n    by\n\tRef\nend function\n\nfunction transformNewAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tNew [class_instance_creation_expression]\n    construct NewCmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    by\n\tNewCmd\nend function\n\nrule transformTryCatch\n    replace $ [declaration_or_statement]\n\t'try Block [block] Catches [repeat catch_clause] _ [opt finally_clause]\n    deconstruct Block\n\t'{ BlockStmts [repeat declaration_or_statement] '}\n    construct CatchesStmts [repeat declaration_or_statement]\n\t_ [^ Catches]\n    construct CatchBlock [xotcl_proc_body]\n\tCatchesStmts\n    by\n\t'if '{ '[ 'catch '{ BlockStmts '} 'result '] '} '{\n\tCatchBlock\n\t'} \nend rule\n\nrule transformThrowStmt\n    replace $ [declaration_or_statement]\n\t_ [throw_statement]\t\n    by\n\t'error '$result\nend rule\n\nrule transformIf\n    replace [declaration_or_statement]\n\t'if '( IfExpr [expression] ') _ [repeat comment_NL]\n\tStmt [statement] \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct IfTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    construct TclIf [tcl_if_cmd]\n\t'if '{ IfExpr '} IfTclBlock\n    by\n\tTclIf\nend rule\n\nrule transformIfElse\n    replace [declaration_or_statement]\n\t'if '( IfExpr [expression] ') IfStmt [statement] _ [repeat comment_NL]\n\t'else ElseStmt [statement]\n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct IfTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok IfStmt] \n\t\t      [statementBlockToTclBlock IfStmt]\n    construct ElseTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok ElseStmt] \n\t\t      [statementBlockToTclBlock ElseStmt]\n    deconstruct IfTclBlock\n\t'{ IfBody [opt xotcl_proc_body] '}\n    construct TclIf [tcl_if_cmd]\n\t'if '{ IfExpr '} '{ IfBody '} 'else ElseTclBlock\n    by\n\tTclIf\nend rule\n\nrule transformCondChoice\n    replace $ [assignment_expression]\n\tCond [conditional_expression]\n    deconstruct Cond\n\tUna [unary_expression] '? Exp [expression] ': CondChExp [conditional_expression]\n    by\n\t'[ 'expr '{ Una '? Exp  ': CondChExp '} ']\nend rule\n\nrule transformWhile\n    replace [declaration_or_statement]\n\t'while '( Expr [expression] ') Stmt [statement] \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct WhileTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    construct TclWhile [tcl_while_cmd]\n\t'while '{ Expr '}  WhileTclBlock\n    by\n\tTclWhile\nend rule\n\nrule transformSwitch\n    replace [declaration_or_statement]\n\t'switch '( Expr [expression] ') '{ JAlts [repeat switch_alternative] '}\n    construct Alts [repeat tcl_switch_entry]\n\t_ [transformSwitchAlternatives each JAlts] \n    construct TclSwitch [tcl_switch_cmd]\n\t'switch Expr '{ Alts '} \n    by\n\tTclSwitch\nend rule\n\nrule transformFor\n    replace [declaration_or_statement]\n\t'for '( ForInit [for_init] \n\tForExpr [opt expression] '; \n\tForUpd [list expression] ') \n\tStmt [statement] \n    construct ForUpdSeq [repeat expression]\n\t_ [. each ForUpd]\n    construct TclCmdLists [repeat tcl_cmd_list]\n\t_ [expressionListToTclCmdList ForUpdSeq] \n\t  [transformVarAssignmentFor]\n    construct TclForInit [repeat tcl_cmd_list]\n\t_ [transformForInitStmt1 ForInit] \n\t  [transformForInitStmt2 ForInit]\n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct ForTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    by\n\t'for '{ TclForInit '} \n\t'{ ForExpr '} '{ TclCmdLists '}\n\tForTclBlock\nend rule\n\nrule transformForeach\n    replace [declaration_or_statement]\n\t'for '( \n\t%for_in_init\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t': Expr [expression] ')\n\t\tStmt [statement]        \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct ForTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    by\n\t'foreach '{ Id '} '{ Expr '}\n\tForTclBlock\nend rule\n\nrule convertUnaryOpMultiLocal\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpMultiMy\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    where \n\tRef [is_class_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'my 'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpMultiClass\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    where \n\tRef [is_staticclass_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'[ 'my 'class '] 'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpFirstLocal\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nrule convertUnaryOpFirstMy\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    where \n\tRef [is_class_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'my 'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nrule convertUnaryOpFirstClass\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    where \n\tRef [is_staticclass_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'[ 'my 'class '] 'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nfunction expressionSeq2TclExprMoreSeq Expressions [repeat expression]\n    replace [repeat tcl_expr_more]\n\tEMore [repeat tcl_expr_more]\n    deconstruct Expressions\n\tExpr [expression] Exprs [repeat expression]\n    construct TclEMore [repeat tcl_expr_more]\n\tExpr\n    by\n\tEMore [. TclEMore] [expressionSeq2TclExprMoreSeq Exprs]\nend function\n\nfunction argumentToExpression Argument [argument]\n    replace [repeat expression]\n\tExps [repeat expression]\n    deconstruct Argument\n\tExp [expression]\n    by\n\tExps [. Exp]\nend function\n\nfunction is_static \n    match * [modifier]\n\t'static\nend function\n\nfunction is_synchronized\n    match * [modifier]\n\t'synchronized\nend function\n\nfunction transformId2TclVar Id [id]\n    replace [repeat tcl_expr_more]\n\tCmds [repeat tcl_expr_more]\n    construct Var [tcl_expr_more]\n\t'$ Id\n    by\n\tCmds [. Var]\nend function\n\nfunction buildParameterTypeList Parameter [formal_parameter]\n    replace [id]\n\tParams [id] \n    construct TypeName [id]\n\t_ [extractPrimitiveTypeName Parameter]\n\t  [extractReferenceTypeName Parameter]\n    by\n\tParams [_ TypeName]\nend function\n\nfunction this2my \n    replace [id]\n\t'this\n    by\n\t'my\nend function\n\nfunction dim2TclDim Dims [repeat dimension]\n    construct DimLen [number]\n\t_ [length Dims]\n    where \n\tDimLen [= 1]\n    deconstruct Dims\n\tDim [dimension] _ [repeat dimension]\n    deconstruct Dim\n\t'[ Expr [expression] ']\n    replace [repeat tcl_array_dimension]\n\t_ [repeat tcl_array_dimension]\n    by\n\t'( Expr ')\nend function\n\nfunction is_class_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_nonstatic_var Id]\nend function\n\nfunction is_staticclass_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_static_var Id]\nend function\n\nfunction buildVarsTypeList4Constructor Constructor [constructor_declaration] VarId [id]\n    replace [id]\n\tIds [id]\n    construct Tmp1 [constructor_declaration]\n\tConstructor [findVarTypeInConstructorParams VarId]\n    import TypeName [id]\n    by\n\tIds [+ TypeName]\nend function\n\nrule is_arithmetic\n    match $ [any]\n\tAny [any]\n    where \n\tAny [istype 'add_op]\n\t    [istype 'mult_op]\n\t    [istype 'unary_op]\n\t    [istype 'or_conditional_and_expression]\n\t    [istype 'and_inclusive_or_expression]\n\t    [istype 'or_exclusive_or_expression]\n\t    [istype 'or_and_expression]\n\t    [istype 'and_equality_expression]\n\t    [istype 'equality_op]\n\t    [istype 'relational_op]\n\t    [istype 'shif_op]\n\t    [istype 'conditional_choice]\nend rule\n\nfunction statementOneDeclToTclBlcok Stmt [statement]\n    replace [tcl_block]\n\t_ [tcl_block]\n    deconstruct not Stmt\n\t_ [block]\n    construct Decl [declaration_or_statement]\n\tStmt\n    by\n\t'{ Decl '}\nend function\n\nfunction statementBlockToTclBlock Stmt [statement]\n    replace [tcl_block]\n\t_ [tcl_block]\n    deconstruct Stmt\n\t'{ Decls [repeat declaration_or_statement] '}\n    by\n\t'{ Decls '}\nend function\n\nfunction transformSwitchAlternatives JAlt [switch_alternative]\n    replace [repeat tcl_switch_entry]\n\tEntries [repeat tcl_switch_entry]\n    deconstruct JAlt\n\t'case Label [constant_expression] ': Decls [repeat declaration_or_statement]\n    construct SwitchLabel [tcl_cmd]\n\t_ [switchLabelConvertNum Label] [switchLabelConvertChar Label]\n    construct Entry [tcl_switch_entry]\n\tSwitchLabel '{ Decls '} \t\n    by\n\tEntries [. Entry]\nend function\n\nfunction expressionListToTclCmdList Expressions [repeat expression]\n    replace [repeat tcl_cmd_list]\n\t_  [repeat tcl_cmd_list]\n    deconstruct Expressions\n\tExpr [expression] Exprs [repeat expression]\n    construct TclCmdList [tcl_cmd_list]\n\tExpr\n    by\n\tTclCmdList [addExpToTclCmdList each Exprs]\nend function\n\nfunction transformForInitStmt1 ForInit [for_init]\n    deconstruct ForInit\n\tExprs [list expression] ';\n    replace [repeat tcl_cmd_list]\n\t_ [repeat tcl_cmd_list]\n    construct ExprSeq [repeat expression]\n\t_ [. each Exprs]\n    by\n\t_ [expressionListToTclCmdList ExprSeq] [transformVarAssignmentFor]\nend function\n\nfunction transformForInitStmt2 ForInit [for_init]\n    deconstruct ForInit\n\tLocalDecl [declaration_or_statement] \n    construct TmpDecls [repeat declaration_or_statement]\n\tLocalDecl\n    construct TmpDecls2 [repeat declaration_or_statement]\n\tTmpDecls [splitLocalVarDeclarations] [localVarDecl2Assignment]\n    deconstruct TmpDecls2\n\tDecl1 [declaration_or_statement] _ [repeat declaration_or_statement]\n    replace [repeat tcl_cmd_list]\n\t_ [repeat tcl_cmd_list]\n    by\n%\tLocalDecl\n\tTmpDecls2\nend function\n\nrule transformVarAssignmentFor\n    replace [repeat tcl_expr_more]\n\t Ref [reference] '= Butt [assignment_expression] \n    construct TclCmd [repeat tcl_expr_more]\n\t_ [transformJavaLocalScopeVar Ref] \n\n\t  [transformJavaClassVar Ref] \n\t  [transformJavaClassStaticVar Ref] \n\n\t  [transformJavaThisVar Ref] \n\t  [transformJavaThisStaticVar Ref] \n\n\t  [complexRefAssignment Ref]\n\t  [assignToArrayRef Ref]\n    construct TclLit [tcl_expr_more]\n\t_ [transformArithAssExp Butt]\n\t  [transformLiteralAssExp Butt]\n\t  [transformRefAssExp Butt]\n\t  [transformNewAssExp Butt]\n    by\n\tTclCmd [. TclLit] \nend rule\n\nfunction makeDecrCmdTail Op [pre_inc_dec]\n    deconstruct Op\n\t'--\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    construct Num [tcl_literal]\n\t-1\n    by\n\tNum\nend function\n\nfunction extractPrimitiveTypeName Parameter [formal_parameter]\n    replace [id]\n\t_ [id]\n    construct Primitive [repeat primitive_type]\n\t_ [^ Parameter]\n    deconstruct Primitive\n\tFirst [primitive_type] _ [repeat primitive_type]\n    construct TypeName [id]\n\t_ [quote First]\n    by\n\t_ [+ TypeName]\nend function\n\nfunction extractReferenceTypeName Parameter [formal_parameter]\n    replace [id]\n\t_ [id]\n    construct References [repeat reference]\n\t_ [^ Parameter]\n    deconstruct References\n\t_ [id] _ [repeat dimension] _ [repeat component]\n    construct Ids [repeat id]\n\t_ [^ References]\n    deconstruct * Ids \n\tTypeName [id]\n    by\n\t_ [+ TypeName]\nend function\n\nfunction is_nonstatic_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where\n\tField [has_var Id] \n    where not\n\tField [is_static]\nend function\n\nfunction is_static_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where all\n\tField [has_var Id] [is_static]\nend function\n\nrule findVarTypeInConstructorParams VarId [id]\n    replace $ [formal_parameter]\n\tFP [formal_parameter]\n    deconstruct FP\n\t_ [opt 'final] _ [type_specifier] _ [opt var_arg_specifier] \n\tId  [id] _ [opt generic_parameter] _ [repeat dimension]\n    where \n\tId [= VarId]\n    construct TypeName [id]\n\t_ [buildParameterTypeList FP]\n    export TypeName\n    by\n\tFP\nend rule\n\nfunction switchLabelConvertNum Label [constant_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct Label\n\tNum [number]\n    by\n\tNum\nend function\n\nfunction switchLabelConvertChar Label [constant_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct Label\n\tChars [charlit]\n    construct Unq [id]\n\t_ [unquote Chars]\n    by\n\tUnq\nend function\n\nfunction addExpToTclCmdList Expr [expression]\n    replace [tcl_cmd_list]\n\tTclExpr [tcl_expr] TclCmdMore [repeat tcl_cmd_more]\n    construct TclCmdMore2 [tcl_cmd_more]\n\t'; Expr\n    by\n\tTclExpr TclCmdMore [. TclCmdMore2]\nend function\n\nrule splitLocalVarDeclarations\n    replace [repeat declaration_or_statement]\n\tModr [repeat modifier] TypSpec [type_specifier] VarDecl [variable_declarator] ', VarDeclRest [list variable_declarator+] '; \n\tRest [repeat declaration_or_statement]\n    by\n\tModr TypSpec VarDecl ';\n\tModr TypSpec VarDeclRest ';\n\tRest\nend rule\n\nrule localVarDecl2Assignment\n    replace $ [declaration_or_statement]\n\tDecl [declaration_or_statement] \n    deconstruct Decl\n\t_ [repeat modifier] _ [type_specifier] _ [variable_declarators] ';\n    by\n\tDecl [localVarDecl2AssignmentExp] [localVarDecl2AssignmentArray] \nend rule\n\nfunction has_var Id [id]\n    match * [variable_name]\n\tVarId [id] _ [opt generic_parameter] _ [repeat dimension]\n    where \n\tVarId [= Id]\nend function\n\nfunction localVarDecl2AssignmentExp\n    replace [declaration_or_statement]\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t'= Exp [conditional_expression] ';\n    construct Ass [assignment_expression]\n\tId '= Exp \n    by\n\tAss ';\nend function\n\nfunction localVarDecl2AssignmentArray\n    replace [declaration_or_statement]\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t'= Exp [array_initializer] ';\n    construct Ass [assignment_expression]\n\tId '= Exp \n    by\n\tAss ';\nend function\n\n",
        "after": " package require XOTcl\nnamespace import ::xotcl::*\n\nClass create UnaryDemo_metapapa -superclass {Class} -slots {\n\n}\n\nUnaryDemo_metapapa create UnaryDemo -superclass {Class} -slots {\n\n}\n\nUnaryDemo proc main {args} {\n    set result [expr {+1}]\n    // result is now 1\n    \n    [System set out] println $result\n    incr result -1\n    // result is now 0\n    \n    [System set out] println $result\n    incr result\n    // result is now 1 \n    \n    [System set out] println $result\n    set result [expr {-$result}]\n    // result is now -1\n    \n    [System set out] println $result\n    set success 0\n    [System set out] println $success\n    // false\n    \n    [System set out] println !$success\n    // true\n    \n}\n\n ",
        "before": "\npackage require XOTcl\nnamespace import ::xotcl::*\n\nclass UnaryDemo {\n\n    public static void main (String [] args) {\n        result = +1;\n        // result is now 1\n        \n        System.out.println (result);\n        result --;\n        // result is now 0\n        \n        System.out.println (result);\n        result ++;\n        // result is now 1 \n        \n        System.out.println (result);\n        result = -result;\n        // result is now -1\n        \n        System.out.println (result);\n        success = 0;\n        System.out.println (success);\n        // false\n        \n        System.out.println (!success);\n        // true\n        \n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function",
        "context": "function translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\n\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " Console.WriteLine (\"target is zero\");\nbreak;\n ",
        "before": "\nSystem.out.println (\"target is zero\");\nbreak;\n "
    },
    {
        "hole_rule": "function removeEmptyArgsFromProc\n    replace [function_definition]\n\t'procedure N [identifier] '( ')\n\t    D [repeat externaldefinition]\n\t    S [repeat statement]\n\t'end N\n    by\n\t'procedure N\n\t    D\n\t    S\n\t'end N\nend function",
        "context": "function translateCConst\n    replace [externaldefinition]\n\t'const T [type_specifier] N [identifier] '= E [expression] ';\n    construct NewType [type_specifier]\n\tT [changeType]\n    by\t\n\t'const N ': NewType ':= E\nend function\n\nfunction translateCType\n    replace [externaldefinition]\n\t'typedef T [type_specifier] OP [opt pointer] N [identifier] OAP [opt array_part] ';\n    construct NewType [type_specifier]\n\tT [changeType]\n    construct NewTuringType [externaldefinition]\n\t'type N : NewType\n    by\n\tNewTuringType\nend function\n\nfunction translateCVar\n    replace [externaldefinition]\n\tT [type_specifier] D [list decl_id_part+] ';\n    construct NewTuringVar [repeat t_var]\n\t_ [translatePointerVarDecl T each D]\n\t  [translateVarDecl T each D]\n    construct NewED [externaldefinition]\n\tNewTuringVar\n    by\n\tNewED\nend function\n\nfunction translateCFunction\n    replace [externaldefinition]\n\tF [function_definition]\n    construct NewTuringFunction [externaldefinition]\n\tF [translateProcedure]\t\t%% must be done before functions\n\t  [translateFunction]\n    by\n\tNewTuringFunction\nend function\n\nfunction changeType\n    construct CTypes [repeat type_specifier]\n    \t'char 'long 'float 'double\n    construct TuringTypes [repeat type_specifier]\n    \t'string(1) 'int 'real 'real\n    replace * [type_specifier]\n        CType [type_specifier]\n    by\n\tCType [$ each CTypes TuringTypes]\nend function\n\nfunction translateVarDecl T [type_specifier] D [decl_id_part]\n    deconstruct D\n\tDI [decl_identifier] OAP [opt array_part] OI [opt initialisation]\n    replace [repeat t_var]\n\tSoFar [repeat t_var]\n    construct TuringVar [t_var]\n\t'var DI ': T\n    construct NewTuringVar [t_var]\n\tTuringVar [addOptArrayPart OAP]\n\t\t  [addOptInit OI]\n\t\t  [changeType]\n    by\n\tSoFar [. NewTuringVar]\t\nend function\n\nfunction translatePointerVarDecl T [type_specifier] D [decl_id_part]\n    deconstruct D\n\t'* DI [decl_identifier] OAP [opt array_part] OI [opt initialisation]\n    deconstruct T\n\t'char\n    replace [repeat t_var]\n\tSoFar [repeat t_var]\n    construct TuringVar [t_var]\n\t'var DI ': 'string\n    construct NewTuringVar [t_var]\n\tTuringVar [addOptArrayPart OAP]\n\t\t  [addOptInit OI]\n    by\n\tSoFar [. NewTuringVar]\t\nend function\n\nfunction translateFunction\n    replace [function_definition]\n\tTS [type_specifier] N [identifier] '( AD [list argument_declaration] ')\n\tCS [compound_statement]\n    construct TuringArgs [list argument_declaration]\n\t_ [translateArg each AD]\n    construct ArgPart [t_paramDecl]\n\t'( TuringArgs ')\n    construct NewFunc [function_definition]\n\t'function N ArgPart ': TS\n\t    CS [changeCompound]\n\t'end N\n    by\n\tNewFunc [removeBeginEndFromFunc] \n\t\t[removeEmptyArgsFromFunc]\nend function\n\nfunction translateProcedure\n    replace [function_definition]\n\t'void N [identifier] '( AD [list argument_declaration] ')\n\tCS [compound_statement]\n    construct TuringArgs [list argument_declaration]\n\t_ [translateArg each AD]\n    construct ArgPart [t_paramDecl]\n\t'( TuringArgs ')\n    construct NewProc [function_definition]\n\t'procedure N ArgPart\n\t    CS [changeCompound]\n\t'end N\n    by\n    NewProc [removeBeginEndFromProc] \n    \t    [removeEmptyArgsFromProc]\nend function\n\nfunction addOptInit OI [opt initialisation]\n    deconstruct OI\n\t'= E [expression]\n    replace [t_var]\n\t'var DI [decl_identifier] ': T [type_specifier]\n    by\n\t'var DI ': T ':= E [changeExpression]\nend function\n\nfunction addOptArrayPart OAP[opt array_part]\n    deconstruct OAP\n\t'[ N [number] ']\n    replace [t_var]\n\t'var DI [decl_identifier] ': T [type_specifier]\n    construct NewN [number]\n\tN [- 1]\n    construct TuringArraySpec [type_specifier]\n\t'array 0 .. NewN 'of T\n    construct NewTuringArraySpec [type_specifier]\n\tTuringArraySpec [changeToStringSpec]\n    by\n\t'var DI ': NewTuringArraySpec\nend function\n\nfunction translateArg AD [argument_declaration]\n    deconstruct AD\n\tT [type_specifier] DI [decl_identifier] OAP [opt array_part] OI [opt initialisation]\n    replace [list argument_declaration]\n\tSoFar [list argument_declaration]\n    construct TuringArg [argument_declaration]\n\tDI ': T\n    construct NewTuringArg [argument_declaration]\n\tTuringArg [changeOptArrayPart OAP]\n\t\t  [changeType]\n    by\n\tSoFar [, NewTuringArg]\t\nend function\n\nfunction removeBeginEndFromFunc\n    replace [function_definition]\n\t'function N [identifier] OA [opt t_paramDecl] ': TS [type_specifier]\n\t    'begin\n\t\tD [repeat externaldefinition]\n\t\tS [repeat statement]\n\t    'end\n\t'end N\n    construct NewType [type_specifier]\n\tTS [changeType]\n    by\n\t'function N OA ': NewType\n\t    D\n\t    S\n\t'end N\nend function\n\nfunction removeEmptyArgsFromFunc\n    replace [function_definition]\n\t'function N [identifier] '( ') ': TS [type_specifier] \n\t    D [repeat externaldefinition]\n\t    S [repeat statement]\n\t'end N\n    by\n\t'function N ': TS\n\t    D\n\t    S\n\t'end N\nend function\n\nrule changeCompound\n    replace [compound_statement]\n\t'{\n\t\tD [repeat declaration] \n\t\tS [repeat statement]\n\t'} OS [opt ';]\n    construct ExtDefs [repeat externaldefinition]\n\t_ [makeExternalDef each D]\n    construct TuringDecls [repeat externaldefinition]\n\t_ [changeExternalDef each ExtDefs]\n    construct TuringStatements [repeat statement]\n\t_ [translateCStatements each S]\n    by\n\t'begin\n\t\tTuringDecls\n\t\tTuringStatements \n\t'end\nend rule\n\nfunction removeBeginEndFromProc\n    replace [function_definition]\n\t'procedure N [identifier] OA [opt t_paramDecl]\n\t    'begin\n\t\tD [repeat externaldefinition]\n\t\tS [repeat statement]\n\t    'end\n\t'end N\n    by\n\t'procedure N OA\n\t    D\n\t    S\n\t'end N\nend function\n\n\n\nrule changeExpression\n    construct COps [repeat binary_operator]\n        '== '!= '&& '|| '%\n    construct TuringOps [repeat binary_operator]\n    \t'= 'not= 'and 'or 'mod\n    replace [expression]\n\tE [expression]\n    construct NewE [expression]\n\tE [changeOp each COps TuringOps]\n\t  [changeArrayBrackets]\n    deconstruct not NewE\n\tE \n    by\n\tNewE \nend rule\n\nfunction changeToStringSpec\n    replace * [type_specifier]\n\t'array 0 .. N [number] 'of 'char\n    construct NewN [number]\n\tN [+ 1]\n    construct NewTuringTypeSpec [type_specifier]\n\t'string '( NewN ')\n    by\n\tNewTuringTypeSpec\nend function\n\nfunction changeOptArrayPart OAP [opt array_part]\n    deconstruct OAP\n\t'[ N [number] ']\n    replace [argument_declaration]\n\tDI [decl_identifier] ': T [type_specifier]\n    construct NewN [number]\n\tN [- 1]\n    construct TuringArraySpec [type_specifier]\n\t'array 0 .. NewN 'of T\n    construct NewTuringArraySpec [type_specifier]\n\tTuringArraySpec [changeToStringSpec]\n    by\n\tDI ': NewTuringArraySpec\nend function\n\nfunction translateCStatements CStatement [statement]\t\t\t\n    replace [repeat statement]\n\tSoFar [repeat statement]\n    construct NewTuringStatement [statement]\n\tCStatement [changeCStatement]\n    by\n\tSoFar [. NewTuringStatement]\nend function\n\nfunction makeExternalDef D [declaration]\n    replace [repeat externaldefinition]\n\tSoFar [repeat externaldefinition]\n    construct NewExternalDef [externaldefinition]\n\tD\n    by\n\tSoFar [. NewExternalDef]\nend function\n\nfunction changeArrayBrackets\n    replace * [unary_expression]\n\tPE [primary_expression] '[ E [expression] ']\n    by\n\tPE '( E ')\nend function\n\nfunction changeOp COp [binary_operator] TuringOp [binary_operator]\n    replace * [binary_operator]\n\tCOp\n    by\n\tTuringOp\nend function\n\nfunction changeCStatement\n    replace [statement]\n\tS [statement]\n    construct NewS [statement]\n\tS [changeExprStatement]\n\t  [changeIfStatement]\n\t%% Loop statements\n\t  [changeDoWhileStatement]\n\t  [changeWhileStatement]\n\t  [changeForStatement]\n\t%% Jump statements\n\t  [changeReturnStatement]\n\t  [changeBreakStatement]\n    deconstruct not NewS\n\tS\n    by\n\tNewS\nend function\n\nfunction changeDoWhileStatement\n    replace [statement]\n\t'do\n\t    S [statement] \n\t'while '( E [expression] ') ';\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( E [changeExpression] ')\n    construct NewS [repeat statement]\n\tS \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'loop\n\t    NewBody [. exitCondition]\n\t'end 'loop\nend function\n\nfunction changeWhileStatement\n    replace [statement]\n\t'while '( E [expression] ') \n\t    S [statement]\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( E [changeExpression] ')\n    construct NewS [repeat statement]\n\tS \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'loop\n\t    exitCondition \n\t    NewBody\n\t'end 'loop\nend function\n\nfunction changeForStatement\n    replace [statement]\n\t'for '( I [expression] '; C [expression] '; S1 [expression] ') \n\t    S2 [statement]\n    construct InitStatement [statement]\n\tI\n    construct NewInitStatement [statement]\n\tInitStatement [changeCStatement]\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( C [changeExpression] ')\n    construct NewFinalStatement [repeat statement]\n\tS1\n    construct NewS [repeat statement]\n\tS2 \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets] [. NewFinalStatement]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'begin\n\t    NewInitStatement\n\t    'loop\n\t\texitCondition\n\t\tNewBody\n\t    'end 'loop\n\t'end\nend function\n\nfunction changeIfStatement\n    replace [statement]\n\t'if '( E [expression] ')\n\t    S [statement]\n\tOE [opt ELSEstatement]\n    construct NewS [repeat statement]\n\tS\n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'if E [changeExpression] 'then\n\t    NewBody\n\tOE [changeElse]\n\t'end 'if\nend function\n\nfunction changeReturnStatement\n    replace [statement]\n\t'return E [expression] ';\n    by\n\t'result E [changeExpression]\nend function\n\nfunction changeBreakStatement\n    replace [statement]\n\t'break ';\n    by\n\t'exit\nend function\n\nrule changeExprStatement\n    replace [statement]\n\tES [expression_statement] \n    construct NewES [expression_statement]\n\tES [removeSemiColon]\n\t   [removeAmpersand]\n\t   [changeAssignment]\n\t   [changeBasicPrintf]\n\t   [changeComplexPrintf]\n\t   [changeBasicScanf]\n\t   [changeStrCopy]\n\t   [changeStrCat]\n\t   [changePrePlusPlus]\n\t   [changePostPlusPlus]\n\t   [changePreMinusMinus]\n\t   [changePostMinusMinus]\n\t   [changeArrayBrackets]\t\t%% changeArrayBrackets defined in expr_t.C\n    deconstruct not NewES\n\tES\n    by\n\tNewES \nend rule\n\nfunction removeBrackets\n    replace [repeat statement]\n\t'{\n\t    RS [repeat statement]\n\t'}\n    by\n\tRS\nend function\n\nrule changeElse\n    replace [ELSEstatement]\n\t'else 'if '( E [expression] ')\n\t    S [statement]\n\tOE [opt ELSEstatement]\n    construct NewS [repeat statement]\n\tS\n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'elsif E [changeExpression] 'then\n\t    NewBody\n\tOE [changeElse]\nend rule\n\nfunction removeSemiColon\n    replace [expression_statement]\n\tE [expression] ';\n    by\n\tE [changeExpression]\nend function\n\nfunction removeAmpersand\n    replace * [cast_expression]\n\t'& CE [cast_expression]\n    by\n\tCE\nend function\n\nfunction changeAssignment\n    replace [expression_statement]\n\tCE1 [cast_expression] '= CE2 [cast_expression] RBO [repeat binary_operation]\n    by\n\tCE1 ':= CE2 RBO\nend function\n\nfunction changeBasicPrintf\n    replace [expression_statement]\n\t'printf '( SL[stringlit] ')\n    by\n\t'put SL '..\nend function\n\nfunction changeComplexPrintf\n    replace [expression_statement]\n\t'printf '( LE [list assignment_expression+] ')\n    construct repeatExpr [repeat assignment_expression]\n\t_ [. each LE]\n    deconstruct repeatExpr\n\tSL [stringlit] Rest [repeat assignment_expression]\n    construct NewArgList [list putArg]\n\t_ [translatePutArgs SL Rest]\t\t\t\n    construct putStatement [expression_statement]\n\t'put NewArgList [removeEmptyArg] '..\n    by\n\tputStatement [removeOptDotDot]\nend function\n\nfunction changeBasicScanf\n    replace [expression_statement]\n\t'scanf '( LE [list assignment_expression+] ')\n    construct repeatExpr [repeat assignment_expression]\n\t_ [. each LE]\n    deconstruct repeatExpr\n\tSL [stringlit] Rest [repeat assignment_expression]\n    construct listExpr [list assignment_expression]\n\t_ [, each Rest]\n    by\n\t'get listExpr\nend function\n\nfunction changeStrCopy\n    replace [expression_statement]\n\tES [expression_statement]\n    by\n\tES [changeCopyWithLiteral]\n\t   [changeCopyWithIdentifier]\nend function\n\nfunction changeStrCat\n    replace [expression_statement]\n\tES [expression_statement]\n    by\n\tES [changeCatWithLiteral]\n\t   [changeCatWithIdentifier]\nend function\n\nfunction changePrePlusPlus\n    replace [expression_statement]\n\t'++ ID [identifier]\n    by\n\tID ':= ID '+ 1\nend function\n\nfunction changePostPlusPlus\n    replace [expression_statement]\n\tID [identifier] '++ \n    by\n\tID ':= ID '+ 1\nend function\n\nfunction changePreMinusMinus\n    replace [expression_statement]\n\t'-- ID [identifier]\n    by\n\tID ':= ID '- 1\nend function\n\nfunction changePostMinusMinus\n    replace [expression_statement]\n\tID [identifier] '-- \n    by\n\tID ':= ID '- 1\nend function\n\nfunction translatePutArgs SL [stringlit] RAE [repeat assignment_expression]\t\t\t\n    replace [list putArg]\n\tSoFar [list putArg]\n    construct beforePercent [stringlit]\t\t% get everything before the next percent\n\tSL [before \"%\"] [replaceEmpty SL RAE]\n    construct NewSL [putArg]\n\tbeforePercent\n    where not\t\t\t\t\t% terminating condition\n\tbeforePercent [?replaceEmpty SL RAE]\n    construct afterPercent [stringlit]\t\t% get everything after the percent sign\n\tSL [after \"%\"]\n    construct restSL [stringlit]\t\t% skip the next character\n\tafterPercent [: 2 9999] \t\t% 2nd to last character\n    construct RestAE [repeat assignment_expression]\n\t_ [getRest RAE]\n    construct recurse [list putArg]\n\t_ [translatePutArgs restSL RestAE]  \n    by\n\tSoFar [, NewSL] [addAE RAE] [, recurse]\nend function\n\nfunction removeEmptyArg\n    replace * [list_1_putArg]\n\t\"\" ', Tail [list_1_putArg]\n    by\n\tTail \nend function\n\nfunction removeOptDotDot\n    replace [expression_statement]\n\t'put LPA [list putArg] '..\n    construct NewLPA [list putArg]\n\tLPA [removeNewline]\n    %%deconstruct not NewLPA \n    \t%%LPA\n    by\n\t'put NewLPA\nend function\n\nfunction changeCopyWithLiteral\n    replace [expression_statement]\n\t'strcpy '( N [identifier] ', SL [stringlit] ')\n    by\n\tN ':= SL\nend function\n\nfunction changeCopyWithIdentifier\n    replace [expression_statement]\n\t'strcpy '( N [identifier] ', N2 [identifier] ')\n    by\n\tN ':= N2\nend function\n\nfunction changeCatWithLiteral\n    replace [expression_statement]\n\t'strcat '( N [identifier] ', SL [stringlit] ')\n    by\n\tN ':= N '+ SL\nend function\n\nfunction changeCatWithIdentifier\n    replace [expression_statement]\n\t'strcat '( N [identifier] ', N2 [identifier] ')\n    by\n\tN ':= N '+ N2\nend function\n\nfunction replaceEmpty restSL [stringlit] RAE [repeat assignment_expression]\n    replace [stringlit]\n\t\"\"\n    where not\n\tRAE [?notEmpty]\n    by\n\trestSL\nend function\n\nfunction addAE RAE [repeat assignment_expression]\n    deconstruct RAE\n\tAE [assignment_expression] RestAE [repeat assignment_expression]\n    replace [list putArg]\n\tLPA [list putArg]\n    construct NewPA [putArg]\n\tAE\n    by\n\tLPA [, NewPA]\nend function\n\nfunction getRest RAE [repeat assignment_expression]\n    replace [repeat assignment_expression]\n\tRest [repeat assignment_expression]\n    deconstruct RAE\n\tAE [assignment_expression] RestAE [repeat assignment_expression]\n    by\n\tRestAE\nend function\n\nfunction before SL [stringlit]\n    replace [stringlit]\n\tScope [stringlit]\n    construct N [number]\n\t_ [index Scope SL]\n    construct NewN [number]\n\tN [- 1]\n    by\n\tScope [changeNull N]\n\t      [changeNOTNull 1 NewN]\nend function\n\nfunction after SL [stringlit]\n    replace [stringlit]\n\tScope [stringlit]\n    construct N [number]\n\t_ [index Scope SL]\n    construct NewN [number]\n\tN [+ 1]\n    by\n\tScope [changeNull N]\n\t      [changeNOTNull NewN 9999]\nend function\n\nfunction removeNewline\n    replace * [list putArg]\n\tS [stringlit]\n    by\n\t% nothing\nend function\n\nfunction changeNull N [number]\n    replace [stringlit]\n\tSL [stringlit]\n    where\n\tN [<= 1]\n    by\n\t\"\"\nend function\n\nfunction changeNOTNull N1 [number] N2 [number]\n    replace [stringlit]\n\tSL [stringlit]\n    by\n\tSL [: N1 N2]\nend function\n\n",
        "after": " var a : array 0..4 of int\n ",
        "before": "\n "
    },
    {
        "hole_rule": "function changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function",
        "context": "function translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\n\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " Console.WriteLine (\"target is zero\");\nbreak;\n ",
        "before": "\nSystem.out.println (\"target is zero\");\nbreak;\n "
    },
    {
        "hole_rule": "function translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function",
        "context": "function translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\n\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " while (a < 10) {\n    if (a == 5) break cleanup;\n\n}\ncleanup :\nConsole.WriteLine (a);\n ",
        "before": "\nwhile (a < 10) {\n    if (a == 5) break cleanup;\n\n}\ncleanup :\nSystem.out.println (a);\n "
    },
    {
        "hole_rule": "function toRight Pivot [id] N [id]\n    where not \n        N [< Pivot]\n    replace [id *] \n        List [id *]\n    by \n        N List\nend function",
        "context": "function toLeft Pivot [id] N [id]\n    where \n        N [< Pivot]\n    replace [id *] \n        List [id *]\n    by \n        N List\nend function\n\n\n\n",
        "after": " a but am be again depending a could a algorithms between difference a begin but am be again depending a could ",
        "before": "\na am be again depending a could a algorithms between difference a begin but am be again depending a could "
    },
    {
        "hole_rule": "function changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function",
        "context": "function translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\n\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " Console.WriteLine (\"In static constructor\");\n ",
        "before": "\nSystem.out.println (\"In static constructor\");\n "
    },
    {
        "hole_rule": "function changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function",
        "context": "function checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\n\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\n",
        "after": " int count = 0;\nint total = 0;\nint len;\nwhile (true) {\n    len = getLength ();\n    if (len == 0) break;\n\n    count ++;\n    total += len;\n}\nreturn total / count;\n// Can throw ArithmeticException\n\n ",
        "before": "\nint count = 0;\nint total = 0;\nint len;\nwhile (true) {\n    len = getLength ();\n    if (len == 0) break;\n\n    count ++;\n    total += len;\n}\nreturn total / count;\n// Can throw ArithmeticException\n\n "
    },
    {
        "hole_rule": "function changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function",
        "context": "function translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\n\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " case 1 :\n    Console.WriteLine (\"One\");\n    break;\ncase 2 :\n    Console.WriteLine (\"Two\");\n    break;\ndefault :\n    Console.WriteLine (\"?\");\n    break;\n ",
        "before": "\ncase 1 :\n    System.out.println (\"One\");\n    break;\ncase 2 :\n    System.out.println (\"Two\");\n    break;\ndefault :\n    System.out.println (\"?\");\n    break;\n "
    },
    {
        "hole_rule": "function setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function",
        "context": "function addBraces %\nreplace [program] \n\tNewImportDeclaration[repeat import_declaration]\n\tPHeader[package_header]\t    \n\tTypeDeclr[repeat type_declaration]\n\t%construct Length[number]\n\t%\t _[length NewImportDeclaration]\n\t%where Length[> 0]\n\tby\n\tNewImportDeclaration\n\tPHeader\t    \n\t'{\n\t    TypeDeclr\n\t'}\nend function\n\nfunction changeImportToUsing importDec[import_declaration]\n\tdeconstruct importDec\n\t    'import Name[package_or_type_name] DotStar[opt dot_star] '; \n\treplace *[repeat import_declaration]\n\tby\n\t    'using Name ';%remove DotStar\n\t    %decide how to change for proper C# equivelant API\nend function\n\nfunction changePackageToNamespace\n\treplace [opt package_header]\n\t    'package Name[package_name] '; \n\tby\n\t    'namespace Name \nend function\n\nfunction changeClassHeader\n% Java: [repeat modifier] 'class [class_name] [opt extends_clause] [opt implements_clause]\n% C#:   class-modifiersopt   class   identifier   class-base opt   class-body   ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\t\t%to set a constructor if needed\n\t\texport ClassName[class_name]\n\t\t\tName\t\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeInterfaceHeader\n% Java: [repeat modifier] 'interface [interface_name] [opt extends_clause] [opt implements_clause]\n% C#:   attributesopt interface-modifiersopt interface identifier interface-baseopt interface-body ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nfunction translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\n\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " using System;\nnamespace examples\n    {\n        class MyMainClass {\n\n            public static void Main (String [] args) {\n                WhileContinue ();\n                WhileBreak ();\n                WhileGoto ();\n            }\n\n            static void WhileContinue () {\n                int a = 0;\n                while (a < 10) {\n                    a ++;\n                    if (a == 5) {\n                        a ++;\n                        continue;\n                    }\n                }\n            }\n\n            static void WhileBreak () {\n                int a = 0;\n                while (a < 10) {\n                    a ++;\n                    if (a == 5) break;\n\n                }\n                a ++;\n            }\n\n            static void WhileGoto () {\n                int a = 0;\n                while (a < 10) {\n                    if (a == 5) break cleanup;\n\n                }\n                cleanup :\n                Console.WriteLine (a);\n            }\n\n        }\n\n    }\n ",
        "before": "\npackage examples;\n\nclass MyMainClass {\n\n    public static void main (String [] args) {\n        WhileContinue ();\n        WhileBreak ();\n        WhileGoto ();\n    }\n\n    static void WhileContinue () {\n        int a = 0;\n        while (a < 10) {\n            a ++;\n            if (a == 5) {\n                a ++;\n                continue;\n            }\n        }\n    }\n\n    static void WhileBreak () {\n        int a = 0;\n        while (a < 10) {\n            a ++;\n            if (a == 5) break;\n\n        }\n        a ++;\n    }\n\n    static void WhileGoto () {\n        int a = 0;\n        while (a < 10) {\n            if (a == 5) break cleanup;\n\n        }\n        cleanup :\n        System.out.println (a);\n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function",
        "context": "function addBraces %\nreplace [program] \n\tNewImportDeclaration[repeat import_declaration]\n\tPHeader[package_header]\t    \n\tTypeDeclr[repeat type_declaration]\n\t%construct Length[number]\n\t%\t _[length NewImportDeclaration]\n\t%where Length[> 0]\n\tby\n\tNewImportDeclaration\n\tPHeader\t    \n\t'{\n\t    TypeDeclr\n\t'}\nend function\n\nfunction changeImportToUsing importDec[import_declaration]\n\tdeconstruct importDec\n\t    'import Name[package_or_type_name] DotStar[opt dot_star] '; \n\treplace *[repeat import_declaration]\n\tby\n\t    'using Name ';%remove DotStar\n\t    %decide how to change for proper C# equivelant API\nend function\n\nfunction changePackageToNamespace\n\treplace [opt package_header]\n\t    'package Name[package_name] '; \n\tby\n\t    'namespace Name \nend function\n\nfunction changeClassHeader\n% Java: [repeat modifier] 'class [class_name] [opt extends_clause] [opt implements_clause]\n% C#:   class-modifiersopt   class   identifier   class-base opt   class-body   ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\t\t%to set a constructor if needed\n\t\texport ClassName[class_name]\n\t\t\tName\t\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeInterfaceHeader\n% Java: [repeat modifier] 'interface [interface_name] [opt extends_clause] [opt implements_clause]\n% C#:   attributesopt interface-modifiersopt interface identifier interface-baseopt interface-body ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nfunction translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\n\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " using System;\nnamespace examples\n    {\n        class FlowControl {\n\n            static void Main (string [] args) {\n                int a = 0;\n                //while\n                \n                while (a > 10) {\n                    a ++;\n                    Console.WriteLine (a);\n                }\n                //Do while\n                \n                a = 0;\n                do {\n                    a ++;\n                    Console.WriteLine (a);\n                } while (a < 10);\n                //if\n                \n                a = 5;\n                int b = 5, c = 10;\n                if (a == b) Console.WriteLine (a);\n\n                if ((a > c) || (a == b)) Console.WriteLine (b);\n\n                if ((a >= c) && (b <= c)) Console.WriteLine (c);\n\n                //for\n                \n                for (sbyte v = 0;\n                a >> 10; a ++) {\n                    Console.WriteLine (a);\n                }\n                //switch\n                \n                a = 2;\n                switch (a) {\n                    case 1 :\n                        Console.WriteLine (\"One\");\n                        break;\n                    case 2 :\n                        Console.WriteLine (\"Two\");\n                        break;\n                    default :\n                        Console.WriteLine (\"?\");\n                        break;\n                }\n            }\n\n        }\n\n    }\n ",
        "before": "\npackage examples;\n\nclass FlowControl {\n\n    static void Main (string [] args) {\n        int a = 0;\n        //while\n        \n        while (a > 10) {\n            a ++;\n            System.out.println (a);\n        }\n        //Do while\n        \n        a = 0;\n        do {\n            a ++;\n            System.out.println (a);\n        } while (a < 10);\n        //if\n        \n        a = 5;\n        int b = 5, c = 10;\n        if (a == b) System.out.println (a);\n\n        if ((a > c) || (a == b)) System.out.println (b);\n\n        if ((a >= c) && (b <= c)) System.out.println (c);\n\n        //for\n        \n        for (byte v = 0;\n        a >>> 10; a ++) {\n            System.out.println (a);\n        }\n        //switch\n        \n        a = 2;\n        switch (a) {\n            case 1 :\n                System.out.println (\"One\");\n                break;\n            case 2 :\n                System.out.println (\"Two\");\n                break;\n            default :\n                System.out.println (\"?\");\n        }\n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function",
        "context": "function translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\n\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " public static void Main (String [] args) {\n    Console.WriteLine (\"Beginning main()\");\n    StaticInitTest.doStuff ();\n    StaticInitTest sti = new StaticInitTest ();\n    Console.WriteLine (\"Completed main()\");\n}\n\n ",
        "before": "\npublic static void main (String [] args) {\n    System.out.println (\"Beginning main()\");\n    StaticInitTest.doStuff ();\n    StaticInitTest sti = new StaticInitTest ();\n    System.out.println (\"Completed main()\");\n}\n\n "
    },
    {
        "hole_rule": "function changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function",
        "context": "function addBraces %\nreplace [program] \n\tNewImportDeclaration[repeat import_declaration]\n\tPHeader[package_header]\t    \n\tTypeDeclr[repeat type_declaration]\n\t%construct Length[number]\n\t%\t _[length NewImportDeclaration]\n\t%where Length[> 0]\n\tby\n\tNewImportDeclaration\n\tPHeader\t    \n\t'{\n\t    TypeDeclr\n\t'}\nend function\n\nfunction changeImportToUsing importDec[import_declaration]\n\tdeconstruct importDec\n\t    'import Name[package_or_type_name] DotStar[opt dot_star] '; \n\treplace *[repeat import_declaration]\n\tby\n\t    'using Name ';%remove DotStar\n\t    %decide how to change for proper C# equivelant API\nend function\n\nfunction changePackageToNamespace\n\treplace [opt package_header]\n\t    'package Name[package_name] '; \n\tby\n\t    'namespace Name \nend function\n\nfunction changeClassHeader\n% Java: [repeat modifier] 'class [class_name] [opt extends_clause] [opt implements_clause]\n% C#:   class-modifiersopt   class   identifier   class-base opt   class-body   ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\t\t%to set a constructor if needed\n\t\texport ClassName[class_name]\n\t\t\tName\t\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeInterfaceHeader\n% Java: [repeat modifier] 'interface [interface_name] [opt extends_clause] [opt implements_clause]\n% C#:   attributesopt interface-modifiersopt interface identifier interface-baseopt interface-body ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nfunction translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\n\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " using System;\nusing java.util;\n\n        class BlockVars {\n            int [] b;\n\n            public static void Main (String [] args) {\n                bool flag = true;\n                const int y = 6;\n                double X = Math.random ();\n                int DAYS_IN_YEAR;\n                if (flag) DAYS_IN_YEAR = 366;\n                else DAYS_IN_YEAR = 365;\n\n            }\n\n        }\n\n ",
        "before": "\nimport java.util.*;\n\nclass BlockVars {\n    int b [];\n\n    public static void main (String [] args) {\n        boolean flag = true;\n        final int y = 6;\n        final double X = Math.random ();\n        final int DAYS_IN_YEAR;\n        if (flag) DAYS_IN_YEAR = 366;\n        else DAYS_IN_YEAR = 365;\n\n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function isPublic\n\tmatch [modifier]\n\t\t'public\nend function",
        "context": "function translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\n\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n",
        "after": " public static void Main (String [] args) {\n    Balance [] current = new Balance [3];\n    current [0] = new Balance (\"K. J. Fielding\", 123.23);\n    current [1] = new Balance (\"Will Tell\", 157.02);\n    current [2] = new Balance (\"Tom Jackson\", - 12.33);\n    for (int i = 0;\n    i < 3; i ++) current [i].show ();\n\n}\n\n ",
        "before": "\npublic static void main (String args []) {\n    Balance current [] = new Balance [3];\n    current [0] = new Balance (\"K. J. Fielding\", 123.23);\n    current [1] = new Balance (\"Will Tell\", 157.02);\n    current [2] = new Balance (\"Tom Jackson\", - 12.33);\n    for (int i = 0;\n    i < 3; i ++) current [i].show ();\n\n}\n\n "
    },
    {
        "hole_rule": "function is_class_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_nonstatic_var Id]\nend function",
        "context": "rule convertUnaryOpFirstLocal\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nrule convertUnaryOpFirstMy\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    where \n\tRef [is_class_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'my 'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nrule convertUnaryOpFirstClass\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    where \n\tRef [is_staticclass_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'[ 'my 'class '] 'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nfunction makeDecrCmdTail Op [pre_inc_dec]\n    deconstruct Op\n\t'--\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    construct Num [tcl_literal]\n\t-1\n    by\n\tNum\nend function\n\n\n\nfunction is_staticclass_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_static_var Id]\nend function\n\nfunction is_nonstatic_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where\n\tField [has_var Id] \n    where not\n\tField [is_static]\nend function\n\nfunction is_static_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where all\n\tField [has_var Id] [is_static]\nend function\n\nfunction has_var Id [id]\n    match * [variable_name]\n\tVarId [id] _ [opt generic_parameter] _ [repeat dimension]\n    where \n\tVarId [= Id]\nend function\n\nfunction is_static \n    match * [modifier]\n\t'static\nend function\n\n",
        "after": " incr result\n ",
        "before": "\nresult ++;\n "
    },
    {
        "hole_rule": "function isTransient\n\tmatch [modifier]\n\t\t'transient\nend function",
        "context": "function changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\n\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " virtual public void swap (int a [], int b [], bool f []) {\n}\n\n ",
        "before": "\npublic void swap (int a [], int b [], boolean f []) {\n}\n\n "
    },
    {
        "hole_rule": "function changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function",
        "context": "function translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\n\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " internal Methods (sbyte [] a) {\n}\n\n ",
        "before": "\nMethods (byte a []) {\n}\n\n "
    },
    {
        "hole_rule": "rule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule",
        "context": "function translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\n\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " virtual public int getLength () {\n    String s;\n    try {\n        s = readUpTo (':');\n    } catch (IOException e) {\n        return 0;\n    }\n    return s.length ();\n}\n\n ",
        "before": "\nint getLength () {\n    String s;\n    try {\n        s = readUpTo (':');\n    } catch (IOException e) {\n        return 0;\n    }\n    return s.length ();\n}\n\n "
    },
    {
        "hole_rule": "function changeBasicScanf\n    replace [expression_statement]\n\t'scanf '( LE [list assignment_expression+] ')\n    construct repeatExpr [repeat assignment_expression]\n\t_ [. each LE]\n    deconstruct repeatExpr\n\tSL [stringlit] Rest [repeat assignment_expression]\n    construct listExpr [list assignment_expression]\n\t_ [, each Rest]\n    by\n\t'get listExpr\nend function",
        "context": "function translateArg AD [argument_declaration]\n    deconstruct AD\n\tT [type_specifier] DI [decl_identifier] OAP [opt array_part] OI [opt initialisation]\n    replace [list argument_declaration]\n\tSoFar [list argument_declaration]\n    construct TuringArg [argument_declaration]\n\tDI ': T\n    construct NewTuringArg [argument_declaration]\n\tTuringArg [changeOptArrayPart OAP]\n\t\t  [changeType]\n    by\n\tSoFar [, NewTuringArg]\t\nend function\n\nfunction removeBeginEndFromFunc\n    replace [function_definition]\n\t'function N [identifier] OA [opt t_paramDecl] ': TS [type_specifier]\n\t    'begin\n\t\tD [repeat externaldefinition]\n\t\tS [repeat statement]\n\t    'end\n\t'end N\n    construct NewType [type_specifier]\n\tTS [changeType]\n    by\n\t'function N OA ': NewType\n\t    D\n\t    S\n\t'end N\nend function\n\nfunction removeEmptyArgsFromFunc\n    replace [function_definition]\n\t'function N [identifier] '( ') ': TS [type_specifier] \n\t    D [repeat externaldefinition]\n\t    S [repeat statement]\n\t'end N\n    by\n\t'function N ': TS\n\t    D\n\t    S\n\t'end N\nend function\n\nrule changeCompound\n    replace [compound_statement]\n\t'{\n\t\tD [repeat declaration] \n\t\tS [repeat statement]\n\t'} OS [opt ';]\n    construct ExtDefs [repeat externaldefinition]\n\t_ [makeExternalDef each D]\n    construct TuringDecls [repeat externaldefinition]\n\t_ [changeExternalDef each ExtDefs]\n    construct TuringStatements [repeat statement]\n\t_ [translateCStatements each S]\n    by\n\t'begin\n\t\tTuringDecls\n\t\tTuringStatements \n\t'end\nend rule\n\nfunction changeType\n    construct CTypes [repeat type_specifier]\n    \t'char 'long 'float 'double\n    construct TuringTypes [repeat type_specifier]\n    \t'string(1) 'int 'real 'real\n    replace * [type_specifier]\n        CType [type_specifier]\n    by\n\tCType [$ each CTypes TuringTypes]\nend function\n\nfunction changeOptArrayPart OAP [opt array_part]\n    deconstruct OAP\n\t'[ N [number] ']\n    replace [argument_declaration]\n\tDI [decl_identifier] ': T [type_specifier]\n    construct NewN [number]\n\tN [- 1]\n    construct TuringArraySpec [type_specifier]\n\t'array 0 .. NewN 'of T\n    construct NewTuringArraySpec [type_specifier]\n\tTuringArraySpec [changeToStringSpec]\n    by\n\tDI ': NewTuringArraySpec\nend function\n\nfunction changeExternalDef ExtDef [externaldefinition]\n    replace [repeat externaldefinition]\n\tSoFar [repeat externaldefinition]\n\t\n    construct NewExtDef [externaldefinition]\n\tExtDef [translateCConst]\n\t       [translateCType]\n\t       [translateCVar]\n\t       [translateCFunction]\n    by\n\tSoFar [. NewExtDef]\nend function\n\nfunction translateCStatements CStatement [statement]\t\t\t\n    replace [repeat statement]\n\tSoFar [repeat statement]\n    construct NewTuringStatement [statement]\n\tCStatement [changeCStatement]\n    by\n\tSoFar [. NewTuringStatement]\nend function\n\nfunction makeExternalDef D [declaration]\n    replace [repeat externaldefinition]\n\tSoFar [repeat externaldefinition]\n    construct NewExternalDef [externaldefinition]\n\tD\n    by\n\tSoFar [. NewExternalDef]\nend function\n\nfunction changeToStringSpec\n    replace * [type_specifier]\n\t'array 0 .. N [number] 'of 'char\n    construct NewN [number]\n\tN [+ 1]\n    construct NewTuringTypeSpec [type_specifier]\n\t'string '( NewN ')\n    by\n\tNewTuringTypeSpec\nend function\n\nfunction translateCConst\n    replace [externaldefinition]\n\t'const T [type_specifier] N [identifier] '= E [expression] ';\n    construct NewType [type_specifier]\n\tT [changeType]\n    by\t\n\t'const N ': NewType ':= E\nend function\n\nfunction translateCType\n    replace [externaldefinition]\n\t'typedef T [type_specifier] OP [opt pointer] N [identifier] OAP [opt array_part] ';\n    construct NewType [type_specifier]\n\tT [changeType]\n    construct NewTuringType [externaldefinition]\n\t'type N : NewType\n    by\n\tNewTuringType\nend function\n\nfunction translateCVar\n    replace [externaldefinition]\n\tT [type_specifier] D [list decl_id_part+] ';\n    construct NewTuringVar [repeat t_var]\n\t_ [translatePointerVarDecl T each D]\n\t  [translateVarDecl T each D]\n    construct NewED [externaldefinition]\n\tNewTuringVar\n    by\n\tNewED\nend function\n\nfunction translateCFunction\n    replace [externaldefinition]\n\tF [function_definition]\n    construct NewTuringFunction [externaldefinition]\n\tF [translateProcedure]\t\t%% must be done before functions\n\t  [translateFunction]\n    by\n\tNewTuringFunction\nend function\n\nfunction changeCStatement\n    replace [statement]\n\tS [statement]\n    construct NewS [statement]\n\tS [changeExprStatement]\n\t  [changeIfStatement]\n\t%% Loop statements\n\t  [changeDoWhileStatement]\n\t  [changeWhileStatement]\n\t  [changeForStatement]\n\t%% Jump statements\n\t  [changeReturnStatement]\n\t  [changeBreakStatement]\n    deconstruct not NewS\n\tS\n    by\n\tNewS\nend function\n\nfunction translateVarDecl T [type_specifier] D [decl_id_part]\n    deconstruct D\n\tDI [decl_identifier] OAP [opt array_part] OI [opt initialisation]\n    replace [repeat t_var]\n\tSoFar [repeat t_var]\n    construct TuringVar [t_var]\n\t'var DI ': T\n    construct NewTuringVar [t_var]\n\tTuringVar [addOptArrayPart OAP]\n\t\t  [addOptInit OI]\n\t\t  [changeType]\n    by\n\tSoFar [. NewTuringVar]\t\nend function\n\nfunction translatePointerVarDecl T [type_specifier] D [decl_id_part]\n    deconstruct D\n\t'* DI [decl_identifier] OAP [opt array_part] OI [opt initialisation]\n    deconstruct T\n\t'char\n    replace [repeat t_var]\n\tSoFar [repeat t_var]\n    construct TuringVar [t_var]\n\t'var DI ': 'string\n    construct NewTuringVar [t_var]\n\tTuringVar [addOptArrayPart OAP]\n\t\t  [addOptInit OI]\n    by\n\tSoFar [. NewTuringVar]\t\nend function\n\nfunction translateProcedure\n    replace [function_definition]\n\t'void N [identifier] '( AD [list argument_declaration] ')\n\tCS [compound_statement]\n    construct TuringArgs [list argument_declaration]\n\t_ [translateArg each AD]\n    construct ArgPart [t_paramDecl]\n\t'( TuringArgs ')\n    construct NewProc [function_definition]\n\t'procedure N ArgPart\n\t    CS [changeCompound]\n\t'end N\n    by\n    NewProc [removeBeginEndFromProc] \n    \t    [removeEmptyArgsFromProc]\nend function\n\nfunction changeDoWhileStatement\n    replace [statement]\n\t'do\n\t    S [statement] \n\t'while '( E [expression] ') ';\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( E [changeExpression] ')\n    construct NewS [repeat statement]\n\tS \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'loop\n\t    NewBody [. exitCondition]\n\t'end 'loop\nend function\n\nfunction changeWhileStatement\n    replace [statement]\n\t'while '( E [expression] ') \n\t    S [statement]\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( E [changeExpression] ')\n    construct NewS [repeat statement]\n\tS \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'loop\n\t    exitCondition \n\t    NewBody\n\t'end 'loop\nend function\n\nfunction changeForStatement\n    replace [statement]\n\t'for '( I [expression] '; C [expression] '; S1 [expression] ') \n\t    S2 [statement]\n    construct InitStatement [statement]\n\tI\n    construct NewInitStatement [statement]\n\tInitStatement [changeCStatement]\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( C [changeExpression] ')\n    construct NewFinalStatement [repeat statement]\n\tS1\n    construct NewS [repeat statement]\n\tS2 \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets] [. NewFinalStatement]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'begin\n\t    NewInitStatement\n\t    'loop\n\t\texitCondition\n\t\tNewBody\n\t    'end 'loop\n\t'end\nend function\n\nfunction changeIfStatement\n    replace [statement]\n\t'if '( E [expression] ')\n\t    S [statement]\n\tOE [opt ELSEstatement]\n    construct NewS [repeat statement]\n\tS\n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'if E [changeExpression] 'then\n\t    NewBody\n\tOE [changeElse]\n\t'end 'if\nend function\n\nfunction changeReturnStatement\n    replace [statement]\n\t'return E [expression] ';\n    by\n\t'result E [changeExpression]\nend function\n\nfunction changeBreakStatement\n    replace [statement]\n\t'break ';\n    by\n\t'exit\nend function\n\nrule changeExprStatement\n    replace [statement]\n\tES [expression_statement] \n    construct NewES [expression_statement]\n\tES [removeSemiColon]\n\t   [removeAmpersand]\n\t   [changeAssignment]\n\t   [changeBasicPrintf]\n\t   [changeComplexPrintf]\n\t   [changeBasicScanf]\n\t   [changeStrCopy]\n\t   [changeStrCat]\n\t   [changePrePlusPlus]\n\t   [changePostPlusPlus]\n\t   [changePreMinusMinus]\n\t   [changePostMinusMinus]\n\t   [changeArrayBrackets]\t\t%% changeArrayBrackets defined in expr_t.C\n    deconstruct not NewES\n\tES\n    by\n\tNewES \nend rule\n\nfunction addOptInit OI [opt initialisation]\n    deconstruct OI\n\t'= E [expression]\n    replace [t_var]\n\t'var DI [decl_identifier] ': T [type_specifier]\n    by\n\t'var DI ': T ':= E [changeExpression]\nend function\n\nfunction addOptArrayPart OAP[opt array_part]\n    deconstruct OAP\n\t'[ N [number] ']\n    replace [t_var]\n\t'var DI [decl_identifier] ': T [type_specifier]\n    construct NewN [number]\n\tN [- 1]\n    construct TuringArraySpec [type_specifier]\n\t'array 0 .. NewN 'of T\n    construct NewTuringArraySpec [type_specifier]\n\tTuringArraySpec [changeToStringSpec]\n    by\n\t'var DI ': NewTuringArraySpec\nend function\n\nfunction removeBeginEndFromProc\n    replace [function_definition]\n\t'procedure N [identifier] OA [opt t_paramDecl]\n\t    'begin\n\t\tD [repeat externaldefinition]\n\t\tS [repeat statement]\n\t    'end\n\t'end N\n    by\n\t'procedure N OA\n\t    D\n\t    S\n\t'end N\nend function\n\nfunction removeEmptyArgsFromProc\n    replace [function_definition]\n\t'procedure N [identifier] '( ')\n\t    D [repeat externaldefinition]\n\t    S [repeat statement]\n\t'end N\n    by\n\t'procedure N\n\t    D\n\t    S\n\t'end N\nend function\n\nfunction removeBrackets\n    replace [repeat statement]\n\t'{\n\t    RS [repeat statement]\n\t'}\n    by\n\tRS\nend function\n\nrule changeExpression\n    construct COps [repeat binary_operator]\n        '== '!= '&& '|| '%\n    construct TuringOps [repeat binary_operator]\n    \t'= 'not= 'and 'or 'mod\n    replace [expression]\n\tE [expression]\n    construct NewE [expression]\n\tE [changeOp each COps TuringOps]\n\t  [changeArrayBrackets]\n    deconstruct not NewE\n\tE \n    by\n\tNewE \nend rule\n\nrule changeElse\n    replace [ELSEstatement]\n\t'else 'if '( E [expression] ')\n\t    S [statement]\n\tOE [opt ELSEstatement]\n    construct NewS [repeat statement]\n\tS\n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'elsif E [changeExpression] 'then\n\t    NewBody\n\tOE [changeElse]\nend rule\n\nfunction removeSemiColon\n    replace [expression_statement]\n\tE [expression] ';\n    by\n\tE [changeExpression]\nend function\n\nfunction removeAmpersand\n    replace * [cast_expression]\n\t'& CE [cast_expression]\n    by\n\tCE\nend function\n\nfunction changeAssignment\n    replace [expression_statement]\n\tCE1 [cast_expression] '= CE2 [cast_expression] RBO [repeat binary_operation]\n    by\n\tCE1 ':= CE2 RBO\nend function\n\nfunction changeBasicPrintf\n    replace [expression_statement]\n\t'printf '( SL[stringlit] ')\n    by\n\t'put SL '..\nend function\n\nfunction changeComplexPrintf\n    replace [expression_statement]\n\t'printf '( LE [list assignment_expression+] ')\n    construct repeatExpr [repeat assignment_expression]\n\t_ [. each LE]\n    deconstruct repeatExpr\n\tSL [stringlit] Rest [repeat assignment_expression]\n    construct NewArgList [list putArg]\n\t_ [translatePutArgs SL Rest]\t\t\t\n    construct putStatement [expression_statement]\n\t'put NewArgList [removeEmptyArg] '..\n    by\n\tputStatement [removeOptDotDot]\nend function\n\n\n\nfunction changeStrCopy\n    replace [expression_statement]\n\tES [expression_statement]\n    by\n\tES [changeCopyWithLiteral]\n\t   [changeCopyWithIdentifier]\nend function\n\nfunction changeStrCat\n    replace [expression_statement]\n\tES [expression_statement]\n    by\n\tES [changeCatWithLiteral]\n\t   [changeCatWithIdentifier]\nend function\n\nfunction changePrePlusPlus\n    replace [expression_statement]\n\t'++ ID [identifier]\n    by\n\tID ':= ID '+ 1\nend function\n\nfunction changePostPlusPlus\n    replace [expression_statement]\n\tID [identifier] '++ \n    by\n\tID ':= ID '+ 1\nend function\n\nfunction changePreMinusMinus\n    replace [expression_statement]\n\t'-- ID [identifier]\n    by\n\tID ':= ID '- 1\nend function\n\nfunction changePostMinusMinus\n    replace [expression_statement]\n\tID [identifier] '-- \n    by\n\tID ':= ID '- 1\nend function\n\nfunction changeArrayBrackets\n    replace * [unary_expression]\n\tPE [primary_expression] '[ E [expression] ']\n    by\n\tPE '( E ')\nend function\n\nfunction changeOp COp [binary_operator] TuringOp [binary_operator]\n    replace * [binary_operator]\n\tCOp\n    by\n\tTuringOp\nend function\n\nfunction translatePutArgs SL [stringlit] RAE [repeat assignment_expression]\t\t\t\n    replace [list putArg]\n\tSoFar [list putArg]\n    construct beforePercent [stringlit]\t\t% get everything before the next percent\n\tSL [before \"%\"] [replaceEmpty SL RAE]\n    construct NewSL [putArg]\n\tbeforePercent\n    where not\t\t\t\t\t% terminating condition\n\tbeforePercent [?replaceEmpty SL RAE]\n    construct afterPercent [stringlit]\t\t% get everything after the percent sign\n\tSL [after \"%\"]\n    construct restSL [stringlit]\t\t% skip the next character\n\tafterPercent [: 2 9999] \t\t% 2nd to last character\n    construct RestAE [repeat assignment_expression]\n\t_ [getRest RAE]\n    construct recurse [list putArg]\n\t_ [translatePutArgs restSL RestAE]  \n    by\n\tSoFar [, NewSL] [addAE RAE] [, recurse]\nend function\n\nfunction removeEmptyArg\n    replace * [list_1_putArg]\n\t\"\" ', Tail [list_1_putArg]\n    by\n\tTail \nend function\n\nfunction removeOptDotDot\n    replace [expression_statement]\n\t'put LPA [list putArg] '..\n    construct NewLPA [list putArg]\n\tLPA [removeNewline]\n    %%deconstruct not NewLPA \n    \t%%LPA\n    by\n\t'put NewLPA\nend function\n\nfunction changeCopyWithLiteral\n    replace [expression_statement]\n\t'strcpy '( N [identifier] ', SL [stringlit] ')\n    by\n\tN ':= SL\nend function\n\nfunction changeCopyWithIdentifier\n    replace [expression_statement]\n\t'strcpy '( N [identifier] ', N2 [identifier] ')\n    by\n\tN ':= N2\nend function\n\nfunction changeCatWithLiteral\n    replace [expression_statement]\n\t'strcat '( N [identifier] ', SL [stringlit] ')\n    by\n\tN ':= N '+ SL\nend function\n\nfunction changeCatWithIdentifier\n    replace [expression_statement]\n\t'strcat '( N [identifier] ', N2 [identifier] ')\n    by\n\tN ':= N '+ N2\nend function\n\nfunction replaceEmpty restSL [stringlit] RAE [repeat assignment_expression]\n    replace [stringlit]\n\t\"\"\n    where not\n\tRAE [?notEmpty]\n    by\n\trestSL\nend function\n\nfunction addAE RAE [repeat assignment_expression]\n    deconstruct RAE\n\tAE [assignment_expression] RestAE [repeat assignment_expression]\n    replace [list putArg]\n\tLPA [list putArg]\n    construct NewPA [putArg]\n\tAE\n    by\n\tLPA [, NewPA]\nend function\n\nfunction getRest RAE [repeat assignment_expression]\n    replace [repeat assignment_expression]\n\tRest [repeat assignment_expression]\n    deconstruct RAE\n\tAE [assignment_expression] RestAE [repeat assignment_expression]\n    by\n\tRestAE\nend function\n\nfunction before SL [stringlit]\n    replace [stringlit]\n\tScope [stringlit]\n    construct N [number]\n\t_ [index Scope SL]\n    construct NewN [number]\n\tN [- 1]\n    by\n\tScope [changeNull N]\n\t      [changeNOTNull 1 NewN]\nend function\n\nfunction after SL [stringlit]\n    replace [stringlit]\n\tScope [stringlit]\n    construct N [number]\n\t_ [index Scope SL]\n    construct NewN [number]\n\tN [+ 1]\n    by\n\tScope [changeNull N]\n\t      [changeNOTNull NewN 9999]\nend function\n\nfunction removeNewline\n    replace * [list putArg]\n\tS [stringlit]\n    by\n\t% nothing\nend function\n\nfunction changeNull N [number]\n    replace [stringlit]\n\tSL [stringlit]\n    where\n\tN [<= 1]\n    by\n\t\"\"\nend function\n\nfunction changeNOTNull N1 [number] N2 [number]\n    replace [stringlit]\n\tSL [stringlit]\n    by\n\tSL [: N1 N2]\nend function\n\n",
        "after": " function main : int\n    var x : int\n    var y : int\n    var z : int\n\n    x := 10\n    y := 5\n    loop\n        z := x + y\n        if z > 10 then\n            x := x - 1\n        end if\n        put z \n        y := y - 1\n        exit when not (y not= 0)\n    end loop\n    begin\n        x := 1\n        loop\n            exit when not (x < 10)\n            z := z + y\n            x := x + 1\n        end loop\n    end\nend main\n ",
        "before": "\nint main () {\n    int x, y, z;\n    x = 10;\n    y = 5;\n    do {\n        z = x + y;\n        if (z > 10) x = x - 1;\n        printf (\"%i\\n\", z);\n        y = y - 1;\n    }\n    while (y != 0);\n    for (x = 1; x < 10; x ++)\n    {\n        z = z + y;\n    }\n}\n "
    },
    {
        "hole_rule": "function complexRefAssignment Ref [reference]\n    deconstruct Ref\n\tId [id] Dim [repeat dimension] Comps [repeat component+] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    construct ExprLen [number]\n\t_ [length Expr]\n    where not\n\tExprLen [> 0]\n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    construct NewRef [reference]\n\tId Dim NewComps\n    by\n\tNewRef 'set VarId \nend function",
        "context": "function java2xotcl\n    replace [program]\n\tP [program]\n    by\n\tP [preparationTransformations]\n\t  [transformImpEx] \n\t  [classTransforms]\n\t  [finalTransformations]\nend function\n\nfunction preparationTransformations\n    replace [program]\n\tP [program]\n    by\n\tP [exportClass]\n\t  [removeCastExpressions]\n\t  [expandJavaSwitch]\n\t  [javaPreUnary2PostUnary]\n\t  [convertJavaSelfAssignments]\n\t  \n\t  [transformVariables]\n\n\t  [localVarDecl2Assignment]\n\n\t  [removeArrayCreation]\n\n\t  [transformLiterals]\nend function\n\nfunction finalTransformations\n    replace [program]\n\tP [program]\n    by\n\tP [systemOutPrintln2Puts]\n   \t  [systemOutPrint2Puts]\nend function\n\nfunction transformImpEx\n    replace [program]\n\tP [program]\n    by\t\n\tP [addXOTclImport] [addXOTclImportIfNoPH] [removeImports]\nend function\n\nfunction classTransforms\n    replace [program]\n\tP [program]\n    by\n\tP [constructorTransforms]\n\t  [addClassMetaAndClass]\n\n\t  [teleportClassStaticAttributes]\n\t  [teleportClassStaticMethods]\n\n\t  [transformMethodsHeaders]\n\n\t  [transformDefaultAttributes]\n\t  [transformInitAttributesNew]\n\n\t  [transformExpressions]\n\n\t  [transformParameterVarRefs]\n\n\t  [transformDotRefs] \n\n\t  [untransformForUpdate]\n\n\t  [varRef2TclRef]\nend function\n\nfunction transformVariables\n    replace [program]\n\tP [program]\n    by\n\tP [splitVarDeclarations] [sortAllVarsUp]\n\t  [splitLocalVarDeclarations]\n\t  [removeEmptyLocalVarDeclarations]\nend function\n\nfunction exportClass\n    replace * [class_declaration]\n\tCD [class_declaration]\n    export JClassOrigin [class_declaration]\n\tCD\n    by\n\tCD\nend function\n\nrule transformLiterals\n    replace $ [literal]\n\tL [literal]\n    by\n\tL [transformBooleanTrue] [transformBooleanFalse]\nend rule\n\nrule removeCastExpressions\n    replace [unary_expression]\n\t'( _ [type_specifier] ') Unary [unary_expression]\n    by\n\tUnary\nend rule\n\nrule expandJavaSwitch\n    replace $ [switch_block]\n\tBlock [switch_block]\n    by\n\tBlock [removeSwitchBreak]\n\t      [convertSwitchDefaultLabel] \n\t      [expandJavaSwitchAlts]\nend rule\n\nrule javaPreUnary2PostUnary\n    replace [unary_expression]\n\tOp [pre_inc_dec] Una [primary]\n    by\n\tUna Op\nend rule\n\nrule convertJavaSelfAssignments\n    replace [assignment_expression]\n\tAss [assignment_expression]\n    deconstruct Ass\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct not Op\n\t_ [forbidden_self_assignments]\n    by\n\tAss [convertJavaSelfAssPlus]\n\t    [convertJavaSelfAssMinus]\n\t    [convertJavaSelfAssDiv]\n\t    [convertJavaSelfAssMul]\n\t    [convertJavaSelfAssDivLeft]\nend rule\n\nrule localVarDecl2Assignment\n    replace $ [declaration_or_statement]\n\tDecl [declaration_or_statement] \n    deconstruct Decl\n\t_ [repeat modifier] _ [type_specifier] _ [variable_declarators] ';\n    by\n\tDecl [localVarDecl2AssignmentExp] [localVarDecl2AssignmentArray] \nend rule\n\nrule removeArrayCreation\n    replace [repeat declaration_or_statement]\n\t_ [reference] '= _ [array_creation_expression] ';\t\n\tRest [repeat declaration_or_statement]\n    by\n\tRest\nend rule\n\nrule systemOutPrintln2Puts\n    replace $ [repeat tcl_expr_more]\n\t Cmd1 [reference] 'println More [repeat tcl_expr_more]\n    deconstruct Cmd1\n\t'[ Sys [reference] 'set 'out ']\n    deconstruct Sys\n\t'System\n    by\n\t'puts More [expandPrintlnParams]\nend rule\n\nrule systemOutPrint2Puts\n    replace $ [repeat tcl_expr_more]\n\t Cmd1 [reference] 'print More [repeat tcl_expr_more]\n    deconstruct Cmd1\n\t'[ Sys [reference] 'set 'out ']\n    deconstruct Sys\n\t'System\n    by\n\t'puts '-nonewline More [expandPrintlnParams]\nend rule\n\nfunction addXOTclImport\n    replace * [package_header]\n\tAnn [repeat annotation]\n\t'package Ref [package_name] ';\n    by\n%\tAnn \n\t'package 'provide Ref\n\t'package 'require 'XOTcl\n        'namespace 'import '::xotcl::*\nend function\n\nfunction addXOTclImportIfNoPH\n    replace * [package_declaration]\n\t_ [repeat comment_NL]\n%\tPH [opt package_header]\n\tImps [repeat import_declaration] \n\tDecls [repeat type_declaration]\n    construct OHead [package_header] \n%\t'package 'provide 'SampleTransform\n\t'package 'require 'XOTcl\n        'namespace 'import '::xotcl::*\n    by\n\tOHead\n\tImps\n\tDecls\nend function\n\nfunction removeImports\n    replace * [package_declaration]\n\tCmts [repeat comment_NL] \n\tPkgHead [opt package_header]\n\tImpDecl [repeat import_declaration] \n\tTypeDecl [repeat type_declaration]\n    by\n\tCmts PkgHead TypeDecl\nend function\n\nfunction addClassMetaAndClass\n    replace * [package_declaration]\n\tCmts [repeat comment_NL] \n\tPkgHead [opt package_header]\n\tImpDecl [repeat import_declaration] \n\tTypeDecl [repeat type_declaration]\n    deconstruct TypeDecl \n\t_ [repeat modifier] 'class ClassName [id] \n\tExtends [opt extends_clause] Implements [opt implements_clause] \n\t_ [class_body]\n\t_ [repeat type_declaration]\n    construct MetaClassName [id]\n\tClassName [_ 'metapapa]\n    construct ExtendClasses [repeat reference]\n\t_ [^ Extends]\n    construct Parents [repeat reference]\n\tExtendClasses [removeNonIdRef]\n    construct TclParents [repeat tcl_id]\n\t_ [pkgRef2TclId each Parents]\n    by\n\tCmts PkgHead ImpDecl \n\t'Class 'create MetaClassName '-superclass '{ 'Class '} '-slots '{ '}\n\tMetaClassName 'create ClassName '-superclass '{ 'Class TclParents '} \n\t'-slots '{ '}\n\tTypeDecl\nend function\n\nfunction constructorTransforms\n    replace [program]\n\tP [program]\n    by\n\tP [transformThisInConstructor] [transformSuperInConstructors]\nend function\n\nfunction transformExpressions\n    replace [program]\n\tP [program]\n    by\n\tP \n\t  [transformNewExpr]\n\n\t  [transformExceptions]\n\t  [transformConditionalStatements]\n\n\t  [transformVarAssignment]\n\n\n\t  [convertUnaryOpFirst]\n\t  [convertUnaryOpInMultiplicative]\nend function\n\nrule transformDefaultAttributes\n    replace [field_declaration]\n\t_ [repeat modifier] _ [type_specifier] Name [id] _ [opt generic_parameter] \n\t'= Literal [literal] '; \n    by\n\t'Attribute Name '-default Literal \nend rule\n\nrule transformInitAttributesNew\n    replace [field_declaration]\n\t_ [repeat modifier] _ [type_specifier] Name [id] _ [opt generic_parameter] \n\t'= New [class_instance_creation_expression] ';\n    construct NewCmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    by\n\t'Attribute Name '-initcmd '{ NewCmd '}\nend rule\n\nrule teleportClassStaticAttributes\n    replace $ [repeat type_declaration]\n\t%MetaClass\n\tMetaBase [id] MetaCreate [opt 'create] MetaClassName [id] MetaSuper [opt xotcl_class_superclasses]\n\t'-slots '{ '}\n\t%Class\n\tClassBase [id] ClassCreate [opt 'create] ClassName [id] ClassSuper [opt xotcl_class_superclasses]\n\t'-slots '{ '}\n\t%Java Class\n\tJClassHeader [class_header] JBody [class_or_interface_body]\n\t_ [repeat type_declaration]\n    construct JBodyElements [repeat class_body_declaration]\n\t_ [^ JBody]\n    construct JFields [repeat field_declaration]\n\t_ [^ JBody]\n    by\n\tMetaBase MetaCreate MetaClassName MetaSuper '-slots '{ JFields [removeNonStaticField] '}\n\tClassBase ClassCreate ClassName ClassSuper '-slots '{ JFields [removeStaticField] '}\n\tJClassHeader JBody \nend rule\n\nrule teleportClassStaticMethods\n    replace $ [repeat type_declaration]\n\t%Class\n\tClassBase [xotcl_class]\n\t%Java Class\n\tJClass [class_header] JBody [class_or_interface_body]\n\t_ [repeat type_declaration]\n    construct JMethods [repeat method_or_constructor_declaration]\n\t_ [^ JBody]\n    construct InstanceMethods [repeat method_or_constructor_declaration]\n\tJMethods [transformNonStaticMethod2Proc]\n    by\n\tClassBase\n\tJMethods [transformStaticMethod2Proc] [. InstanceMethods]\nend rule\n\nrule transformMethodsHeaders\n    replace $ [xotcl_class_with_methods]\n\tClass [xotcl_class]\n\tMethods [repeat method_or_constructor_declaration]\n    deconstruct Class\n\t_ [id] _ [opt 'create] \n\tName [id] _ [opt xotcl_class_superclasses] _ [opt xotcl_class_slots] \n    by\n\tClass\n\tMethods [transformNonStaticMethodHeader Name] \n\t\t[transformStaticMethodHeader Name]\n\t\t[transformSynchroNonStaticMethodHeader Name] \n\t\t[transformSynchroStaticMethodHeader Name]\n\t\t[transformConstructorHeader]\nend rule\n\nrule transformParameterVarRefs\n    replace $ [repeat method_or_constructor_declaration]\n \tMethod [method_or_constructor_declaration]\n \tMethods [repeat method_or_constructor_declaration]\n    deconstruct Method\n\t_ [id] _ [xotcl_proc_scope] _ [id] '{ VarIds [repeat id] '} _ [tcl_cmd_set]\n    by\n\tMethod [transformJavaVar2TclVar VarIds]\n\tMethods \nend rule\n\nrule transformDotRefs\n    replace [program]\n\tP [program]\n    where \n\tP [?transformRefMethodFirst1]\n\t  [?transformRefMethodFirst1In]\n\t  \n\t  [?transformRefMethodFirst]\n\t  [?transformRefMethod]\n\t  [?transformRefIdFirst]\n\t  [?transformRefId]\n\t  [?transformRefArray]\n    by \n\tP  [transformRefMethodFirst1]\n\t   [transformRefMethodFirst1In]\n  \n\t   [transformRefMethodFirst]\n\t   [transformRefMethod]\n\n\t   [transformRefIdFirst]\n\t   [transformRefId]\n\t   [transformRefArray] \nend rule\n\nrule varRef2TclRef\n    replace $ [reference]\n\tRef [reference]\n    construct RefNew [reference]\n\tRef [varRef2TclClassVar Ref]\n\t    [varRef2TclClassStaticVar Ref]\n\t    [varRef2TclVarSimple Ref]\n\t    [varRefThis2TclThis Ref]\n    by\n\tRefNew\nend rule\n\nrule untransformForUpdate\n    replace $ [tcl_for_cmd]\n\t'for Init [tcl_cmd_set] Cond [tcl_cmd_set] Upd [tcl_cmd_set] Block [tcl_block]\n    by\n\t'for Init Cond Upd [untransformForUpdateMores] Block \nend rule\n\nrule splitVarDeclarations\n    replace [repeat class_body_declaration]\n\tModr [repeat modifier] TypSpec [type_specifier] VarDecl [variable_declarator] ', VarDeclRest [list variable_declarator+] '; \n\tRest [repeat class_body_declaration]\n    by\n\tModr TypSpec VarDecl ';\n\tModr TypSpec VarDeclRest ';\n\tRest \nend rule\n\nrule splitLocalVarDeclarations\n    replace [repeat declaration_or_statement]\n\tModr [repeat modifier] TypSpec [type_specifier] VarDecl [variable_declarator] ', VarDeclRest [list variable_declarator+] '; \n\tRest [repeat declaration_or_statement]\n    by\n\tModr TypSpec VarDecl ';\n\tModr TypSpec VarDeclRest ';\n\tRest\nend rule\n\nrule removeEmptyLocalVarDeclarations\n    replace [repeat declaration_or_statement]\n\t_ [repeat modifier] _ [type_specifier] _ [id] _ [opt generic_parameter] '; \n\tRest [repeat declaration_or_statement]\n    by\n\tRest\nend rule\n\nrule sortAllVarsUp\n    replace [repeat class_body_declaration]\n\tNonVar [class_body_declaration_wo_field]\n\tVar [field_declaration]\n\tRest [repeat class_body_declaration]\n    by\n\tVar NonVar Rest\nend rule\n\nrule transformBooleanTrue\n    replace [literal]\n\t'true\n    by\n\t1\nend rule\n\nrule transformBooleanFalse\n    replace [literal]\n\t'false\n    by\n\t0\nend rule\n\nfunction expandJavaSwitchAlts\n    replace * [repeat switch_alternative]\n\tAlts [repeat switch_alternative]\n    deconstruct * Alts\n\tLastAlt [switch_alternative]\n    construct AltsLen [number]\n\t_ [length Alts] [- 1]\n    construct FirstAlts [repeat switch_alternative]\n\tAlts [head AltsLen]\n    construct LastAltConverted [switch_alternative]\n\tLastAlt [processJavaSwitchAltEmptyEntry] [processJavaSwitchAltCommentEntry] [processJavaSwitchAltEntry] \n    by\n\tFirstAlts [expandJavaSwitchAlts] [. LastAltConverted]\nend function\n\nrule convertSwitchDefaultLabel\n    replace $ [switch_alternative]\n\t'default ': Decls [repeat declaration_or_statement]\n    by\n\t'case ''default' ': Decls\nend rule\n\nrule removeSwitchBreak\n    replace [repeat declaration_or_statement]\n\t'break '; Decls [repeat declaration_or_statement]\n    by\n\tDecls\nend rule\n\nfunction convertJavaSelfAssPlus\n    replace [assignment_expression]\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct Op\n\t'+=\n    by\n\tUna '= Una '+ '( AssExp ')\nend function\n\nfunction convertJavaSelfAssMinus\n    replace [assignment_expression]\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct Op\n\t'-=\n    by\n\tUna '= Una '- '( AssExp ')\nend function\n\nfunction convertJavaSelfAssDiv\n    replace [assignment_expression]\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct Op\n\t'/=\n    by\n\tUna '= Una '/ '( AssExp ')\nend function\n\nfunction convertJavaSelfAssMul\n    replace [assignment_expression]\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct Op\n\t'*=\n    by\n\tUna '= Una '* '( AssExp ')\nend function\n\nfunction convertJavaSelfAssDivLeft\n    replace [assignment_expression]\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct Op\n\t'%=\n    by\n\tUna '= Una '% '( AssExp ')\nend function\n\nfunction localVarDecl2AssignmentExp\n    replace [declaration_or_statement]\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t'= Exp [conditional_expression] ';\n    construct Ass [assignment_expression]\n\tId '= Exp \n    by\n\tAss ';\nend function\n\nfunction localVarDecl2AssignmentArray\n    replace [declaration_or_statement]\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t'= Exp [array_initializer] ';\n    construct Ass [assignment_expression]\n\tId '= Exp \n    by\n\tAss ';\nend function\n\nfunction expandPrintlnParams\n    replace [repeat tcl_expr_more]\n\tMores [repeat tcl_expr_more]\n    export PutsUnas [repeat unary_expression]\n\t_\n    construct Dumb [repeat tcl_expr_more]\n\tMores [collectUnaries]\n    import PutsUnas\n\n    construct Len [number]\n\t_ [length PutsUnas]\n    where \n\tLen [> 1]\n    construct Cmds [repeat tcl_expr_more]\n\t_ [addUnaryToTclExprs each PutsUnas]\n    by\n\t'[ 'concat Cmds ']\nend function\n\nfunction pkgRef2TclId Ref [reference]\n    replace [repeat tcl_id]\n\t_ [repeat tcl_id]\n    construct RefIds [repeat id]\n\t_ [^ Ref]\n    deconstruct RefIds\n\tFirstId [id] RestId [repeat id]\n    construct TclIdHead [tcl_id_head]\n\tFirstId\n    construct TclIdPart [repeat tcl_id_part]\n\t_ [addTclIdPart each RestId]\n    by\n\tTclIdHead TclIdPart\nend function\n\nrule removeNonIdRef\n    replace [repeat reference]\n\tFirst [reference] Rest [repeat reference]\n    deconstruct First\n\tPrima [primitive_type] _ [repeat dimension] _ [repeat component]\n    by\n\tRest\nend rule\n\nrule transformSuperInConstructors\n    replace $ [constructor_declaration]\n\tConstructor [constructor_declaration]\n    by\n\tConstructor [addSuperInConstructorIfAbsent Constructor]\n\t\t    [transformSuperInConstructor Constructor]\n\t\t    [removeSuperInConstructor]\nend rule\n\nrule transformThisInConstructor \n    replace $ [constructor_declaration]\n\tConstructor [constructor_declaration]\n    by\n\tConstructor [transformThisStatement Constructor]\nend rule\n\nrule transformVarAssignment\n    replace [declaration_or_statement]\n\t Ref [reference] '= Butt [assignment_expression] ';\n    construct TclCmd [repeat tcl_expr_more]\n\t_ [transformJavaLocalScopeVar Ref] \n\n\t  [transformJavaClassVar Ref] \n\t  [transformJavaClassStaticVar Ref] \n\n\t  [transformJavaThisVar Ref] \n\t  [transformJavaThisStaticVar Ref] \n\n\t  [complexRefAssignment Ref]\n\t  [assignToArrayRef Ref]\n    construct TclLit [tcl_expr_more]\n\t_ [transformArithAssExp Butt]\n\t  [transformLiteralAssExp Butt]\n\t  [transformRefAssExp Butt]\n\t  [transformNewAssExp Butt]\n    by\n\tTclCmd [. TclLit] '%\nend rule\n\nrule transformExceptions\n    replace $ [program]\n\tP [program]\n    by\n\tP [transformThrowStmt]\n\t  [transformTryCatch]\nend rule\n\nrule transformConditionalStatements\n    replace $ [program]\n\tP [program]\n    by\n\tP [transformIfElse]\n\t  [transformIf]\n%\t  [transformCondChoice]\n\t  [transformWhile]\n\t  [transformSwitch]\n\t  [transformFor]\n\t  [transformForeach]\nend rule\n\nrule convertUnaryOpInMultiplicative\n    replace $ [multiplicative_expression]\n\tMulti [multiplicative_expression]\n    deconstruct Multi\n\tRef [id] Op [pre_inc_dec]\n    by\n\tMulti [convertUnaryOpMultiMy]\n\t      [convertUnaryOpMultiClass]\n\t      [convertUnaryOpMultiLocal]\nend rule\n\nrule convertUnaryOpFirst\n    replace $ [declaration_or_statement]\n\tDecl [declaration_or_statement]\n    deconstruct Decl\n\tRef [id] Op [pre_inc_dec] ';\n    by\n\tDecl [convertUnaryOpFirstMy]\n\t     [convertUnaryOpFirstClass]\n\t     [convertUnaryOpFirstLocal]\nend rule\n\nrule transformNewExpr\n    replace $ [multiplicative_expression]\n\tNew [class_instance_creation_expression]\n    construct Cmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    deconstruct Cmd\n\t'[ Expr [tcl_expr] ']\n    by\n\t'[ Expr ']\nend rule\n\nfunction convertNewClassInstance New [class_instance_creation_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct New\n\t'new JClassName [reference] '( Args [list argument] ') _ [opt class_body]\n    construct TmpName [repeat tcl_id]\n\t_ [pkgRef2TclId JClassName]\n    deconstruct * TmpName\n\tClassName [tcl_id]\n    construct Args1 [repeat expression]\n\t_ [argumentToExpression each Args]\n    construct TclArgs [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args1]\n    by\n\t'[ ClassName ClassName TclArgs ']\nend function\n\nrule removeStaticField\n    replace [repeat field_declaration]\n\tFirst [field_declaration] Rest [repeat field_declaration]\n    where \n\tFirst [is_static]\n    by\n\tRest\nend rule\n\nrule removeNonStaticField\n    replace [repeat field_declaration]\n\tFirst [field_declaration] Rest [repeat field_declaration]\n    where not\n\tFirst [is_static]\n    by\n\tRest\nend rule\n\nrule transformStaticMethod2Proc\n    replace  [repeat method_or_constructor_declaration]\n\tMethod [method_or_constructor_declaration] \n\tMethods [repeat method_or_constructor_declaration]\n    where not\n\tMethod [is_static]\n    by\n\tMethods\nend rule\n\nrule transformNonStaticMethod2Proc\n    replace  [repeat method_or_constructor_declaration]\n\tMethod [method_or_constructor_declaration] \n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tMethod [is_static]\n    by\n\tMethods\nend rule\n\nrule transformNonStaticMethodHeader ClassName [id]\n    replace [method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n    where not\n\tJModifiers [is_synchronized]\n    where not\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    by\n\tClassName 'instproc JName '{ ParamsNames '}  Body\nend rule\n\nrule transformStaticMethodHeader ClassName [id]\n    replace [method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n    where not\n\tJModifiers [is_synchronized]\n    where\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    by\n\tClassName 'proc JName '{ ParamsNames '}  Body\nend rule\n\nrule transformSynchroNonStaticMethodHeader ClassName [id]\n    replace [repeat method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tJModifiers [is_synchronized]\n    where not\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n    construct JSynchName [id]\n\tJName [_ 'synchrobaby]\n    construct MutexName [id]\n\tClassName [_ JName] [_ 'mutex]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'thread::mutex 'lock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'set 'cought 0 '%\n\t'#call the real method implementation\n\t'if '{ '[ 'catch '{ 'my JSynchName ParamsAsVars '} 'result '] '} '{\n\t'set 'cought 1 '%\n\t'} \n\t'thread::mutex 'unlock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'#transfer exception to the upper level\n\t'if '{ '$cought '} '{ 'error '$result '} \n\t'}\n    by\n\tClassName 'instproc JName '{ ParamsNames '} ProcBody \n\tClassName 'instproc JSynchName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformSynchroStaticMethodHeader ClassName [id]\n    replace [repeat method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tJModifiers [is_synchronized]\n    where\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n    construct JSynchName [id]\n\tJName [_ 'synchrobaby]\n    construct MutexName [id]\n\tClassName [_ JName] [_ 'mutex]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'thread::mutex 'lock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'set 'cought 0 '%\n\t'#call the real method implementation\n\t'if '{ '[ 'catch '{ 'my JSynchName ParamsAsVars '} 'result '] '} '{\n\t'set 'cought 1 '%\n\t'} \n\t'thread::mutex 'unlock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'#transfer exception to the upper level\n\t'if '{ '$cought '} '{ 'error '$result '} \n\t'} \n    by\n\tClassName 'proc JName '{ ParamsNames '} ProcBody \n\tClassName 'proc JSynchName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformConstructorHeader\n    replace [repeat method_or_constructor_declaration]\n \tConstructor [constructor_declaration]\n \tMethods [repeat method_or_constructor_declaration]\n    deconstruct Constructor\n\tJModifiers [repeat modifier] \n\tJClassName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') \n\t_ [opt throws] Body [block]\n\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n\n    construct ParamsString [id]\n\t_ [buildParameterTypeList each Parameters]\n    construct XNew [id]\n\t_ [+ JClassName] \n    construct XNewBody [id]\n\t_ [+ JClassName] [+ \"_body\"]\n    construct XNewName [id]\n\tXNew [+ ParamsString]\n    construct XNewBodyName [id]\n\tXNewBody [+ ParamsString]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'#create new object\n\t'set 'obj '[ JClassName 'new '] '%\n\t'#call the constructor\n\t'$obj XNewBodyName ParamsAsVars '%\n\t'#return new object after constructor's work is done\n\t'return '$obj '%\n\t'} \n    by\n\tJClassName 'proc XNewName '{ ParamsNames '} ProcBody\n\tJClassName 'instproc XNewBodyName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformJavaVar2TclVar VarIds [repeat id]\n    replace $ [reference]\n\tId [id] _ [repeat dimension] Comp [repeat component]\n    construct Len [number]\n\t_ [length Comp]\n    where \n\tLen [= 0]\n    where\n\tId [= each VarIds]\n    by\n\t'$ Id\nend rule\n\nrule transformRefMethodFirst1\n    replace [declaration_or_statement]\n\tId [id] _ [repeat dimension] Comps [repeat component] ';\n    construct CompsLen [number]\n\t_ [length Comps]\n    where \n\tCompsLen [= 1]\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'my Id Exps '%\nend rule\n\nrule transformRefMethodFirst1In\n    replace [reference]\n\tId [id] _ [repeat dimension] Comps [repeat component] \n    construct CompsLen [number]\n\t_ [length Comps]\n    where \n\tCompsLen [= 1]\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'[ 'my Id Exps '] \nend rule\n\nrule transformRefMethodFirst\n    replace [declaration_or_statement]\n\tId [id] Dims [repeat dimension] Comps [repeat component] ';\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct CompsLenFinal [number]\n\t_ [length Comps] [- 2]\n    construct NewCompsTmp [repeat component]\n\tComps [head CompsLen]\n    construct NewComps [repeat component]\n\tComps [head CompsLenFinal]\n    construct RefIds [repeat id]\n\t_ [^ NewCompsTmp]\n    deconstruct * RefIds\n\tMethodName [id]\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\tId [this2my] Dims NewComps MethodName Exps '%\nend rule\n\nrule transformRefMethod\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct CompsLenFinal [number]\n\t_ [length Comps] [- 2]\n    construct NewCompsTmp [repeat component]\n\tComps [head CompsLen]\n    construct NewComps [repeat component]\n\tComps [head CompsLenFinal]\n    construct RefIds [repeat id]\n\t_ [^ NewCompsTmp]\n    deconstruct * RefIds\n\tMethodName [id]\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'[ Id [this2my] Dims NewComps MethodName Exps '] \nend rule\n\nrule transformRefIdFirst\n    replace [declaration_or_statement]\n\tId [id] _ [repeat dimension] Comps [repeat component] '= AssExp [assignment_expression] ';\n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    by\n\tId NewComps 'set VarId AssExp '%\nend rule\n\nrule transformRefId\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps\n    by\n\t'[ NewRef 'set VarId ']\nend rule\n\nrule transformRefArray\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\tDim [dimension]\n\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n\n\n    deconstruct * NewComps\n\t'. VarId [id]\n    construct CompsLen2 [number]\n\t_ [length NewComps] [- 1]\n    construct DimComp [component]\n\tDim\n    construct NewComps2 [repeat component]\n\tNewComps [head CompsLen2] % [. DimComp]\n\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps2 \n\n    construct TmpDims [repeat dimension]\n\tDim\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim TmpDims]\n\n    by\n\t'[ NewRef 'set VarId TclDim ']\nend rule\n\nfunction varRef2TclClassVar Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where \n\tId [is_class_var]\n    by\n\t'[ 'my 'set Id TclDim ']\nend function\n\nfunction varRef2TclClassStaticVar Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ '[ 'my 'class '] 'set Id TclDim ']\nend function\n\nfunction varRef2TclVarSimple Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where all \n\tId [>= 'a] [<= 'z]\n    where not\n\tId [is_staticclass_var]\n\t   [is_class_var]\n    deconstruct not Id\n\t'my\n    by\n\t'$ Id TclDim\nend function\n\nfunction varRefThis2TclThis Ref [reference]\n    deconstruct Ref\n\t'this\n    replace [reference]\n\t_ [reference]\n    by\n\t'[ 'self ']\nend function\n\nrule untransformForUpdateMores\n%    skipping [tcl_expr_more]\n    replace $ [tcl_expr]\n\tExp [tcl_expr]\n    deconstruct Exp\n\tRef [reference]\n    deconstruct Ref\n\t'[ More [tcl_expr] ']\n    by\n\tMore\nend rule\n\nfunction processJavaSwitchAltEntry\n    replace [switch_alternative]\n\tLabel [switch_label] Decls [repeat declaration_or_statement+] \n    export SwitchAltDecls [repeat declaration_or_statement+]\n\tDecls \n    by\n\tLabel Decls \nend function\n\nfunction processJavaSwitchAltCommentEntry\n    replace [switch_alternative]\n\tLabel [switch_label] Decls [repeat declaration_or_statement+]\n    deconstruct Decls\n\t_ [comment_NL]\n    import SwitchAltDecls [repeat declaration_or_statement+]\n    by\n\tLabel Decls [. SwitchAltDecls]\nend function\n\nfunction processJavaSwitchAltEmptyEntry\n    replace [switch_alternative]\n\tLabel [switch_label] \n    import SwitchAltDecls [repeat declaration_or_statement+]\n    by\n\tLabel SwitchAltDecls \nend function\n\nfunction addUnaryToTclExprs Una [unary_expression]\n    replace [repeat tcl_expr_more]\n\tMores [repeat tcl_expr_more]\n    construct Cmd [tcl_expr_more]\n\tUna\n    by\n\tMores [. Cmd]\nend function\n\nrule collectUnaries\n    skipping [unary_expression]\n    replace $ [unary_expression]\n\tUna [unary_expression]\n    import PutsUnas [repeat unary_expression]\n    construct NewPutsUnas [repeat unary_expression]\n\tPutsUnas [. Una]\n    export PutsUnas\n\tNewPutsUnas\n    by\n\tUna\nend rule\n\nfunction addTclIdPart Id [id]\n    replace [repeat tcl_id_part]\n\tParts [repeat tcl_id_part]\n    construct Part [tcl_id_part]\n\t':: Id\n    by\n\tParts [. Part]\nend function\n\nrule addSuperInConstructorIfAbsent Constructor [constructor_declaration] \n    replace $ [constructor_body]\n\t'{ Decls [repeat declaration_or_statement] '}\n    where not\n\tDecls [?transformSuperInConstructor Constructor]\n    by\n\t'{\n\t'super '( ') ';\n\tDecls '}\nend rule\n\nrule transformSuperInConstructor Constructor [constructor_declaration] \n    replace $ [declaration_or_statement]\n\t'super MethArg [method_argument] ';\n    import JClassOrigin [class_declaration]\n    deconstruct JClassOrigin\n\t_ [repeat modifier] 'class _ [class_name] \n\tExtends [opt extends_clause] \n\t_ [opt implements_clause] _ [class_body]\n    construct ExtendClasses [repeat reference]\n\t_ [^ Extends]\n    construct Parents [repeat reference]\n\tExtendClasses [removeNonIdRef]\n    deconstruct * ExtendClasses \n\tParentName [id]\n    construct Args [repeat expression]\n\t_ [^ MethArg]\n    construct VarIds [repeat id]\n\t_ [^ Args]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    construct TypeString [id]\n\t_ [buildVarsTypeList4Constructor Constructor each VarIds]\n    construct XNewName [id]\n\t_ [+ ParentName] [+ \"_body\"] [+ TypeString]\n    by\n\t'my XNewName Exps '% \nend rule\n\nrule removeSuperInConstructor \n    replace [repeat declaration_or_statement]\n\t'super MethArg [method_argument] ';\n\tDecls [repeat declaration_or_statement]\n    by\n\tDecls\nend rule\n\nrule transformThisStatement Constructor [constructor_declaration] \n    replace $ [declaration_or_statement]\n\t'this MethArg [method_argument] ';\n    deconstruct Constructor\n\t_ [repeat modifier] ClassName [id] _ [opt generic_parameter]\n\t'( _ [list formal_parameter] ')  _ [opt throws] _ [constructor_body]\n    construct Args [repeat expression]\n\t_ [^ MethArg]\n    construct VarIds [repeat id]\n\t_ [^ Args]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    construct TypeString [id]\n\t_ [buildVarsTypeList4Constructor Constructor each VarIds]\n    construct XNewName [id]\n\t_ [+ ClassName] [+ \"_body\"] [+ TypeString]\n    by\n\t'my XNewName Exps '% \nend rule\n\nfunction transformJavaLocalScopeVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    by\n\t'set Id TclDim\nend function\n\nfunction transformJavaClassVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    where \n\tId [is_class_var]\n    by\n\t'my 'set Id TclDim\nend function\n\nfunction transformJavaClassStaticVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ 'my 'class '] 'set Id TclDim\nend function\n\nfunction transformJavaThisVar Ref [reference]\n    deconstruct Ref\n\t'this '. Id [id] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_class_var]\n    by\n\t'my 'set Id \nend function\n\nfunction transformJavaThisStaticVar Ref [reference]\n    deconstruct Ref\n\t'this '. Id [id] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ 'my 'class '] 'set Id \nend function\n\n\n\nfunction assignToArrayRef Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n\n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    construct ExprLen [number]\n\t_ [length Expr]\n    where not\n\tExprLen [> 0]\n\n    deconstruct * Comps\n\tDim [dimension]\n\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n\n\n    deconstruct * NewComps\n\t'. VarId [id]\n    construct CompsLen2 [number]\n\t_ [length NewComps] [- 1]\n    construct DimComp [component]\n\tDim\n    construct NewComps2 [repeat component]\n\tNewComps [head CompsLen2] % [. DimComp]\n\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps2 \n\n    construct TmpDims [repeat dimension]\n\tDim\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim TmpDims]\n\n    by\n        NewRef 'set VarId TclDim \nend function\n\nfunction transformArithAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    where\n\tButt [is_arithmetic]\n    construct TclRef [tcl_expr_more]\n\t'[ 'expr '{ Butt '} ']\n    by\n\tTclRef\nend function\n\nfunction transformLiteralAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tLiteral [literal]\n    by\n\tLiteral\nend function\n\nfunction transformRefAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tRef [reference]\n    by\n\tRef\nend function\n\nfunction transformNewAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tNew [class_instance_creation_expression]\n    construct NewCmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    by\n\tNewCmd\nend function\n\nrule transformTryCatch\n    replace $ [declaration_or_statement]\n\t'try Block [block] Catches [repeat catch_clause] _ [opt finally_clause]\n    deconstruct Block\n\t'{ BlockStmts [repeat declaration_or_statement] '}\n    construct CatchesStmts [repeat declaration_or_statement]\n\t_ [^ Catches]\n    construct CatchBlock [xotcl_proc_body]\n\tCatchesStmts\n    by\n\t'if '{ '[ 'catch '{ BlockStmts '} 'result '] '} '{\n\tCatchBlock\n\t'} \nend rule\n\nrule transformThrowStmt\n    replace $ [declaration_or_statement]\n\t_ [throw_statement]\t\n    by\n\t'error '$result\nend rule\n\nrule transformIf\n    replace [declaration_or_statement]\n\t'if '( IfExpr [expression] ') _ [repeat comment_NL]\n\tStmt [statement] \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct IfTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    construct TclIf [tcl_if_cmd]\n\t'if '{ IfExpr '} IfTclBlock\n    by\n\tTclIf\nend rule\n\nrule transformIfElse\n    replace [declaration_or_statement]\n\t'if '( IfExpr [expression] ') IfStmt [statement] _ [repeat comment_NL]\n\t'else ElseStmt [statement]\n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct IfTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok IfStmt] \n\t\t      [statementBlockToTclBlock IfStmt]\n    construct ElseTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok ElseStmt] \n\t\t      [statementBlockToTclBlock ElseStmt]\n    deconstruct IfTclBlock\n\t'{ IfBody [opt xotcl_proc_body] '}\n    construct TclIf [tcl_if_cmd]\n\t'if '{ IfExpr '} '{ IfBody '} 'else ElseTclBlock\n    by\n\tTclIf\nend rule\n\nrule transformCondChoice\n    replace $ [assignment_expression]\n\tCond [conditional_expression]\n    deconstruct Cond\n\tUna [unary_expression] '? Exp [expression] ': CondChExp [conditional_expression]\n    by\n\t'[ 'expr '{ Una '? Exp  ': CondChExp '} ']\nend rule\n\nrule transformWhile\n    replace [declaration_or_statement]\n\t'while '( Expr [expression] ') Stmt [statement] \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct WhileTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    construct TclWhile [tcl_while_cmd]\n\t'while '{ Expr '}  WhileTclBlock\n    by\n\tTclWhile\nend rule\n\nrule transformSwitch\n    replace [declaration_or_statement]\n\t'switch '( Expr [expression] ') '{ JAlts [repeat switch_alternative] '}\n    construct Alts [repeat tcl_switch_entry]\n\t_ [transformSwitchAlternatives each JAlts] \n    construct TclSwitch [tcl_switch_cmd]\n\t'switch Expr '{ Alts '} \n    by\n\tTclSwitch\nend rule\n\nrule transformFor\n    replace [declaration_or_statement]\n\t'for '( ForInit [for_init] \n\tForExpr [opt expression] '; \n\tForUpd [list expression] ') \n\tStmt [statement] \n    construct ForUpdSeq [repeat expression]\n\t_ [. each ForUpd]\n    construct TclCmdLists [repeat tcl_cmd_list]\n\t_ [expressionListToTclCmdList ForUpdSeq] \n\t  [transformVarAssignmentFor]\n    construct TclForInit [repeat tcl_cmd_list]\n\t_ [transformForInitStmt1 ForInit] \n\t  [transformForInitStmt2 ForInit]\n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct ForTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    by\n\t'for '{ TclForInit '} \n\t'{ ForExpr '} '{ TclCmdLists '}\n\tForTclBlock\nend rule\n\nrule transformForeach\n    replace [declaration_or_statement]\n\t'for '( \n\t%for_in_init\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t': Expr [expression] ')\n\t\tStmt [statement]        \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct ForTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    by\n\t'foreach '{ Id '} '{ Expr '}\n\tForTclBlock\nend rule\n\nrule convertUnaryOpMultiLocal\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpMultiMy\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    where \n\tRef [is_class_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'my 'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpMultiClass\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    where \n\tRef [is_staticclass_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'[ 'my 'class '] 'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpFirstLocal\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nrule convertUnaryOpFirstMy\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    where \n\tRef [is_class_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'my 'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nrule convertUnaryOpFirstClass\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    where \n\tRef [is_staticclass_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'[ 'my 'class '] 'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nfunction expressionSeq2TclExprMoreSeq Expressions [repeat expression]\n    replace [repeat tcl_expr_more]\n\tEMore [repeat tcl_expr_more]\n    deconstruct Expressions\n\tExpr [expression] Exprs [repeat expression]\n    construct TclEMore [repeat tcl_expr_more]\n\tExpr\n    by\n\tEMore [. TclEMore] [expressionSeq2TclExprMoreSeq Exprs]\nend function\n\nfunction argumentToExpression Argument [argument]\n    replace [repeat expression]\n\tExps [repeat expression]\n    deconstruct Argument\n\tExp [expression]\n    by\n\tExps [. Exp]\nend function\n\nfunction is_static \n    match * [modifier]\n\t'static\nend function\n\nfunction is_synchronized\n    match * [modifier]\n\t'synchronized\nend function\n\nfunction transformId2TclVar Id [id]\n    replace [repeat tcl_expr_more]\n\tCmds [repeat tcl_expr_more]\n    construct Var [tcl_expr_more]\n\t'$ Id\n    by\n\tCmds [. Var]\nend function\n\nfunction buildParameterTypeList Parameter [formal_parameter]\n    replace [id]\n\tParams [id] \n    construct TypeName [id]\n\t_ [extractPrimitiveTypeName Parameter]\n\t  [extractReferenceTypeName Parameter]\n    by\n\tParams [_ TypeName]\nend function\n\nfunction this2my \n    replace [id]\n\t'this\n    by\n\t'my\nend function\n\nfunction dim2TclDim Dims [repeat dimension]\n    construct DimLen [number]\n\t_ [length Dims]\n    where \n\tDimLen [= 1]\n    deconstruct Dims\n\tDim [dimension] _ [repeat dimension]\n    deconstruct Dim\n\t'[ Expr [expression] ']\n    replace [repeat tcl_array_dimension]\n\t_ [repeat tcl_array_dimension]\n    by\n\t'( Expr ')\nend function\n\nfunction is_class_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_nonstatic_var Id]\nend function\n\nfunction is_staticclass_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_static_var Id]\nend function\n\nfunction buildVarsTypeList4Constructor Constructor [constructor_declaration] VarId [id]\n    replace [id]\n\tIds [id]\n    construct Tmp1 [constructor_declaration]\n\tConstructor [findVarTypeInConstructorParams VarId]\n    import TypeName [id]\n    by\n\tIds [+ TypeName]\nend function\n\nrule is_arithmetic\n    match $ [any]\n\tAny [any]\n    where \n\tAny [istype 'add_op]\n\t    [istype 'mult_op]\n\t    [istype 'unary_op]\n\t    [istype 'or_conditional_and_expression]\n\t    [istype 'and_inclusive_or_expression]\n\t    [istype 'or_exclusive_or_expression]\n\t    [istype 'or_and_expression]\n\t    [istype 'and_equality_expression]\n\t    [istype 'equality_op]\n\t    [istype 'relational_op]\n\t    [istype 'shif_op]\n\t    [istype 'conditional_choice]\nend rule\n\nfunction statementOneDeclToTclBlcok Stmt [statement]\n    replace [tcl_block]\n\t_ [tcl_block]\n    deconstruct not Stmt\n\t_ [block]\n    construct Decl [declaration_or_statement]\n\tStmt\n    by\n\t'{ Decl '}\nend function\n\nfunction statementBlockToTclBlock Stmt [statement]\n    replace [tcl_block]\n\t_ [tcl_block]\n    deconstruct Stmt\n\t'{ Decls [repeat declaration_or_statement] '}\n    by\n\t'{ Decls '}\nend function\n\nfunction transformSwitchAlternatives JAlt [switch_alternative]\n    replace [repeat tcl_switch_entry]\n\tEntries [repeat tcl_switch_entry]\n    deconstruct JAlt\n\t'case Label [constant_expression] ': Decls [repeat declaration_or_statement]\n    construct SwitchLabel [tcl_cmd]\n\t_ [switchLabelConvertNum Label] [switchLabelConvertChar Label]\n    construct Entry [tcl_switch_entry]\n\tSwitchLabel '{ Decls '} \t\n    by\n\tEntries [. Entry]\nend function\n\nfunction expressionListToTclCmdList Expressions [repeat expression]\n    replace [repeat tcl_cmd_list]\n\t_  [repeat tcl_cmd_list]\n    deconstruct Expressions\n\tExpr [expression] Exprs [repeat expression]\n    construct TclCmdList [tcl_cmd_list]\n\tExpr\n    by\n\tTclCmdList [addExpToTclCmdList each Exprs]\nend function\n\nfunction transformForInitStmt1 ForInit [for_init]\n    deconstruct ForInit\n\tExprs [list expression] ';\n    replace [repeat tcl_cmd_list]\n\t_ [repeat tcl_cmd_list]\n    construct ExprSeq [repeat expression]\n\t_ [. each Exprs]\n    by\n\t_ [expressionListToTclCmdList ExprSeq] [transformVarAssignmentFor]\nend function\n\nfunction transformForInitStmt2 ForInit [for_init]\n    deconstruct ForInit\n\tLocalDecl [declaration_or_statement] \n    construct TmpDecls [repeat declaration_or_statement]\n\tLocalDecl\n    construct TmpDecls2 [repeat declaration_or_statement]\n\tTmpDecls [splitLocalVarDeclarations] [localVarDecl2Assignment]\n    deconstruct TmpDecls2\n\tDecl1 [declaration_or_statement] _ [repeat declaration_or_statement]\n    replace [repeat tcl_cmd_list]\n\t_ [repeat tcl_cmd_list]\n    by\n%\tLocalDecl\n\tTmpDecls2\nend function\n\nrule transformVarAssignmentFor\n    replace [repeat tcl_expr_more]\n\t Ref [reference] '= Butt [assignment_expression] \n    construct TclCmd [repeat tcl_expr_more]\n\t_ [transformJavaLocalScopeVar Ref] \n\n\t  [transformJavaClassVar Ref] \n\t  [transformJavaClassStaticVar Ref] \n\n\t  [transformJavaThisVar Ref] \n\t  [transformJavaThisStaticVar Ref] \n\n\t  [complexRefAssignment Ref]\n\t  [assignToArrayRef Ref]\n    construct TclLit [tcl_expr_more]\n\t_ [transformArithAssExp Butt]\n\t  [transformLiteralAssExp Butt]\n\t  [transformRefAssExp Butt]\n\t  [transformNewAssExp Butt]\n    by\n\tTclCmd [. TclLit] \nend rule\n\nfunction makeDecrCmdTail Op [pre_inc_dec]\n    deconstruct Op\n\t'--\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    construct Num [tcl_literal]\n\t-1\n    by\n\tNum\nend function\n\nfunction extractPrimitiveTypeName Parameter [formal_parameter]\n    replace [id]\n\t_ [id]\n    construct Primitive [repeat primitive_type]\n\t_ [^ Parameter]\n    deconstruct Primitive\n\tFirst [primitive_type] _ [repeat primitive_type]\n    construct TypeName [id]\n\t_ [quote First]\n    by\n\t_ [+ TypeName]\nend function\n\nfunction extractReferenceTypeName Parameter [formal_parameter]\n    replace [id]\n\t_ [id]\n    construct References [repeat reference]\n\t_ [^ Parameter]\n    deconstruct References\n\t_ [id] _ [repeat dimension] _ [repeat component]\n    construct Ids [repeat id]\n\t_ [^ References]\n    deconstruct * Ids \n\tTypeName [id]\n    by\n\t_ [+ TypeName]\nend function\n\nfunction is_nonstatic_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where\n\tField [has_var Id] \n    where not\n\tField [is_static]\nend function\n\nfunction is_static_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where all\n\tField [has_var Id] [is_static]\nend function\n\nrule findVarTypeInConstructorParams VarId [id]\n    replace $ [formal_parameter]\n\tFP [formal_parameter]\n    deconstruct FP\n\t_ [opt 'final] _ [type_specifier] _ [opt var_arg_specifier] \n\tId  [id] _ [opt generic_parameter] _ [repeat dimension]\n    where \n\tId [= VarId]\n    construct TypeName [id]\n\t_ [buildParameterTypeList FP]\n    export TypeName\n    by\n\tFP\nend rule\n\nfunction switchLabelConvertNum Label [constant_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct Label\n\tNum [number]\n    by\n\tNum\nend function\n\nfunction switchLabelConvertChar Label [constant_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct Label\n\tChars [charlit]\n    construct Unq [id]\n\t_ [unquote Chars]\n    by\n\tUnq\nend function\n\nfunction addExpToTclCmdList Expr [expression]\n    replace [tcl_cmd_list]\n\tTclExpr [tcl_expr] TclCmdMore [repeat tcl_cmd_more]\n    construct TclCmdMore2 [tcl_cmd_more]\n\t'; Expr\n    by\n\tTclExpr TclCmdMore [. TclCmdMore2]\nend function\n\nfunction has_var Id [id]\n    match * [variable_name]\n\tVarId [id] _ [opt generic_parameter] _ [repeat dimension]\n    where \n\tVarId [= Id]\nend function\n\n",
        "after": " package require XOTcl\nnamespace import ::xotcl::*\n\nClass create IfElseDemo_metapapa -superclass {Class} -slots {\n\n}\n\nIfElseDemo_metapapa create IfElseDemo -superclass {Class} -slots {\n\n}\n\nIfElseDemo proc main {args} {\n    set testscore 76\n    if {$testscore >= 90} {\n        set grade 'A'\n    } else {\n        if {$testscore >= 80} {\n            set grade 'B'\n        } else {\n            if {$testscore >= 70} {\n                set grade 'C'\n            } else {\n                if {$testscore >= 60} {\n                    set grade 'D'\n                } else {\n                    set grade 'F'\n                }\n            }\n        }\n    }\n    puts [concat \"Grade = \" $grade]\n}\n\n ",
        "before": "\n// Copyright (c) 1995 - 2008 Sun Microsystems, Inc.  All rights reserved.\n\nclass IfElseDemo {\n\n    public static void main (String [] args) {\n        int testscore = 76;\n        char grade;\n        if (testscore >= 90) {\n            grade = 'A';\n        } else if (testscore >= 80) {\n            grade = 'B';\n        } else if (testscore >= 70) {\n            grade = 'C';\n        } else if (testscore >= 60) {\n            grade = 'D';\n        } else {\n            grade = 'F';\n        }\n\n        System.out.println (\"Grade = \" + grade);\n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function",
        "context": "function translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\n\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " //while\n\nwhile (a > 10) {\n    a ++;\n    Console.WriteLine (a);\n}\n//Do while\n\na = 0;\ndo {\n    a ++;\n    Console.WriteLine (a);\n} while (a < 10);\n//if\n\na = 5;\nint b = 5, c = 10;\nif (a == b) Console.WriteLine (a);\n\nif ((a > c) || (a == b)) Console.WriteLine (b);\n\nif ((a >= c) && (b <= c)) Console.WriteLine (c);\n\n//for\n\nfor (sbyte v = 0;\na >> 10; a ++) {\n    Console.WriteLine (a);\n}\n//switch\n\na = 2;\nswitch (a) {\n    case 1 :\n        Console.WriteLine (\"One\");\n        break;\n    case 2 :\n        Console.WriteLine (\"Two\");\n        break;\n    default :\n        Console.WriteLine (\"?\");\n        break;\n}\n ",
        "before": "\n//while\n\nwhile (a > 10) {\n    a ++;\n    System.out.println (a);\n}\n//Do while\n\na = 0;\ndo {\n    a ++;\n    System.out.println (a);\n} while (a < 10);\n//if\n\na = 5;\nint b = 5, c = 10;\nif (a == b) System.out.println (a);\n\nif ((a > c) || (a == b)) System.out.println (b);\n\nif ((a >= c) && (b <= c)) System.out.println (c);\n\n//for\n\nfor (byte v = 0;\na >>> 10; a ++) {\n    System.out.println (a);\n}\n//switch\n\na = 2;\nswitch (a) {\n    case 1 :\n        System.out.println (\"One\");\n        break;\n    case 2 :\n        System.out.println (\"Two\");\n        break;\n    default :\n        System.out.println (\"?\");\n}\n "
    },
    {
        "hole_rule": "function isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function",
        "context": "function translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\n\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " StaticInitTest.doStuff ();\nStaticInitTest sti = new StaticInitTest ();\nConsole.WriteLine (\"Completed main()\");\n ",
        "before": "\nStaticInitTest.doStuff ();\nStaticInitTest sti = new StaticInitTest ();\nSystem.out.println (\"Completed main()\");\n "
    },
    {
        "hole_rule": "function changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function",
        "context": "function translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\n\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " {\n    try {\n        lock (Class.forName (\"BumpTest\")) {\n            classCount ++;\n        }\n    } catch (System.Exception e) {\n    }\n} ",
        "before": "\n{\n    try {\n        synchronized (Class.forName (\"BumpTest\")) {\n            classCount ++;\n        }\n    } catch (ClassNotFoundException e) {\n    }\n} "
    },
    {
        "hole_rule": "rule resolveGenerics\n    replace [repeat Statement+]\n        G [Ident] '[ TP [list IdentDefaultType+] '] ( VP [list IdentDefaultExpr+] ) = GB [Type] ;\n        MoreS [repeat Statement]\n    by\n        ; MoreS [resolveGeneric G TP VP GB]\nend rule",
        "context": "function expandConstants\n    replace * [TypeUnitSpec]\n        types T [Ident] ;\n            TUB [StatementList]\n        'end OT [opt Ident] .\n    by\n        types T ;\n            TUB     [constsFirst] [resolveConsts]\n        'end OT .\nend function\n\nfunction expandTypes\n    replace * [TypeUnitSpec]\n        types T [Ident] ;\n            TUB [StatementList]\n        'end OT [opt Ident] .\n    by\n        types T ;\n            TUB     [typesFirst] [resolveTypes]\n        'end OT .\nend function\n\nfunction nameStructurallyEquivalentTypes\n    replace * [TypeUnitSpec]\n        types T [Ident] ;\n            TUB [StatementList]\n        'end OT [opt Ident] .\n    by\n        types T ;\n            TUB     [nameOneStructurallyEquivalentType]\n        'end OT .\nend function\n\nrule expandGenerics\n    replace [TypeUnitSpec]\n        types T [Ident] ;\n            TUB [StatementList]\n        'end OT [opt Ident] .\n    construct NewTUB [StatementList]\n        TUB     [normalizeGenerics]\n                [genericsFirst]\n                [resolveGenerics]\n    where not\n        NewTUB [= TUB]\n    by\n        types T ;\n            NewTUB\n        'end OT .\nend rule\n\nrule cleanup\n    replace [repeat Statement]\n        ;\n        MoreS [repeat Statement]\n    by\n        MoreS\nend rule\n\nfunction resolveConsts\n    replace * [repeat Statement+]\n        CD [ConstDef] ;\n        MoreS [repeat Statement]\n    deconstruct CD\n        Cid [Ident] == Cexpr [Expr]\n    by\n        CD ;\n        MoreS [substituteConstValue Cid Cexpr] [resolveConsts]\nend function\n\nrule constsFirst\n    replace [repeat Statement+]\n        S [Statement] \n        CD [ConstDef] ;\n        MoreS [repeat Statement]\n    where not\n        S [isConstDef] \n    by\n        CD ;\n        S\n        MoreS\nend rule\n\nfunction resolveTypes\n    replace * [repeat Statement+]\n        TD [TypeClause] ;\n        MoreS [repeat Statement]\n    deconstruct TD\n        Tid [Ident] = Ttype [Type]\n    by\n        TD ;\n        MoreS [substituteTypeDef Tid Ttype] [resolveTypes]\nend function\n\nrule typesFirst\n    replace [repeat Statement+]\n        S [Statement] \n        TD [TypeClause] ;\n        MoreS [repeat Statement]\n    where not\n        S [isTypeClause] \n    by\n        TD ;\n        S\n        MoreS\nend rule\n\nrule nameOneStructurallyEquivalentType\n    replace [repeat Statement+]\n        TD [TypeClause] ;\n        MoreS [repeat Statement]\n    deconstruct TD\n        Tid [id] = Ttype [Type]\n    where not\n        Ttype [isSimpleType] \n    where\n        MoreS [hasAnotherTypeDefLike Ttype]\n    construct Tprime [id]\n        Tid [!]\n    by\n        Tprime = Ttype ;\n        Tid = Tprime ;\n        MoreS [substituteTypeId Ttype Tprime]\nend rule\n\nfunction normalizeGenerics\n    replace [StatementList]\n        SL [StatementList]\n    by\n        SL [addMissingGenericTypeParameters] \n            [addMissingGenericValueParameters]\nend function\n\nrule genericsFirst\n    % put all generics first, regardless of present position\n    replace [repeat Statement+]\n        S [Statement]\n        T [TypeClause] ;\n        MoreS [repeat Statement]\n    where\n        T [isGeneric]\n    where not\n        S [isGeneric]\n    by\n        T ;\n        S\n        MoreS\nend rule\n\n\n\nrule substituteConstValue  Cid [Ident]  Cvalue [Expr]\n    replace [Expr]\n        Cid\n    by\n        Cvalue\nend rule\n\nfunction isConstDef\n    match [Statement]\n        CD [ConstDef] ;\nend function\n\nrule substituteTypeDef  Tid [Ident]  Ttype [Type]\n    replace [Type]\n        Tid\n    by\n        Ttype\nend rule\n\nfunction isTypeClause\n    match [Statement]\n        TD [TypeClause] ;\nend function\n\nfunction isSimpleType\n    match [Type]\n        ST [SimpleType]\nend function\n\nrule hasAnotherTypeDefLike Ttype [Type]\n    match [Type]\n        Ttype\nend rule\n\nrule substituteTypeId Ttype [Type] Tid [id]\n    replace [Type]\n        Ttype\n    by\n        Tid\nend rule\n\nrule addMissingGenericTypeParameters\n    replace [repeat Statement+]\n        G [Ident] FP [FormalParamPart] = GB [Type] ;\n        MoreS [repeat Statement]\n    deconstruct G \n        Gid [id]\n    construct NewParmId [Ident]\n        Gid [!]\n    by\n        G '[ NewParmId '] FP = GB ;\n        MoreS  [addDummyTypeParam G]\nend rule\n\nrule addMissingGenericValueParameters\n    replace [repeat Statement+]\n        G [Ident] GP [GenericPart] = GB [Type] ;\n        MoreS [repeat Statement] \n    deconstruct G \n        Gid [id]\n    construct NewParmId [Ident]\n        Gid [!]\n    by\n        G GP ( NewParmId ) = GB ;\n        MoreS  [addDummyValueParam G]\nend rule\n\nrule isGeneric\n    match [TypeClause]\n        G [Ident] GP [GenericPart] GFP [FormalParamPart] = GB [Type] \nend rule\n\nrule resolveGeneric     G [Ident] TPL [list IdentDefaultType+] VPL [list IdentDefaultExpr+] GB [Type]\n    replace [Type]\n        G '[ ITPL [list SimpleType+] '] ( IVPL [list Expr+] )\n    by\n        GB [substituteTypeParameters each TPL ITPL] \n             [substituteValueParameters each VPL IVPL]\nend rule\n\nrule addDummyTypeParam G [Ident]\n    replace [SimpleType]\n        G ( GVP [ExprList] )\n    by\n        G '[ int '] ( GVP )\nend rule\n\nrule addDummyValueParam G [Ident]\n    replace [SimpleType]\n        G '[ GTP [SimpleTypeList] ']\n    by\n        G '[ GTP '] ( 1 )\nend rule\n\nrule substituteTypeParameters GTP [IdentDefaultType] ITP [SimpleType]\n    deconstruct GTP\n        GTPid [Ident]\n    replace [SimpleType]\n        GTPid\n    by\n        ITP\nend rule\n\nrule substituteValueParameters GVP [IdentDefaultExpr] IVP [Expr]\n    deconstruct GVP\n        GVPid [Ident]\n    replace [Expr]\n        GVPid\n    by\n        IVP\nend rule\n\n",
        "after": " types Jim;\n    c == 5;\n    d == 12;\n    e == 65;\n    T = (x : int;);\n    S = (x : string;);\n    TV1 = [5] char;\n    TV = TV1;\n    LTV1 = (x : TV1; y : TV1;);\n    LTV = LTV1;\n    LTVE = LTV1;\n    MT = (x : int; y : LTV1; z : boolean; a : [65] char;);\nend Jim.\n ",
        "before": "\ntypes Jim;\n    c == 5;\n    J [T] = (x : T;);\n    T = J [int];\n    S = J [string];\n    K (V) = [V] char;\n    TV = K (c);\n    L [T] (V) = (x : T; y : [V] char;);\n    LTV = L [TV] (5);\n    d == 12;\n    LTVE = L [TV] (c);\n    M [T1, T2, T3] (V1) = (x : T1; y : T2; z : T3; a : [V1] char;);\n    e == 65;\n    MT = M [int, LTV, boolean] (e);\nend Jim.\n "
    },
    {
        "hole_rule": "function setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function",
        "context": "function translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\n\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " public static void Main (String [] args) {\n    bool flag = true;\n    const int y = 6;\n    double X = Math.random ();\n    int DAYS_IN_YEAR;\n    if (flag) DAYS_IN_YEAR = 366;\n    else DAYS_IN_YEAR = 365;\n\n}\n\n ",
        "before": "\npublic static void main (String [] args) {\n    boolean flag = true;\n    final int y = 6;\n    final double X = Math.random ();\n    final int DAYS_IN_YEAR;\n    if (flag) DAYS_IN_YEAR = 366;\n    else DAYS_IN_YEAR = 365;\n\n}\n\n "
    },
    {
        "hole_rule": "function staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function",
        "context": "function translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\n\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n",
        "after": " static public int My2ndFunction (int myInt2) {\n    myInt2 = myInt2 * 2;\n    return myInt2;\n}\n\n ",
        "before": "\nstatic public int My2ndFunction (int myInt2) {\n    myInt2 = myInt2 * 2;\n    return myInt2;\n}\n\n "
    },
    {
        "hole_rule": "function translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function",
        "context": "function addBraces %\nreplace [program] \n\tNewImportDeclaration[repeat import_declaration]\n\tPHeader[package_header]\t    \n\tTypeDeclr[repeat type_declaration]\n\t%construct Length[number]\n\t%\t _[length NewImportDeclaration]\n\t%where Length[> 0]\n\tby\n\tNewImportDeclaration\n\tPHeader\t    \n\t'{\n\t    TypeDeclr\n\t'}\nend function\n\nfunction changeImportToUsing importDec[import_declaration]\n\tdeconstruct importDec\n\t    'import Name[package_or_type_name] DotStar[opt dot_star] '; \n\treplace *[repeat import_declaration]\n\tby\n\t    'using Name ';%remove DotStar\n\t    %decide how to change for proper C# equivelant API\nend function\n\nfunction changePackageToNamespace\n\treplace [opt package_header]\n\t    'package Name[package_name] '; \n\tby\n\t    'namespace Name \nend function\n\nfunction changeClassHeader\n% Java: [repeat modifier] 'class [class_name] [opt extends_clause] [opt implements_clause]\n% C#:   class-modifiersopt   class   identifier   class-base opt   class-body   ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\t\t%to set a constructor if needed\n\t\texport ClassName[class_name]\n\t\t\tName\t\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeInterfaceHeader\n% Java: [repeat modifier] 'interface [interface_name] [opt extends_clause] [opt implements_clause]\n% C#:   attributesopt interface-modifiersopt interface identifier interface-baseopt interface-body ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\n\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " using System;\nnamespace examples\n    {\n        class MyMainClass {\n\n            public static void Main (String [] args) {\n                WhileContinue ();\n                WhileBreak ();\n                WhileGoto ();\n            }\n\n            static void WhileContinue () {\n                int a = 0;\n                while (a < 10) {\n                    a ++;\n                    if (a == 5) {\n                        a ++;\n                        continue;\n                    }\n                }\n            }\n\n            static void WhileBreak () {\n                int a = 0;\n                while (a < 10) {\n                    a ++;\n                    if (a == 5) break;\n\n                }\n                a ++;\n            }\n\n            static void WhileGoto () {\n                int a = 0;\n                while (a < 10) {\n                    if (a == 5) break cleanup;\n\n                }\n                cleanup :\n                Console.WriteLine (a);\n            }\n\n        }\n\n    }\n ",
        "before": "\npackage examples;\n\nclass MyMainClass {\n\n    public static void main (String [] args) {\n        WhileContinue ();\n        WhileBreak ();\n        WhileGoto ();\n    }\n\n    static void WhileContinue () {\n        int a = 0;\n        while (a < 10) {\n            a ++;\n            if (a == 5) {\n                a ++;\n                continue;\n            }\n        }\n    }\n\n    static void WhileBreak () {\n        int a = 0;\n        while (a < 10) {\n            a ++;\n            if (a == 5) break;\n\n        }\n        a ++;\n    }\n\n    static void WhileGoto () {\n        int a = 0;\n        while (a < 10) {\n            if (a == 5) break cleanup;\n\n        }\n        cleanup :\n        System.out.println (a);\n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function",
        "context": "function translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\n\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\n",
        "after": " lock (Class.forName (\"BumpTest\")) {\n    classCount ++;\n}\n ",
        "before": "\nsynchronized (Class.forName (\"BumpTest\")) {\n    classCount ++;\n}\n "
    },
    {
        "hole_rule": "function extractPrimitiveTypeName Parameter [formal_parameter]\n    replace [id]\n\t_ [id]\n    construct Primitive [repeat primitive_type]\n\t_ [^ Parameter]\n    deconstruct Primitive\n\tFirst [primitive_type] _ [repeat primitive_type]\n    construct TypeName [id]\n\t_ [quote First]\n    by\n\t_ [+ TypeName]\nend function",
        "context": "function preparationTransformations\n    replace [program]\n\tP [program]\n    by\n\tP [exportClass]\n\t  [removeCastExpressions]\n\t  [expandJavaSwitch]\n\t  [javaPreUnary2PostUnary]\n\t  [convertJavaSelfAssignments]\n\t  \n\t  [transformVariables]\n\n\t  [localVarDecl2Assignment]\n\n\t  [removeArrayCreation]\n\n\t  [transformLiterals]\nend function\n\nfunction finalTransformations\n    replace [program]\n\tP [program]\n    by\n\tP [systemOutPrintln2Puts]\n   \t  [systemOutPrint2Puts]\nend function\n\nfunction transformImpEx\n    replace [program]\n\tP [program]\n    by\t\n\tP [addXOTclImport] [addXOTclImportIfNoPH] [removeImports]\nend function\n\nfunction classTransforms\n    replace [program]\n\tP [program]\n    by\n\tP [constructorTransforms]\n\t  [addClassMetaAndClass]\n\n\t  [teleportClassStaticAttributes]\n\t  [teleportClassStaticMethods]\n\n\t  [transformMethodsHeaders]\n\n\t  [transformDefaultAttributes]\n\t  [transformInitAttributesNew]\n\n\t  [transformExpressions]\n\n\t  [transformParameterVarRefs]\n\n\t  [transformDotRefs] \n\n\t  [untransformForUpdate]\n\n\t  [varRef2TclRef]\nend function\n\nfunction transformVariables\n    replace [program]\n\tP [program]\n    by\n\tP [splitVarDeclarations] [sortAllVarsUp]\n\t  [splitLocalVarDeclarations]\n\t  [removeEmptyLocalVarDeclarations]\nend function\n\nfunction exportClass\n    replace * [class_declaration]\n\tCD [class_declaration]\n    export JClassOrigin [class_declaration]\n\tCD\n    by\n\tCD\nend function\n\nrule transformLiterals\n    replace $ [literal]\n\tL [literal]\n    by\n\tL [transformBooleanTrue] [transformBooleanFalse]\nend rule\n\nrule removeCastExpressions\n    replace [unary_expression]\n\t'( _ [type_specifier] ') Unary [unary_expression]\n    by\n\tUnary\nend rule\n\nrule expandJavaSwitch\n    replace $ [switch_block]\n\tBlock [switch_block]\n    by\n\tBlock [removeSwitchBreak]\n\t      [convertSwitchDefaultLabel] \n\t      [expandJavaSwitchAlts]\nend rule\n\nrule javaPreUnary2PostUnary\n    replace [unary_expression]\n\tOp [pre_inc_dec] Una [primary]\n    by\n\tUna Op\nend rule\n\nrule convertJavaSelfAssignments\n    replace [assignment_expression]\n\tAss [assignment_expression]\n    deconstruct Ass\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct not Op\n\t_ [forbidden_self_assignments]\n    by\n\tAss [convertJavaSelfAssPlus]\n\t    [convertJavaSelfAssMinus]\n\t    [convertJavaSelfAssDiv]\n\t    [convertJavaSelfAssMul]\n\t    [convertJavaSelfAssDivLeft]\nend rule\n\nrule localVarDecl2Assignment\n    replace $ [declaration_or_statement]\n\tDecl [declaration_or_statement] \n    deconstruct Decl\n\t_ [repeat modifier] _ [type_specifier] _ [variable_declarators] ';\n    by\n\tDecl [localVarDecl2AssignmentExp] [localVarDecl2AssignmentArray] \nend rule\n\nrule removeArrayCreation\n    replace [repeat declaration_or_statement]\n\t_ [reference] '= _ [array_creation_expression] ';\t\n\tRest [repeat declaration_or_statement]\n    by\n\tRest\nend rule\n\nrule systemOutPrintln2Puts\n    replace $ [repeat tcl_expr_more]\n\t Cmd1 [reference] 'println More [repeat tcl_expr_more]\n    deconstruct Cmd1\n\t'[ Sys [reference] 'set 'out ']\n    deconstruct Sys\n\t'System\n    by\n\t'puts More [expandPrintlnParams]\nend rule\n\nrule systemOutPrint2Puts\n    replace $ [repeat tcl_expr_more]\n\t Cmd1 [reference] 'print More [repeat tcl_expr_more]\n    deconstruct Cmd1\n\t'[ Sys [reference] 'set 'out ']\n    deconstruct Sys\n\t'System\n    by\n\t'puts '-nonewline More [expandPrintlnParams]\nend rule\n\nfunction addXOTclImport\n    replace * [package_header]\n\tAnn [repeat annotation]\n\t'package Ref [package_name] ';\n    by\n%\tAnn \n\t'package 'provide Ref\n\t'package 'require 'XOTcl\n        'namespace 'import '::xotcl::*\nend function\n\nfunction addXOTclImportIfNoPH\n    replace * [package_declaration]\n\t_ [repeat comment_NL]\n%\tPH [opt package_header]\n\tImps [repeat import_declaration] \n\tDecls [repeat type_declaration]\n    construct OHead [package_header] \n%\t'package 'provide 'SampleTransform\n\t'package 'require 'XOTcl\n        'namespace 'import '::xotcl::*\n    by\n\tOHead\n\tImps\n\tDecls\nend function\n\nfunction removeImports\n    replace * [package_declaration]\n\tCmts [repeat comment_NL] \n\tPkgHead [opt package_header]\n\tImpDecl [repeat import_declaration] \n\tTypeDecl [repeat type_declaration]\n    by\n\tCmts PkgHead TypeDecl\nend function\n\nfunction addClassMetaAndClass\n    replace * [package_declaration]\n\tCmts [repeat comment_NL] \n\tPkgHead [opt package_header]\n\tImpDecl [repeat import_declaration] \n\tTypeDecl [repeat type_declaration]\n    deconstruct TypeDecl \n\t_ [repeat modifier] 'class ClassName [id] \n\tExtends [opt extends_clause] Implements [opt implements_clause] \n\t_ [class_body]\n\t_ [repeat type_declaration]\n    construct MetaClassName [id]\n\tClassName [_ 'metapapa]\n    construct ExtendClasses [repeat reference]\n\t_ [^ Extends]\n    construct Parents [repeat reference]\n\tExtendClasses [removeNonIdRef]\n    construct TclParents [repeat tcl_id]\n\t_ [pkgRef2TclId each Parents]\n    by\n\tCmts PkgHead ImpDecl \n\t'Class 'create MetaClassName '-superclass '{ 'Class '} '-slots '{ '}\n\tMetaClassName 'create ClassName '-superclass '{ 'Class TclParents '} \n\t'-slots '{ '}\n\tTypeDecl\nend function\n\nfunction constructorTransforms\n    replace [program]\n\tP [program]\n    by\n\tP [transformThisInConstructor] [transformSuperInConstructors]\nend function\n\nfunction transformExpressions\n    replace [program]\n\tP [program]\n    by\n\tP \n\t  [transformNewExpr]\n\n\t  [transformExceptions]\n\t  [transformConditionalStatements]\n\n\t  [transformVarAssignment]\n\n\n\t  [convertUnaryOpFirst]\n\t  [convertUnaryOpInMultiplicative]\nend function\n\nrule transformDefaultAttributes\n    replace [field_declaration]\n\t_ [repeat modifier] _ [type_specifier] Name [id] _ [opt generic_parameter] \n\t'= Literal [literal] '; \n    by\n\t'Attribute Name '-default Literal \nend rule\n\nrule transformInitAttributesNew\n    replace [field_declaration]\n\t_ [repeat modifier] _ [type_specifier] Name [id] _ [opt generic_parameter] \n\t'= New [class_instance_creation_expression] ';\n    construct NewCmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    by\n\t'Attribute Name '-initcmd '{ NewCmd '}\nend rule\n\nrule teleportClassStaticAttributes\n    replace $ [repeat type_declaration]\n\t%MetaClass\n\tMetaBase [id] MetaCreate [opt 'create] MetaClassName [id] MetaSuper [opt xotcl_class_superclasses]\n\t'-slots '{ '}\n\t%Class\n\tClassBase [id] ClassCreate [opt 'create] ClassName [id] ClassSuper [opt xotcl_class_superclasses]\n\t'-slots '{ '}\n\t%Java Class\n\tJClassHeader [class_header] JBody [class_or_interface_body]\n\t_ [repeat type_declaration]\n    construct JBodyElements [repeat class_body_declaration]\n\t_ [^ JBody]\n    construct JFields [repeat field_declaration]\n\t_ [^ JBody]\n    by\n\tMetaBase MetaCreate MetaClassName MetaSuper '-slots '{ JFields [removeNonStaticField] '}\n\tClassBase ClassCreate ClassName ClassSuper '-slots '{ JFields [removeStaticField] '}\n\tJClassHeader JBody \nend rule\n\nrule teleportClassStaticMethods\n    replace $ [repeat type_declaration]\n\t%Class\n\tClassBase [xotcl_class]\n\t%Java Class\n\tJClass [class_header] JBody [class_or_interface_body]\n\t_ [repeat type_declaration]\n    construct JMethods [repeat method_or_constructor_declaration]\n\t_ [^ JBody]\n    construct InstanceMethods [repeat method_or_constructor_declaration]\n\tJMethods [transformNonStaticMethod2Proc]\n    by\n\tClassBase\n\tJMethods [transformStaticMethod2Proc] [. InstanceMethods]\nend rule\n\nrule transformMethodsHeaders\n    replace $ [xotcl_class_with_methods]\n\tClass [xotcl_class]\n\tMethods [repeat method_or_constructor_declaration]\n    deconstruct Class\n\t_ [id] _ [opt 'create] \n\tName [id] _ [opt xotcl_class_superclasses] _ [opt xotcl_class_slots] \n    by\n\tClass\n\tMethods [transformNonStaticMethodHeader Name] \n\t\t[transformStaticMethodHeader Name]\n\t\t[transformSynchroNonStaticMethodHeader Name] \n\t\t[transformSynchroStaticMethodHeader Name]\n\t\t[transformConstructorHeader]\nend rule\n\nrule transformParameterVarRefs\n    replace $ [repeat method_or_constructor_declaration]\n \tMethod [method_or_constructor_declaration]\n \tMethods [repeat method_or_constructor_declaration]\n    deconstruct Method\n\t_ [id] _ [xotcl_proc_scope] _ [id] '{ VarIds [repeat id] '} _ [tcl_cmd_set]\n    by\n\tMethod [transformJavaVar2TclVar VarIds]\n\tMethods \nend rule\n\nrule transformDotRefs\n    replace [program]\n\tP [program]\n    where \n\tP [?transformRefMethodFirst1]\n\t  [?transformRefMethodFirst1In]\n\t  \n\t  [?transformRefMethodFirst]\n\t  [?transformRefMethod]\n\t  [?transformRefIdFirst]\n\t  [?transformRefId]\n\t  [?transformRefArray]\n    by \n\tP  [transformRefMethodFirst1]\n\t   [transformRefMethodFirst1In]\n  \n\t   [transformRefMethodFirst]\n\t   [transformRefMethod]\n\n\t   [transformRefIdFirst]\n\t   [transformRefId]\n\t   [transformRefArray] \nend rule\n\nrule varRef2TclRef\n    replace $ [reference]\n\tRef [reference]\n    construct RefNew [reference]\n\tRef [varRef2TclClassVar Ref]\n\t    [varRef2TclClassStaticVar Ref]\n\t    [varRef2TclVarSimple Ref]\n\t    [varRefThis2TclThis Ref]\n    by\n\tRefNew\nend rule\n\nrule untransformForUpdate\n    replace $ [tcl_for_cmd]\n\t'for Init [tcl_cmd_set] Cond [tcl_cmd_set] Upd [tcl_cmd_set] Block [tcl_block]\n    by\n\t'for Init Cond Upd [untransformForUpdateMores] Block \nend rule\n\nrule splitVarDeclarations\n    replace [repeat class_body_declaration]\n\tModr [repeat modifier] TypSpec [type_specifier] VarDecl [variable_declarator] ', VarDeclRest [list variable_declarator+] '; \n\tRest [repeat class_body_declaration]\n    by\n\tModr TypSpec VarDecl ';\n\tModr TypSpec VarDeclRest ';\n\tRest \nend rule\n\nrule splitLocalVarDeclarations\n    replace [repeat declaration_or_statement]\n\tModr [repeat modifier] TypSpec [type_specifier] VarDecl [variable_declarator] ', VarDeclRest [list variable_declarator+] '; \n\tRest [repeat declaration_or_statement]\n    by\n\tModr TypSpec VarDecl ';\n\tModr TypSpec VarDeclRest ';\n\tRest\nend rule\n\nrule removeEmptyLocalVarDeclarations\n    replace [repeat declaration_or_statement]\n\t_ [repeat modifier] _ [type_specifier] _ [id] _ [opt generic_parameter] '; \n\tRest [repeat declaration_or_statement]\n    by\n\tRest\nend rule\n\nrule sortAllVarsUp\n    replace [repeat class_body_declaration]\n\tNonVar [class_body_declaration_wo_field]\n\tVar [field_declaration]\n\tRest [repeat class_body_declaration]\n    by\n\tVar NonVar Rest\nend rule\n\nrule transformBooleanTrue\n    replace [literal]\n\t'true\n    by\n\t1\nend rule\n\nrule transformBooleanFalse\n    replace [literal]\n\t'false\n    by\n\t0\nend rule\n\nfunction expandJavaSwitchAlts\n    replace * [repeat switch_alternative]\n\tAlts [repeat switch_alternative]\n    deconstruct * Alts\n\tLastAlt [switch_alternative]\n    construct AltsLen [number]\n\t_ [length Alts] [- 1]\n    construct FirstAlts [repeat switch_alternative]\n\tAlts [head AltsLen]\n    construct LastAltConverted [switch_alternative]\n\tLastAlt [processJavaSwitchAltEmptyEntry] [processJavaSwitchAltCommentEntry] [processJavaSwitchAltEntry] \n    by\n\tFirstAlts [expandJavaSwitchAlts] [. LastAltConverted]\nend function\n\nrule convertSwitchDefaultLabel\n    replace $ [switch_alternative]\n\t'default ': Decls [repeat declaration_or_statement]\n    by\n\t'case ''default' ': Decls\nend rule\n\nrule removeSwitchBreak\n    replace [repeat declaration_or_statement]\n\t'break '; Decls [repeat declaration_or_statement]\n    by\n\tDecls\nend rule\n\nfunction convertJavaSelfAssPlus\n    replace [assignment_expression]\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct Op\n\t'+=\n    by\n\tUna '= Una '+ '( AssExp ')\nend function\n\nfunction convertJavaSelfAssMinus\n    replace [assignment_expression]\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct Op\n\t'-=\n    by\n\tUna '= Una '- '( AssExp ')\nend function\n\nfunction convertJavaSelfAssDiv\n    replace [assignment_expression]\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct Op\n\t'/=\n    by\n\tUna '= Una '/ '( AssExp ')\nend function\n\nfunction convertJavaSelfAssMul\n    replace [assignment_expression]\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct Op\n\t'*=\n    by\n\tUna '= Una '* '( AssExp ')\nend function\n\nfunction convertJavaSelfAssDivLeft\n    replace [assignment_expression]\n\tUna [unary_expression] Op [assignment_operator] AssExp [assignment_expression] \n    deconstruct Op\n\t'%=\n    by\n\tUna '= Una '% '( AssExp ')\nend function\n\nfunction localVarDecl2AssignmentExp\n    replace [declaration_or_statement]\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t'= Exp [conditional_expression] ';\n    construct Ass [assignment_expression]\n\tId '= Exp \n    by\n\tAss ';\nend function\n\nfunction localVarDecl2AssignmentArray\n    replace [declaration_or_statement]\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t'= Exp [array_initializer] ';\n    construct Ass [assignment_expression]\n\tId '= Exp \n    by\n\tAss ';\nend function\n\nfunction expandPrintlnParams\n    replace [repeat tcl_expr_more]\n\tMores [repeat tcl_expr_more]\n    export PutsUnas [repeat unary_expression]\n\t_\n    construct Dumb [repeat tcl_expr_more]\n\tMores [collectUnaries]\n    import PutsUnas\n\n    construct Len [number]\n\t_ [length PutsUnas]\n    where \n\tLen [> 1]\n    construct Cmds [repeat tcl_expr_more]\n\t_ [addUnaryToTclExprs each PutsUnas]\n    by\n\t'[ 'concat Cmds ']\nend function\n\nfunction pkgRef2TclId Ref [reference]\n    replace [repeat tcl_id]\n\t_ [repeat tcl_id]\n    construct RefIds [repeat id]\n\t_ [^ Ref]\n    deconstruct RefIds\n\tFirstId [id] RestId [repeat id]\n    construct TclIdHead [tcl_id_head]\n\tFirstId\n    construct TclIdPart [repeat tcl_id_part]\n\t_ [addTclIdPart each RestId]\n    by\n\tTclIdHead TclIdPart\nend function\n\nrule removeNonIdRef\n    replace [repeat reference]\n\tFirst [reference] Rest [repeat reference]\n    deconstruct First\n\tPrima [primitive_type] _ [repeat dimension] _ [repeat component]\n    by\n\tRest\nend rule\n\nrule transformSuperInConstructors\n    replace $ [constructor_declaration]\n\tConstructor [constructor_declaration]\n    by\n\tConstructor [addSuperInConstructorIfAbsent Constructor]\n\t\t    [transformSuperInConstructor Constructor]\n\t\t    [removeSuperInConstructor]\nend rule\n\nrule transformThisInConstructor \n    replace $ [constructor_declaration]\n\tConstructor [constructor_declaration]\n    by\n\tConstructor [transformThisStatement Constructor]\nend rule\n\nrule transformVarAssignment\n    replace [declaration_or_statement]\n\t Ref [reference] '= Butt [assignment_expression] ';\n    construct TclCmd [repeat tcl_expr_more]\n\t_ [transformJavaLocalScopeVar Ref] \n\n\t  [transformJavaClassVar Ref] \n\t  [transformJavaClassStaticVar Ref] \n\n\t  [transformJavaThisVar Ref] \n\t  [transformJavaThisStaticVar Ref] \n\n\t  [complexRefAssignment Ref]\n\t  [assignToArrayRef Ref]\n    construct TclLit [tcl_expr_more]\n\t_ [transformArithAssExp Butt]\n\t  [transformLiteralAssExp Butt]\n\t  [transformRefAssExp Butt]\n\t  [transformNewAssExp Butt]\n    by\n\tTclCmd [. TclLit] '%\nend rule\n\nrule transformExceptions\n    replace $ [program]\n\tP [program]\n    by\n\tP [transformThrowStmt]\n\t  [transformTryCatch]\nend rule\n\nrule transformConditionalStatements\n    replace $ [program]\n\tP [program]\n    by\n\tP [transformIfElse]\n\t  [transformIf]\n%\t  [transformCondChoice]\n\t  [transformWhile]\n\t  [transformSwitch]\n\t  [transformFor]\n\t  [transformForeach]\nend rule\n\nrule convertUnaryOpInMultiplicative\n    replace $ [multiplicative_expression]\n\tMulti [multiplicative_expression]\n    deconstruct Multi\n\tRef [id] Op [pre_inc_dec]\n    by\n\tMulti [convertUnaryOpMultiMy]\n\t      [convertUnaryOpMultiClass]\n\t      [convertUnaryOpMultiLocal]\nend rule\n\nrule convertUnaryOpFirst\n    replace $ [declaration_or_statement]\n\tDecl [declaration_or_statement]\n    deconstruct Decl\n\tRef [id] Op [pre_inc_dec] ';\n    by\n\tDecl [convertUnaryOpFirstMy]\n\t     [convertUnaryOpFirstClass]\n\t     [convertUnaryOpFirstLocal]\nend rule\n\nrule transformNewExpr\n    replace $ [multiplicative_expression]\n\tNew [class_instance_creation_expression]\n    construct Cmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    deconstruct Cmd\n\t'[ Expr [tcl_expr] ']\n    by\n\t'[ Expr ']\nend rule\n\nfunction convertNewClassInstance New [class_instance_creation_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct New\n\t'new JClassName [reference] '( Args [list argument] ') _ [opt class_body]\n    construct TmpName [repeat tcl_id]\n\t_ [pkgRef2TclId JClassName]\n    deconstruct * TmpName\n\tClassName [tcl_id]\n    construct Args1 [repeat expression]\n\t_ [argumentToExpression each Args]\n    construct TclArgs [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args1]\n    by\n\t'[ ClassName ClassName TclArgs ']\nend function\n\nrule removeStaticField\n    replace [repeat field_declaration]\n\tFirst [field_declaration] Rest [repeat field_declaration]\n    where \n\tFirst [is_static]\n    by\n\tRest\nend rule\n\nrule removeNonStaticField\n    replace [repeat field_declaration]\n\tFirst [field_declaration] Rest [repeat field_declaration]\n    where not\n\tFirst [is_static]\n    by\n\tRest\nend rule\n\nrule transformStaticMethod2Proc\n    replace  [repeat method_or_constructor_declaration]\n\tMethod [method_or_constructor_declaration] \n\tMethods [repeat method_or_constructor_declaration]\n    where not\n\tMethod [is_static]\n    by\n\tMethods\nend rule\n\nrule transformNonStaticMethod2Proc\n    replace  [repeat method_or_constructor_declaration]\n\tMethod [method_or_constructor_declaration] \n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tMethod [is_static]\n    by\n\tMethods\nend rule\n\nrule transformNonStaticMethodHeader ClassName [id]\n    replace [method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n    where not\n\tJModifiers [is_synchronized]\n    where not\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    by\n\tClassName 'instproc JName '{ ParamsNames '}  Body\nend rule\n\nrule transformStaticMethodHeader ClassName [id]\n    replace [method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n    where not\n\tJModifiers [is_synchronized]\n    where\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    by\n\tClassName 'proc JName '{ ParamsNames '}  Body\nend rule\n\nrule transformSynchroNonStaticMethodHeader ClassName [id]\n    replace [repeat method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tJModifiers [is_synchronized]\n    where not\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n    construct JSynchName [id]\n\tJName [_ 'synchrobaby]\n    construct MutexName [id]\n\tClassName [_ JName] [_ 'mutex]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'thread::mutex 'lock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'set 'cought 0 '%\n\t'#call the real method implementation\n\t'if '{ '[ 'catch '{ 'my JSynchName ParamsAsVars '} 'result '] '} '{\n\t'set 'cought 1 '%\n\t'} \n\t'thread::mutex 'unlock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'#transfer exception to the upper level\n\t'if '{ '$cought '} '{ 'error '$result '} \n\t'}\n    by\n\tClassName 'instproc JName '{ ParamsNames '} ProcBody \n\tClassName 'instproc JSynchName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformSynchroStaticMethodHeader ClassName [id]\n    replace [repeat method_or_constructor_declaration]\n\tJModifiers [repeat modifier] _ [type_specifier] \n\tJName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') _ [repeat dimension]    \n\t_ [opt throws] Body [block]\n\tMethods [repeat method_or_constructor_declaration]\n    where \n\tJModifiers [is_synchronized]\n    where\n\tJModifiers [is_static]\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n    construct JSynchName [id]\n\tJName [_ 'synchrobaby]\n    construct MutexName [id]\n\tClassName [_ JName] [_ 'mutex]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'thread::mutex 'lock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'set 'cought 0 '%\n\t'#call the real method implementation\n\t'if '{ '[ 'catch '{ 'my JSynchName ParamsAsVars '} 'result '] '} '{\n\t'set 'cought 1 '%\n\t'} \n\t'thread::mutex 'unlock '[ 'tsv::get 'mutexes MutexName '] '%\n\t'#transfer exception to the upper level\n\t'if '{ '$cought '} '{ 'error '$result '} \n\t'} \n    by\n\tClassName 'proc JName '{ ParamsNames '} ProcBody \n\tClassName 'proc JSynchName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformConstructorHeader\n    replace [repeat method_or_constructor_declaration]\n \tConstructor [constructor_declaration]\n \tMethods [repeat method_or_constructor_declaration]\n    deconstruct Constructor\n\tJModifiers [repeat modifier] \n\tJClassName [id] _ [opt generic_parameter] '( Parameters [list formal_parameter] ') \n\t_ [opt throws] Body [block]\n\n    construct Params [repeat variable_name]\n\t_ [^ Parameters]\n    construct ParamsNames [repeat id]\n\t_ [^ Params]\n    construct ParamsAsVars [repeat tcl_expr_more]\n\t_ [transformId2TclVar each ParamsNames]\n\n    construct ParamsString [id]\n\t_ [buildParameterTypeList each Parameters]\n    construct XNew [id]\n\t_ [+ JClassName] \n    construct XNewBody [id]\n\t_ [+ JClassName] [+ \"_body\"]\n    construct XNewName [id]\n\tXNew [+ ParamsString]\n    construct XNewBodyName [id]\n\tXNewBody [+ ParamsString]\n    construct ProcBody [tcl_block]\n\t'{ \n\t'#create new object\n\t'set 'obj '[ JClassName 'new '] '%\n\t'#call the constructor\n\t'$obj XNewBodyName ParamsAsVars '%\n\t'#return new object after constructor's work is done\n\t'return '$obj '%\n\t'} \n    by\n\tJClassName 'proc XNewName '{ ParamsNames '} ProcBody\n\tJClassName 'instproc XNewBodyName '{ ParamsNames '}  Body\n\tMethods\nend rule\n\nrule transformJavaVar2TclVar VarIds [repeat id]\n    replace $ [reference]\n\tId [id] _ [repeat dimension] Comp [repeat component]\n    construct Len [number]\n\t_ [length Comp]\n    where \n\tLen [= 0]\n    where\n\tId [= each VarIds]\n    by\n\t'$ Id\nend rule\n\nrule transformRefMethodFirst1\n    replace [declaration_or_statement]\n\tId [id] _ [repeat dimension] Comps [repeat component] ';\n    construct CompsLen [number]\n\t_ [length Comps]\n    where \n\tCompsLen [= 1]\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'my Id Exps '%\nend rule\n\nrule transformRefMethodFirst1In\n    replace [reference]\n\tId [id] _ [repeat dimension] Comps [repeat component] \n    construct CompsLen [number]\n\t_ [length Comps]\n    where \n\tCompsLen [= 1]\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'[ 'my Id Exps '] \nend rule\n\nrule transformRefMethodFirst\n    replace [declaration_or_statement]\n\tId [id] Dims [repeat dimension] Comps [repeat component] ';\n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct CompsLenFinal [number]\n\t_ [length Comps] [- 2]\n    construct NewCompsTmp [repeat component]\n\tComps [head CompsLen]\n    construct NewComps [repeat component]\n\tComps [head CompsLenFinal]\n    construct RefIds [repeat id]\n\t_ [^ NewCompsTmp]\n    deconstruct * RefIds\n\tMethodName [id]\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\tId [this2my] Dims NewComps MethodName Exps '%\nend rule\n\nrule transformRefMethod\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\t'( MethArgs [list argument] ')\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct CompsLenFinal [number]\n\t_ [length Comps] [- 2]\n    construct NewCompsTmp [repeat component]\n\tComps [head CompsLen]\n    construct NewComps [repeat component]\n\tComps [head CompsLenFinal]\n    construct RefIds [repeat id]\n\t_ [^ NewCompsTmp]\n    deconstruct * RefIds\n\tMethodName [id]\n    construct Args [repeat expression]\n\t_ [argumentToExpression each MethArgs]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    by\n\t'[ Id [this2my] Dims NewComps MethodName Exps '] \nend rule\n\nrule transformRefIdFirst\n    replace [declaration_or_statement]\n\tId [id] _ [repeat dimension] Comps [repeat component] '= AssExp [assignment_expression] ';\n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    by\n\tId NewComps 'set VarId AssExp '%\nend rule\n\nrule transformRefId\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps\n    by\n\t'[ NewRef 'set VarId ']\nend rule\n\nrule transformRefArray\n    replace [reference]\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n    deconstruct * Comps\n\tDim [dimension]\n\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n\n\n    deconstruct * NewComps\n\t'. VarId [id]\n    construct CompsLen2 [number]\n\t_ [length NewComps] [- 1]\n    construct DimComp [component]\n\tDim\n    construct NewComps2 [repeat component]\n\tNewComps [head CompsLen2] % [. DimComp]\n\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps2 \n\n    construct TmpDims [repeat dimension]\n\tDim\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim TmpDims]\n\n    by\n\t'[ NewRef 'set VarId TclDim ']\nend rule\n\nfunction varRef2TclClassVar Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where \n\tId [is_class_var]\n    by\n\t'[ 'my 'set Id TclDim ']\nend function\n\nfunction varRef2TclClassStaticVar Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ '[ 'my 'class '] 'set Id TclDim ']\nend function\n\nfunction varRef2TclVarSimple Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [reference]\n\t_ [reference]\n    where all \n\tId [>= 'a] [<= 'z]\n    where not\n\tId [is_staticclass_var]\n\t   [is_class_var]\n    deconstruct not Id\n\t'my\n    by\n\t'$ Id TclDim\nend function\n\nfunction varRefThis2TclThis Ref [reference]\n    deconstruct Ref\n\t'this\n    replace [reference]\n\t_ [reference]\n    by\n\t'[ 'self ']\nend function\n\nrule untransformForUpdateMores\n%    skipping [tcl_expr_more]\n    replace $ [tcl_expr]\n\tExp [tcl_expr]\n    deconstruct Exp\n\tRef [reference]\n    deconstruct Ref\n\t'[ More [tcl_expr] ']\n    by\n\tMore\nend rule\n\nfunction processJavaSwitchAltEntry\n    replace [switch_alternative]\n\tLabel [switch_label] Decls [repeat declaration_or_statement+] \n    export SwitchAltDecls [repeat declaration_or_statement+]\n\tDecls \n    by\n\tLabel Decls \nend function\n\nfunction processJavaSwitchAltCommentEntry\n    replace [switch_alternative]\n\tLabel [switch_label] Decls [repeat declaration_or_statement+]\n    deconstruct Decls\n\t_ [comment_NL]\n    import SwitchAltDecls [repeat declaration_or_statement+]\n    by\n\tLabel Decls [. SwitchAltDecls]\nend function\n\nfunction processJavaSwitchAltEmptyEntry\n    replace [switch_alternative]\n\tLabel [switch_label] \n    import SwitchAltDecls [repeat declaration_or_statement+]\n    by\n\tLabel SwitchAltDecls \nend function\n\nfunction addUnaryToTclExprs Una [unary_expression]\n    replace [repeat tcl_expr_more]\n\tMores [repeat tcl_expr_more]\n    construct Cmd [tcl_expr_more]\n\tUna\n    by\n\tMores [. Cmd]\nend function\n\nrule collectUnaries\n    skipping [unary_expression]\n    replace $ [unary_expression]\n\tUna [unary_expression]\n    import PutsUnas [repeat unary_expression]\n    construct NewPutsUnas [repeat unary_expression]\n\tPutsUnas [. Una]\n    export PutsUnas\n\tNewPutsUnas\n    by\n\tUna\nend rule\n\nfunction addTclIdPart Id [id]\n    replace [repeat tcl_id_part]\n\tParts [repeat tcl_id_part]\n    construct Part [tcl_id_part]\n\t':: Id\n    by\n\tParts [. Part]\nend function\n\nrule addSuperInConstructorIfAbsent Constructor [constructor_declaration] \n    replace $ [constructor_body]\n\t'{ Decls [repeat declaration_or_statement] '}\n    where not\n\tDecls [?transformSuperInConstructor Constructor]\n    by\n\t'{\n\t'super '( ') ';\n\tDecls '}\nend rule\n\nrule transformSuperInConstructor Constructor [constructor_declaration] \n    replace $ [declaration_or_statement]\n\t'super MethArg [method_argument] ';\n    import JClassOrigin [class_declaration]\n    deconstruct JClassOrigin\n\t_ [repeat modifier] 'class _ [class_name] \n\tExtends [opt extends_clause] \n\t_ [opt implements_clause] _ [class_body]\n    construct ExtendClasses [repeat reference]\n\t_ [^ Extends]\n    construct Parents [repeat reference]\n\tExtendClasses [removeNonIdRef]\n    deconstruct * ExtendClasses \n\tParentName [id]\n    construct Args [repeat expression]\n\t_ [^ MethArg]\n    construct VarIds [repeat id]\n\t_ [^ Args]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    construct TypeString [id]\n\t_ [buildVarsTypeList4Constructor Constructor each VarIds]\n    construct XNewName [id]\n\t_ [+ ParentName] [+ \"_body\"] [+ TypeString]\n    by\n\t'my XNewName Exps '% \nend rule\n\nrule removeSuperInConstructor \n    replace [repeat declaration_or_statement]\n\t'super MethArg [method_argument] ';\n\tDecls [repeat declaration_or_statement]\n    by\n\tDecls\nend rule\n\nrule transformThisStatement Constructor [constructor_declaration] \n    replace $ [declaration_or_statement]\n\t'this MethArg [method_argument] ';\n    deconstruct Constructor\n\t_ [repeat modifier] ClassName [id] _ [opt generic_parameter]\n\t'( _ [list formal_parameter] ')  _ [opt throws] _ [constructor_body]\n    construct Args [repeat expression]\n\t_ [^ MethArg]\n    construct VarIds [repeat id]\n\t_ [^ Args]\n    construct Exps [repeat tcl_expr_more]\n\t_ [expressionSeq2TclExprMoreSeq Args]\n    construct TypeString [id]\n\t_ [buildVarsTypeList4Constructor Constructor each VarIds]\n    construct XNewName [id]\n\t_ [+ ClassName] [+ \"_body\"] [+ TypeString]\n    by\n\t'my XNewName Exps '% \nend rule\n\nfunction transformJavaLocalScopeVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    by\n\t'set Id TclDim\nend function\n\nfunction transformJavaClassVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    where \n\tId [is_class_var]\n    by\n\t'my 'set Id TclDim\nend function\n\nfunction transformJavaClassStaticVar Ref [reference]\n    deconstruct Ref\n\tId [id]  Dims [repeat dimension]\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim Dims]\n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ 'my 'class '] 'set Id TclDim\nend function\n\nfunction transformJavaThisVar Ref [reference]\n    deconstruct Ref\n\t'this '. Id [id] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_class_var]\n    by\n\t'my 'set Id \nend function\n\nfunction transformJavaThisStaticVar Ref [reference]\n    deconstruct Ref\n\t'this '. Id [id] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    where \n\tId [is_staticclass_var]\n    by\n\t'[ 'my 'class '] 'set Id \nend function\n\nfunction complexRefAssignment Ref [reference]\n    deconstruct Ref\n\tId [id] Dim [repeat dimension] Comps [repeat component+] \n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    construct ExprLen [number]\n\t_ [length Expr]\n    where not\n\tExprLen [> 0]\n    deconstruct * Comps\n\t'. VarId [id]\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n    construct NewRef [reference]\n\tId Dim NewComps\n    by\n\tNewRef 'set VarId \nend function\n\nfunction assignToArrayRef Ref [reference]\n    deconstruct Ref\n\tId [id] Dims [repeat dimension] Comps [repeat component] \n\n    replace [repeat tcl_expr_more]\n\tExpr [repeat tcl_expr_more]\n    construct ExprLen [number]\n\t_ [length Expr]\n    where not\n\tExprLen [> 0]\n\n    deconstruct * Comps\n\tDim [dimension]\n\n    construct CompsLen [number]\n\t_ [length Comps] [- 1]\n    construct NewComps [repeat component]\n\tComps [head CompsLen]\n\n\n    deconstruct * NewComps\n\t'. VarId [id]\n    construct CompsLen2 [number]\n\t_ [length NewComps] [- 1]\n    construct DimComp [component]\n\tDim\n    construct NewComps2 [repeat component]\n\tNewComps [head CompsLen2] % [. DimComp]\n\n    construct NewRef [reference]\n\tId [this2my] Dims NewComps2 \n\n    construct TmpDims [repeat dimension]\n\tDim\n    construct TclDim [repeat tcl_array_dimension]\n\t_ [dim2TclDim TmpDims]\n\n    by\n        NewRef 'set VarId TclDim \nend function\n\nfunction transformArithAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    where\n\tButt [is_arithmetic]\n    construct TclRef [tcl_expr_more]\n\t'[ 'expr '{ Butt '} ']\n    by\n\tTclRef\nend function\n\nfunction transformLiteralAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tLiteral [literal]\n    by\n\tLiteral\nend function\n\nfunction transformRefAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tRef [reference]\n    by\n\tRef\nend function\n\nfunction transformNewAssExp Butt [assignment_expression]\n    replace [tcl_expr_more]\n\t_ [tcl_expr_more] \n    deconstruct Butt\n\tNew [class_instance_creation_expression]\n    construct NewCmd [tcl_cmd]\n\t_ [convertNewClassInstance New]\n    by\n\tNewCmd\nend function\n\nrule transformTryCatch\n    replace $ [declaration_or_statement]\n\t'try Block [block] Catches [repeat catch_clause] _ [opt finally_clause]\n    deconstruct Block\n\t'{ BlockStmts [repeat declaration_or_statement] '}\n    construct CatchesStmts [repeat declaration_or_statement]\n\t_ [^ Catches]\n    construct CatchBlock [xotcl_proc_body]\n\tCatchesStmts\n    by\n\t'if '{ '[ 'catch '{ BlockStmts '} 'result '] '} '{\n\tCatchBlock\n\t'} \nend rule\n\nrule transformThrowStmt\n    replace $ [declaration_or_statement]\n\t_ [throw_statement]\t\n    by\n\t'error '$result\nend rule\n\nrule transformIf\n    replace [declaration_or_statement]\n\t'if '( IfExpr [expression] ') _ [repeat comment_NL]\n\tStmt [statement] \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct IfTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    construct TclIf [tcl_if_cmd]\n\t'if '{ IfExpr '} IfTclBlock\n    by\n\tTclIf\nend rule\n\nrule transformIfElse\n    replace [declaration_or_statement]\n\t'if '( IfExpr [expression] ') IfStmt [statement] _ [repeat comment_NL]\n\t'else ElseStmt [statement]\n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct IfTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok IfStmt] \n\t\t      [statementBlockToTclBlock IfStmt]\n    construct ElseTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok ElseStmt] \n\t\t      [statementBlockToTclBlock ElseStmt]\n    deconstruct IfTclBlock\n\t'{ IfBody [opt xotcl_proc_body] '}\n    construct TclIf [tcl_if_cmd]\n\t'if '{ IfExpr '} '{ IfBody '} 'else ElseTclBlock\n    by\n\tTclIf\nend rule\n\nrule transformCondChoice\n    replace $ [assignment_expression]\n\tCond [conditional_expression]\n    deconstruct Cond\n\tUna [unary_expression] '? Exp [expression] ': CondChExp [conditional_expression]\n    by\n\t'[ 'expr '{ Una '? Exp  ': CondChExp '} ']\nend rule\n\nrule transformWhile\n    replace [declaration_or_statement]\n\t'while '( Expr [expression] ') Stmt [statement] \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct WhileTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    construct TclWhile [tcl_while_cmd]\n\t'while '{ Expr '}  WhileTclBlock\n    by\n\tTclWhile\nend rule\n\nrule transformSwitch\n    replace [declaration_or_statement]\n\t'switch '( Expr [expression] ') '{ JAlts [repeat switch_alternative] '}\n    construct Alts [repeat tcl_switch_entry]\n\t_ [transformSwitchAlternatives each JAlts] \n    construct TclSwitch [tcl_switch_cmd]\n\t'switch Expr '{ Alts '} \n    by\n\tTclSwitch\nend rule\n\nrule transformFor\n    replace [declaration_or_statement]\n\t'for '( ForInit [for_init] \n\tForExpr [opt expression] '; \n\tForUpd [list expression] ') \n\tStmt [statement] \n    construct ForUpdSeq [repeat expression]\n\t_ [. each ForUpd]\n    construct TclCmdLists [repeat tcl_cmd_list]\n\t_ [expressionListToTclCmdList ForUpdSeq] \n\t  [transformVarAssignmentFor]\n    construct TclForInit [repeat tcl_cmd_list]\n\t_ [transformForInitStmt1 ForInit] \n\t  [transformForInitStmt2 ForInit]\n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct ForTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    by\n\t'for '{ TclForInit '} \n\t'{ ForExpr '} '{ TclCmdLists '}\n\tForTclBlock\nend rule\n\nrule transformForeach\n    replace [declaration_or_statement]\n\t'for '( \n\t%for_in_init\n\t_ [repeat modifier] _ [type_specifier] Id [id] _ [opt generic_parameter] _ [repeat dimension]\n\t': Expr [expression] ')\n\t\tStmt [statement]        \n    construct EmptyTclBlock [tcl_block]\n\t'{ '}\n    construct ForTclBlock [tcl_block]\n\tEmptyTclBlock [statementOneDeclToTclBlcok Stmt] \n\t\t      [statementBlockToTclBlock Stmt]\n    by\n\t'foreach '{ Id '} '{ Expr '}\n\tForTclBlock\nend rule\n\nrule convertUnaryOpMultiLocal\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpMultiMy\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    where \n\tRef [is_class_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'my 'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpMultiClass\n    replace $ [multiplicative_expression]\n\tRef [id] Op [pre_inc_dec] \n    where \n\tRef [is_staticclass_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'[ 'my 'class '] 'incr Ref Minus\n    by\n\t'[ NewE '] \nend rule\n\nrule convertUnaryOpFirstLocal\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nrule convertUnaryOpFirstMy\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    where \n\tRef [is_class_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'my 'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nrule convertUnaryOpFirstClass\n    replace $ [declaration_or_statement]\n\tRef [id] Op [pre_inc_dec] ';\n    where \n\tRef [is_staticclass_var]\n    construct Minus [repeat tcl_expr_more]\n\t_  [makeDecrCmdTail Op]\n    construct NewE [tcl_expr]\n\t'[ 'my 'class '] 'incr Ref Minus\n    by\n\tNewE '%\nend rule\n\nfunction expressionSeq2TclExprMoreSeq Expressions [repeat expression]\n    replace [repeat tcl_expr_more]\n\tEMore [repeat tcl_expr_more]\n    deconstruct Expressions\n\tExpr [expression] Exprs [repeat expression]\n    construct TclEMore [repeat tcl_expr_more]\n\tExpr\n    by\n\tEMore [. TclEMore] [expressionSeq2TclExprMoreSeq Exprs]\nend function\n\nfunction argumentToExpression Argument [argument]\n    replace [repeat expression]\n\tExps [repeat expression]\n    deconstruct Argument\n\tExp [expression]\n    by\n\tExps [. Exp]\nend function\n\nfunction is_static \n    match * [modifier]\n\t'static\nend function\n\nfunction is_synchronized\n    match * [modifier]\n\t'synchronized\nend function\n\nfunction transformId2TclVar Id [id]\n    replace [repeat tcl_expr_more]\n\tCmds [repeat tcl_expr_more]\n    construct Var [tcl_expr_more]\n\t'$ Id\n    by\n\tCmds [. Var]\nend function\n\nfunction buildParameterTypeList Parameter [formal_parameter]\n    replace [id]\n\tParams [id] \n    construct TypeName [id]\n\t_ [extractPrimitiveTypeName Parameter]\n\t  [extractReferenceTypeName Parameter]\n    by\n\tParams [_ TypeName]\nend function\n\nfunction this2my \n    replace [id]\n\t'this\n    by\n\t'my\nend function\n\nfunction dim2TclDim Dims [repeat dimension]\n    construct DimLen [number]\n\t_ [length Dims]\n    where \n\tDimLen [= 1]\n    deconstruct Dims\n\tDim [dimension] _ [repeat dimension]\n    deconstruct Dim\n\t'[ Expr [expression] ']\n    replace [repeat tcl_array_dimension]\n\t_ [repeat tcl_array_dimension]\n    by\n\t'( Expr ')\nend function\n\nfunction is_class_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_nonstatic_var Id]\nend function\n\nfunction is_staticclass_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_static_var Id]\nend function\n\nfunction buildVarsTypeList4Constructor Constructor [constructor_declaration] VarId [id]\n    replace [id]\n\tIds [id]\n    construct Tmp1 [constructor_declaration]\n\tConstructor [findVarTypeInConstructorParams VarId]\n    import TypeName [id]\n    by\n\tIds [+ TypeName]\nend function\n\nrule is_arithmetic\n    match $ [any]\n\tAny [any]\n    where \n\tAny [istype 'add_op]\n\t    [istype 'mult_op]\n\t    [istype 'unary_op]\n\t    [istype 'or_conditional_and_expression]\n\t    [istype 'and_inclusive_or_expression]\n\t    [istype 'or_exclusive_or_expression]\n\t    [istype 'or_and_expression]\n\t    [istype 'and_equality_expression]\n\t    [istype 'equality_op]\n\t    [istype 'relational_op]\n\t    [istype 'shif_op]\n\t    [istype 'conditional_choice]\nend rule\n\nfunction statementOneDeclToTclBlcok Stmt [statement]\n    replace [tcl_block]\n\t_ [tcl_block]\n    deconstruct not Stmt\n\t_ [block]\n    construct Decl [declaration_or_statement]\n\tStmt\n    by\n\t'{ Decl '}\nend function\n\nfunction statementBlockToTclBlock Stmt [statement]\n    replace [tcl_block]\n\t_ [tcl_block]\n    deconstruct Stmt\n\t'{ Decls [repeat declaration_or_statement] '}\n    by\n\t'{ Decls '}\nend function\n\nfunction transformSwitchAlternatives JAlt [switch_alternative]\n    replace [repeat tcl_switch_entry]\n\tEntries [repeat tcl_switch_entry]\n    deconstruct JAlt\n\t'case Label [constant_expression] ': Decls [repeat declaration_or_statement]\n    construct SwitchLabel [tcl_cmd]\n\t_ [switchLabelConvertNum Label] [switchLabelConvertChar Label]\n    construct Entry [tcl_switch_entry]\n\tSwitchLabel '{ Decls '} \t\n    by\n\tEntries [. Entry]\nend function\n\nfunction expressionListToTclCmdList Expressions [repeat expression]\n    replace [repeat tcl_cmd_list]\n\t_  [repeat tcl_cmd_list]\n    deconstruct Expressions\n\tExpr [expression] Exprs [repeat expression]\n    construct TclCmdList [tcl_cmd_list]\n\tExpr\n    by\n\tTclCmdList [addExpToTclCmdList each Exprs]\nend function\n\nfunction transformForInitStmt1 ForInit [for_init]\n    deconstruct ForInit\n\tExprs [list expression] ';\n    replace [repeat tcl_cmd_list]\n\t_ [repeat tcl_cmd_list]\n    construct ExprSeq [repeat expression]\n\t_ [. each Exprs]\n    by\n\t_ [expressionListToTclCmdList ExprSeq] [transformVarAssignmentFor]\nend function\n\nfunction transformForInitStmt2 ForInit [for_init]\n    deconstruct ForInit\n\tLocalDecl [declaration_or_statement] \n    construct TmpDecls [repeat declaration_or_statement]\n\tLocalDecl\n    construct TmpDecls2 [repeat declaration_or_statement]\n\tTmpDecls [splitLocalVarDeclarations] [localVarDecl2Assignment]\n    deconstruct TmpDecls2\n\tDecl1 [declaration_or_statement] _ [repeat declaration_or_statement]\n    replace [repeat tcl_cmd_list]\n\t_ [repeat tcl_cmd_list]\n    by\n%\tLocalDecl\n\tTmpDecls2\nend function\n\nrule transformVarAssignmentFor\n    replace [repeat tcl_expr_more]\n\t Ref [reference] '= Butt [assignment_expression] \n    construct TclCmd [repeat tcl_expr_more]\n\t_ [transformJavaLocalScopeVar Ref] \n\n\t  [transformJavaClassVar Ref] \n\t  [transformJavaClassStaticVar Ref] \n\n\t  [transformJavaThisVar Ref] \n\t  [transformJavaThisStaticVar Ref] \n\n\t  [complexRefAssignment Ref]\n\t  [assignToArrayRef Ref]\n    construct TclLit [tcl_expr_more]\n\t_ [transformArithAssExp Butt]\n\t  [transformLiteralAssExp Butt]\n\t  [transformRefAssExp Butt]\n\t  [transformNewAssExp Butt]\n    by\n\tTclCmd [. TclLit] \nend rule\n\nfunction makeDecrCmdTail Op [pre_inc_dec]\n    deconstruct Op\n\t'--\n    replace [repeat tcl_expr_more]\n\t_ [repeat tcl_expr_more]\n    construct Num [tcl_literal]\n\t-1\n    by\n\tNum\nend function\n\n\n\nfunction extractReferenceTypeName Parameter [formal_parameter]\n    replace [id]\n\t_ [id]\n    construct References [repeat reference]\n\t_ [^ Parameter]\n    deconstruct References\n\t_ [id] _ [repeat dimension] _ [repeat component]\n    construct Ids [repeat id]\n\t_ [^ References]\n    deconstruct * Ids \n\tTypeName [id]\n    by\n\t_ [+ TypeName]\nend function\n\nfunction is_nonstatic_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where\n\tField [has_var Id] \n    where not\n\tField [is_static]\nend function\n\nfunction is_static_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where all\n\tField [has_var Id] [is_static]\nend function\n\nrule findVarTypeInConstructorParams VarId [id]\n    replace $ [formal_parameter]\n\tFP [formal_parameter]\n    deconstruct FP\n\t_ [opt 'final] _ [type_specifier] _ [opt var_arg_specifier] \n\tId  [id] _ [opt generic_parameter] _ [repeat dimension]\n    where \n\tId [= VarId]\n    construct TypeName [id]\n\t_ [buildParameterTypeList FP]\n    export TypeName\n    by\n\tFP\nend rule\n\nfunction switchLabelConvertNum Label [constant_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct Label\n\tNum [number]\n    by\n\tNum\nend function\n\nfunction switchLabelConvertChar Label [constant_expression]\n    replace [tcl_cmd]\n\t_ [tcl_cmd]\n    deconstruct Label\n\tChars [charlit]\n    construct Unq [id]\n\t_ [unquote Chars]\n    by\n\tUnq\nend function\n\nfunction addExpToTclCmdList Expr [expression]\n    replace [tcl_cmd_list]\n\tTclExpr [tcl_expr] TclCmdMore [repeat tcl_cmd_more]\n    construct TclCmdMore2 [tcl_cmd_more]\n\t'; Expr\n    by\n\tTclExpr TclCmdMore [. TclCmdMore2]\nend function\n\nfunction has_var Id [id]\n    match * [variable_name]\n\tVarId [id] _ [opt generic_parameter] _ [repeat dimension]\n    where \n\tVarId [= Id]\nend function\n\n",
        "after": " package require XOTcl\nnamespace import ::xotcl::*\n\nClass create IfElseDemo_metapapa -superclass {Class} -slots {\n\n}\n\nIfElseDemo_metapapa create IfElseDemo -superclass {Class} -slots {\n\n}\n\nIfElseDemo proc main {args} {\n    set testscore 76\n    if {$testscore >= 90} {\n        set grade 'A'\n    } else {\n        if {$testscore >= 80} {\n            set grade 'B'\n        } else {\n            if {$testscore >= 70} {\n                set grade 'C'\n            } else {\n                if {$testscore >= 60} {\n                    set grade 'D'\n                } else {\n                    set grade 'F'\n                }\n            }\n        }\n    }\n    puts [concat \"Grade = \" $grade]\n}\n\n ",
        "before": "\n// Copyright (c) 1995 - 2008 Sun Microsystems, Inc.  All rights reserved.\n\nclass IfElseDemo {\n\n    public static void main (String [] args) {\n        int testscore = 76;\n        char grade;\n        if (testscore >= 90) {\n            grade = 'A';\n        } else if (testscore >= 80) {\n            grade = 'B';\n        } else if (testscore >= 70) {\n            grade = 'C';\n        } else if (testscore >= 60) {\n            grade = 'D';\n        } else {\n            grade = 'F';\n        }\n\n        System.out.println (\"Grade = \" + grade);\n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function toRight Pivot [id] N [id]\n    where not \n        N [< Pivot]\n    replace [id *] \n        List [id *]\n    by \n        N List\nend function",
        "context": "function toLeft Pivot [id] N [id]\n    where \n        N [< Pivot]\n    replace [id *] \n        List [id *]\n    by \n        N List\nend function\n\n\n\n",
        "after": " it it it it it it it it it ",
        "before": "\nit it it it it it it it "
    },
    {
        "hole_rule": "function finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function",
        "context": "function translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\n\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " {\n    Console.WriteLine (\"Hello World\");\n} ",
        "before": "\n{\n    System.out.println (\"Hello World\");\n} "
    },
    {
        "hole_rule": "function changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function",
        "context": "function translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\n\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " virtual public void show () {\n    if (bal < 0) Console.Write (\"> \");\n\n    Console.WriteLine (name + \": $\" + bal);\n}\n\n ",
        "before": "\nvoid show () {\n    if (bal < 0) System.out.print (\"> \");\n\n    System.out.println (name + \": $\" + bal);\n}\n\n "
    },
    {
        "hole_rule": "function changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function",
        "context": "function translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\n\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n",
        "after": " int [] b;\n\npublic static void Main (String [] args) {\n    bool flag = true;\n    const int y = 6;\n    double X = Math.random ();\n    int DAYS_IN_YEAR;\n    if (flag) DAYS_IN_YEAR = 366;\n    else DAYS_IN_YEAR = 365;\n\n}\n\n ",
        "before": "\nint [] b;\n\npublic static void main (String [] args) {\n    boolean flag = true;\n    final int y = 6;\n    final double X = Math.random ();\n    final int DAYS_IN_YEAR;\n    if (flag) DAYS_IN_YEAR = 366;\n    else DAYS_IN_YEAR = 365;\n\n}\n\n "
    },
    {
        "hole_rule": "function isTransient\n\tmatch [modifier]\n\t\t'transient\nend function",
        "context": "function changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\n\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " catch (IOException e) {\n    return 0;\n} ",
        "before": "\n"
    },
    {
        "hole_rule": "function isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function",
        "context": "function changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\n\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " Console.WriteLine (0x0F1234567 >> 4);\n ",
        "before": "\nSystem.out.println (0x0F1234567 >>> 4);\n "
    },
    {
        "hole_rule": "function is_staticclass_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_static_var Id]\nend function",
        "context": "function is_class_var\n    import JClassOrigin [class_declaration]\n    construct Fields [repeat field_declaration]\n\t_ [^ JClassOrigin]\n    match * [id]\n\tId [id]\n    where \n\tFields [is_nonstatic_var Id]\nend function\n\n\n\nfunction dim2TclDim Dims [repeat dimension]\n    construct DimLen [number]\n\t_ [length Dims]\n    where \n\tDimLen [= 1]\n    deconstruct Dims\n\tDim [dimension] _ [repeat dimension]\n    deconstruct Dim\n\t'[ Expr [expression] ']\n    replace [repeat tcl_array_dimension]\n\t_ [repeat tcl_array_dimension]\n    by\n\t'( Expr ')\nend function\n\nfunction is_nonstatic_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where\n\tField [has_var Id] \n    where not\n\tField [is_static]\nend function\n\nfunction is_static_var Id [id]\n    match * [field_declaration]\n\tField [field_declaration]\n    where all\n\tField [has_var Id] [is_static]\nend function\n\nfunction has_var Id [id]\n    match * [variable_name]\n\tVarId [id] _ [opt generic_parameter] _ [repeat dimension]\n    where \n\tVarId [= Id]\nend function\n\nfunction is_static \n    match * [modifier]\n\t'static\nend function\n\n",
        "after": " $result ",
        "before": "\nresult "
    },
    {
        "hole_rule": "function changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function",
        "context": "function translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\n\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " {\n    bool flag = true;\n    const int y = 6;\n    double X = Math.random ();\n    int DAYS_IN_YEAR;\n    if (flag) DAYS_IN_YEAR = 366;\n    else DAYS_IN_YEAR = 365;\n\n} ",
        "before": "\n{\n    boolean flag = true;\n    final int y = 6;\n    final double X = Math.random ();\n    final int DAYS_IN_YEAR;\n    if (flag) DAYS_IN_YEAR = 366;\n    else DAYS_IN_YEAR = 365;\n\n} "
    },
    {
        "hole_rule": "function isPrivate\n\tmatch [modifier]\n\t\t'private\nend function",
        "context": "function translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\n\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " {\n\n    public static void Main (String [] args) {\n        int r = 3;\n        Console.WriteLine (0x0F1234567 >> 4);\n        if (j == 4) {\n            if (x > 0) {\n                x *= 7;\n            } else {\n                x *= - 7;\n            }\n        }\n        int i = 3;\n        //case 1 fall through case 2, and default option has no break\n        \n        switch (i) {\n            case 0 :\n                Console.WriteLine (\"i is zero.\");\n                break;\n            case 1 :\n                Console.WriteLine (\"i is one.\");\n                goto case 2;\n            case 2 :\n                Console.WriteLine (\"i is two.\");\n                break;\n            case 3 :\n                Console.WriteLine (\"i is three.\");\n                break;\n            default :\n                Console.WriteLine (\"i is greater than 3.\");\n                break;\n        }\n        //valid in C# and Java\n        \n        switch (i) {\n            case 0 :\n            case 1 :\n            case 2 :\n            case 3 :\n            case 4 :\n                Console.WriteLine (\"i is less than 5\");\n                break;\n            case 5 :\n            case 6 :\n            case 7 :\n            case 8 :\n            case 9 :\n                Console.WriteLine (\"i is less than 10\");\n                break;\n            default :\n                Console.WriteLine (\"i is 10 or more\");\n                break;\n        }\n    }\n\n    //main\n    \n}\n\n ",
        "before": "\n{\n\n    public static void main (String args []) {\n        int r = 3;\n        System.out.println (0x0F1234567 >>> 4);\n        if (j == 4) {\n            if (x > 0) {\n                x *= 7;\n            } else {\n                x *= - 7;\n            }\n        }\n        int i = 3;\n        //case 1 fall through case 2, and default option has no break\n        \n        switch (i) {\n            case 0 :\n                System.out.println (\"i is zero.\");\n                break;\n            case 1 :\n                System.out.println (\"i is one.\");\n            case 2 :\n                System.out.println (\"i is two.\");\n                break;\n            case 3 :\n                System.out.println (\"i is three.\");\n                break;\n            default :\n                System.out.println (\"i is greater than 3.\");\n        }\n        //valid in C# and Java\n        \n        switch (i) {\n            case 0 :\n            case 1 :\n            case 2 :\n            case 3 :\n            case 4 :\n                System.out.println (\"i is less than 5\");\n                break;\n            case 5 :\n            case 6 :\n            case 7 :\n            case 8 :\n            case 9 :\n                System.out.println (\"i is less than 10\");\n                break;\n            default :\n                System.out.println (\"i is 10 or more\");\n        }\n    }\n\n    //main\n    \n}\n\n "
    },
    {
        "hole_rule": "function isPublic\n\tmatch [modifier]\n\t\t'public\nend function",
        "context": "function changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\n\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\n",
        "after": " virtual public ",
        "before": "\n"
    },
    {
        "hole_rule": "function isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function",
        "context": "function checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\n\n\n",
        "after": " int MyInt = 12345;\nint MyInt2 = MyInt + 1;\nint MyInt3;\nMyInt3 = My2ndFunction (MyInt2);\n ",
        "before": "\nint MyInt = 12345;\nint MyInt2 = MyInt + 1;\nint MyInt3;\nMyInt3 = My2ndFunction (MyInt2);\n "
    },
    {
        "hole_rule": "function checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function",
        "context": "function translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " {\n\n    static void Main (string [] args) {\n        //NumericOperators2\n        \n        int a, b, c, d, e, f;\n        a = 1;\n        //1\n        \n        b = a + 1;\n        //2\n        \n        b = b - 1;\n        //1\n        \n        c = 1;\n        d = 2;\n        ++ c;\n        //2\n        \n        -- d;\n        //1\n        \n        e = -- c;\n        // e = 1 c = 1\n        \n        f = c --;\n        // f = 1 c = 0\n        \n        //RelationalOperators\n        \n        a = 10;\n        b = 20;\n        c = 30;\n        if (a < 15 && b < 20) c = 10;\n\n        if (a < 15 || b < 20) c = 15;\n\n        if (! (a == 15)) c = 25;\n\n        //shift operators\n        \n        a = 0;\n        b = 0;\n        a = 8 << 3;\n        b = 32 >> 4;\n        //BitwiseOperators\n        \n        long x = 0x1;\n        long y = 0;\n        y = x & 0x1;\n        y = x | 0x2;\n        y = x ^ 0x4;\n    }\n\n}\n\n ",
        "before": "\n{\n\n    static void Main (string [] args) {\n        //NumericOperators2\n        \n        int a, b, c, d, e, f;\n        a = 1;\n        //1\n        \n        b = a + 1;\n        //2\n        \n        b = b - 1;\n        //1\n        \n        c = 1;\n        d = 2;\n        ++ c;\n        //2\n        \n        -- d;\n        //1\n        \n        e = -- c;\n        // e = 1 c = 1\n        \n        f = c --;\n        // f = 1 c = 0\n        \n        //RelationalOperators\n        \n        a = 10;\n        b = 20;\n        c = 30;\n        if (a < 15 && b < 20) c = 10;\n\n        if (a < 15 || b < 20) c = 15;\n\n        if (! (a == 15)) c = 25;\n\n        //shift operators\n        \n        a = 0;\n        b = 0;\n        a = 8 << 3;\n        b = 32 >> 4;\n        //BitwiseOperators\n        \n        long x = 0x1;\n        long y = 0;\n        y = x & 0x1;\n        y = x | 0x2;\n        y = x ^ 0x4;\n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function",
        "context": "function translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\n\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\n",
        "after": " int x, y;\n\ninternal Point () : base () {\n}\n\ninternal Point (int x, int y) {\n    this.x = x;\n    this.y = y;\n}\n\n ",
        "before": "\nint x, y;\n\nPoint () {\n    super ();\n}\n\nPoint (int x, int y) {\n    this.x = x;\n    this.y = y;\n}\n\n "
    },
    {
        "hole_rule": "rule changeElse\n    replace [ELSEstatement]\n\t'else 'if '( E [expression] ')\n\t    S [statement]\n\tOE [opt ELSEstatement]\n    construct NewS [repeat statement]\n\tS\n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'elsif E [changeExpression] 'then\n\t    NewBody\n\tOE [changeElse]\nend rule",
        "context": "function changeDoWhileStatement\n    replace [statement]\n\t'do\n\t    S [statement] \n\t'while '( E [expression] ') ';\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( E [changeExpression] ')\n    construct NewS [repeat statement]\n\tS \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'loop\n\t    NewBody [. exitCondition]\n\t'end 'loop\nend function\n\nfunction changeWhileStatement\n    replace [statement]\n\t'while '( E [expression] ') \n\t    S [statement]\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( E [changeExpression] ')\n    construct NewS [repeat statement]\n\tS \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'loop\n\t    exitCondition \n\t    NewBody\n\t'end 'loop\nend function\n\nfunction changeForStatement\n    replace [statement]\n\t'for '( I [expression] '; C [expression] '; S1 [expression] ') \n\t    S2 [statement]\n    construct InitStatement [statement]\n\tI\n    construct NewInitStatement [statement]\n\tInitStatement [changeCStatement]\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( C [changeExpression] ')\n    construct NewFinalStatement [repeat statement]\n\tS1\n    construct NewS [repeat statement]\n\tS2 \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets] [. NewFinalStatement]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'begin\n\t    NewInitStatement\n\t    'loop\n\t\texitCondition\n\t\tNewBody\n\t    'end 'loop\n\t'end\nend function\n\nfunction changeIfStatement\n    replace [statement]\n\t'if '( E [expression] ')\n\t    S [statement]\n\tOE [opt ELSEstatement]\n    construct NewS [repeat statement]\n\tS\n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'if E [changeExpression] 'then\n\t    NewBody\n\tOE [changeElse]\n\t'end 'if\nend function\n\nfunction changeReturnStatement\n    replace [statement]\n\t'return E [expression] ';\n    by\n\t'result E [changeExpression]\nend function\n\nfunction changeBreakStatement\n    replace [statement]\n\t'break ';\n    by\n\t'exit\nend function\n\nrule changeExprStatement\n    replace [statement]\n\tES [expression_statement] \n    construct NewES [expression_statement]\n\tES [removeSemiColon]\n\t   [removeAmpersand]\n\t   [changeAssignment]\n\t   [changeBasicPrintf]\n\t   [changeComplexPrintf]\n\t   [changeBasicScanf]\n\t   [changeStrCopy]\n\t   [changeStrCat]\n\t   [changePrePlusPlus]\n\t   [changePostPlusPlus]\n\t   [changePreMinusMinus]\n\t   [changePostMinusMinus]\n\t   [changeArrayBrackets]\t\t%% changeArrayBrackets defined in expr_t.C\n    deconstruct not NewES\n\tES\n    by\n\tNewES \nend rule\n\nfunction translateCStatements CStatement [statement]\t\t\t\n    replace [repeat statement]\n\tSoFar [repeat statement]\n    construct NewTuringStatement [statement]\n\tCStatement [changeCStatement]\n    by\n\tSoFar [. NewTuringStatement]\nend function\n\nfunction removeBrackets\n    replace [repeat statement]\n\t'{\n\t    RS [repeat statement]\n\t'}\n    by\n\tRS\nend function\n\nrule changeExpression\n    construct COps [repeat binary_operator]\n        '== '!= '&& '|| '%\n    construct TuringOps [repeat binary_operator]\n    \t'= 'not= 'and 'or 'mod\n    replace [expression]\n\tE [expression]\n    construct NewE [expression]\n\tE [changeOp each COps TuringOps]\n\t  [changeArrayBrackets]\n    deconstruct not NewE\n\tE \n    by\n\tNewE \nend rule\n\n\n\nfunction removeSemiColon\n    replace [expression_statement]\n\tE [expression] ';\n    by\n\tE [changeExpression]\nend function\n\nfunction removeAmpersand\n    replace * [cast_expression]\n\t'& CE [cast_expression]\n    by\n\tCE\nend function\n\nfunction changeAssignment\n    replace [expression_statement]\n\tCE1 [cast_expression] '= CE2 [cast_expression] RBO [repeat binary_operation]\n    by\n\tCE1 ':= CE2 RBO\nend function\n\nfunction changeBasicPrintf\n    replace [expression_statement]\n\t'printf '( SL[stringlit] ')\n    by\n\t'put SL '..\nend function\n\nfunction changeComplexPrintf\n    replace [expression_statement]\n\t'printf '( LE [list assignment_expression+] ')\n    construct repeatExpr [repeat assignment_expression]\n\t_ [. each LE]\n    deconstruct repeatExpr\n\tSL [stringlit] Rest [repeat assignment_expression]\n    construct NewArgList [list putArg]\n\t_ [translatePutArgs SL Rest]\t\t\t\n    construct putStatement [expression_statement]\n\t'put NewArgList [removeEmptyArg] '..\n    by\n\tputStatement [removeOptDotDot]\nend function\n\nfunction changeBasicScanf\n    replace [expression_statement]\n\t'scanf '( LE [list assignment_expression+] ')\n    construct repeatExpr [repeat assignment_expression]\n\t_ [. each LE]\n    deconstruct repeatExpr\n\tSL [stringlit] Rest [repeat assignment_expression]\n    construct listExpr [list assignment_expression]\n\t_ [, each Rest]\n    by\n\t'get listExpr\nend function\n\nfunction changeStrCopy\n    replace [expression_statement]\n\tES [expression_statement]\n    by\n\tES [changeCopyWithLiteral]\n\t   [changeCopyWithIdentifier]\nend function\n\nfunction changeStrCat\n    replace [expression_statement]\n\tES [expression_statement]\n    by\n\tES [changeCatWithLiteral]\n\t   [changeCatWithIdentifier]\nend function\n\nfunction changePrePlusPlus\n    replace [expression_statement]\n\t'++ ID [identifier]\n    by\n\tID ':= ID '+ 1\nend function\n\nfunction changePostPlusPlus\n    replace [expression_statement]\n\tID [identifier] '++ \n    by\n\tID ':= ID '+ 1\nend function\n\nfunction changePreMinusMinus\n    replace [expression_statement]\n\t'-- ID [identifier]\n    by\n\tID ':= ID '- 1\nend function\n\nfunction changePostMinusMinus\n    replace [expression_statement]\n\tID [identifier] '-- \n    by\n\tID ':= ID '- 1\nend function\n\nfunction changeArrayBrackets\n    replace * [unary_expression]\n\tPE [primary_expression] '[ E [expression] ']\n    by\n\tPE '( E ')\nend function\n\nfunction changeOp COp [binary_operator] TuringOp [binary_operator]\n    replace * [binary_operator]\n\tCOp\n    by\n\tTuringOp\nend function\n\nfunction translatePutArgs SL [stringlit] RAE [repeat assignment_expression]\t\t\t\n    replace [list putArg]\n\tSoFar [list putArg]\n    construct beforePercent [stringlit]\t\t% get everything before the next percent\n\tSL [before \"%\"] [replaceEmpty SL RAE]\n    construct NewSL [putArg]\n\tbeforePercent\n    where not\t\t\t\t\t% terminating condition\n\tbeforePercent [?replaceEmpty SL RAE]\n    construct afterPercent [stringlit]\t\t% get everything after the percent sign\n\tSL [after \"%\"]\n    construct restSL [stringlit]\t\t% skip the next character\n\tafterPercent [: 2 9999] \t\t% 2nd to last character\n    construct RestAE [repeat assignment_expression]\n\t_ [getRest RAE]\n    construct recurse [list putArg]\n\t_ [translatePutArgs restSL RestAE]  \n    by\n\tSoFar [, NewSL] [addAE RAE] [, recurse]\nend function\n\nfunction removeEmptyArg\n    replace * [list_1_putArg]\n\t\"\" ', Tail [list_1_putArg]\n    by\n\tTail \nend function\n\nfunction removeOptDotDot\n    replace [expression_statement]\n\t'put LPA [list putArg] '..\n    construct NewLPA [list putArg]\n\tLPA [removeNewline]\n    %%deconstruct not NewLPA \n    \t%%LPA\n    by\n\t'put NewLPA\nend function\n\nfunction changeCopyWithLiteral\n    replace [expression_statement]\n\t'strcpy '( N [identifier] ', SL [stringlit] ')\n    by\n\tN ':= SL\nend function\n\nfunction changeCopyWithIdentifier\n    replace [expression_statement]\n\t'strcpy '( N [identifier] ', N2 [identifier] ')\n    by\n\tN ':= N2\nend function\n\nfunction changeCatWithLiteral\n    replace [expression_statement]\n\t'strcat '( N [identifier] ', SL [stringlit] ')\n    by\n\tN ':= N '+ SL\nend function\n\nfunction changeCatWithIdentifier\n    replace [expression_statement]\n\t'strcat '( N [identifier] ', N2 [identifier] ')\n    by\n\tN ':= N '+ N2\nend function\n\nfunction replaceEmpty restSL [stringlit] RAE [repeat assignment_expression]\n    replace [stringlit]\n\t\"\"\n    where not\n\tRAE [?notEmpty]\n    by\n\trestSL\nend function\n\nfunction addAE RAE [repeat assignment_expression]\n    deconstruct RAE\n\tAE [assignment_expression] RestAE [repeat assignment_expression]\n    replace [list putArg]\n\tLPA [list putArg]\n    construct NewPA [putArg]\n\tAE\n    by\n\tLPA [, NewPA]\nend function\n\nfunction getRest RAE [repeat assignment_expression]\n    replace [repeat assignment_expression]\n\tRest [repeat assignment_expression]\n    deconstruct RAE\n\tAE [assignment_expression] RestAE [repeat assignment_expression]\n    by\n\tRestAE\nend function\n\nfunction before SL [stringlit]\n    replace [stringlit]\n\tScope [stringlit]\n    construct N [number]\n\t_ [index Scope SL]\n    construct NewN [number]\n\tN [- 1]\n    by\n\tScope [changeNull N]\n\t      [changeNOTNull 1 NewN]\nend function\n\nfunction after SL [stringlit]\n    replace [stringlit]\n\tScope [stringlit]\n    construct N [number]\n\t_ [index Scope SL]\n    construct NewN [number]\n\tN [+ 1]\n    by\n\tScope [changeNull N]\n\t      [changeNOTNull NewN 9999]\nend function\n\nfunction removeNewline\n    replace * [list putArg]\n\tS [stringlit]\n    by\n\t% nothing\nend function\n\nfunction changeNull N [number]\n    replace [stringlit]\n\tSL [stringlit]\n    where\n\tN [<= 1]\n    by\n\t\"\"\nend function\n\nfunction changeNOTNull N1 [number] N2 [number]\n    replace [stringlit]\n\tSL [stringlit]\n    by\n\tSL [: N1 N2]\nend function\n\n",
        "after": " a (3) := 89\n ",
        "before": "\na [3] = 89;\n "
    },
    {
        "hole_rule": "function isTransient\n\tmatch [modifier]\n\t\t'transient\nend function",
        "context": "function translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\n\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " private void initialMethod2 () {\n    bool flag = false;\n}\n\n ",
        "before": "\nprivate void initialMethod2 () {\n    boolean flag = false;\n}\n\n "
    },
    {
        "hole_rule": "function changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function",
        "context": "function changeClassHeader\n% Java: [repeat modifier] 'class [class_name] [opt extends_clause] [opt implements_clause]\n% C#:   class-modifiersopt   class   identifier   class-base opt   class-body   ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\t\t%to set a constructor if needed\n\t\texport ClassName[class_name]\n\t\t\tName\t\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\nfunction checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\n\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " public interface Callback {\n\n    void callback (int param);\n\n}\n\nclass Client : Object, Callback {\n    // Implement Callback's interface\n    \n\n    virtual public void callback (int p) {\n        Console.WriteLine (\"callback called with \" + p);\n    }\n\n}\n\nclass TestIface {\n\n    public static void Main (String [] args) {\n        Callback c = new Client ();\n        c.callback (42);\n    }\n\n}\n\n ",
        "before": "\npublic interface Callback {\n\n    void callback (int param);\n\n}\n\nclass Client implements Callback {\n    // Implement Callback's interface\n    \n\n    public void callback (int p) {\n        System.out.println (\"callback called with \" + p);\n    }\n\n}\n\nclass TestIface {\n\n    public static void main (String args []) {\n        Callback c = new Client ();\n        c.callback (42);\n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function checkStatic\n\tmatch [type_declaration]\n\t   ClassHead[class_header]ClassBody[class_body]\n\t   deconstruct *[repeat modifier]ClassHead\n\t   \tModifiers[repeat modifier]\n\twhere Modifiers[containStatic]\nend function",
        "context": "function changeInterfaceHeader\n% Java: [repeat modifier] 'interface [interface_name] [opt extends_clause] [opt implements_clause]\n% C#:   attributesopt interface-modifiersopt interface identifier interface-baseopt interface-body ;opt \n% Note attributesopt is not used in Java\n\treplace [repeat type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tRemaining [repeat type_declaration]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \n\t\tRemaining[changeClassHeader][changeInterfaceHeader]\nend function\n\nfunction changeModifiers\n\treplace [repeat modifier]\n\t\tModifiers[modifier]\n\t\timport ClassInterfaceMapping [Mapper]\n\t\tdeconstruct * [table_entry] ClassInterfaceMapping\n\t\t\tModifiers -> CSModifier [modifier]\n\tby\n\t\tCSModifier\nend function\n\nfunction changeExtend \n\treplace [opt extends_clause]\n\t\t'extends Enames[list type_name+] \n\t\tconstruct AllNames[repeat qualified_name]\n\t\t\t _[^ Enames]\n\t\tconstruct NewListEnames[list qualified_name]\n\t\t\t _[toQualifiedName each AllNames]\n\tby\n\t\t': NewListEnames\nend function\n\nfunction changeImplement ExtendClause[opt extends_clause]\n\t%check if no extend clause then base class will be Object\n\tdeconstruct not ExtendClause\n\t\t'extends Enames[list type_name+] \n\treplace [opt implements_clause]\n\t\t'implements Inames[list qualified_name+]\n\tconstruct BaseAll [list qualified_name]\n\t\tObject\n\tconstruct NewNames[list qualified_name+]\n\t\tBaseAll[, Inames]\n\tby\n\t\t': NewNames\nend function\n\nfunction addClassExtendToImplmt \n\treplace [class_header]\n\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'class Name NewExtend\nend function\n\nfunction translateEmptyBody\nreplace [class_body]\n\t'{\n\t\t;\n\t'}\n\tby\n\t'{\n\t'}\nend function\n\nfunction changeClassBody\nreplace [class_body]\n\t'{                                   \n\t\tClassBodyDecls[repeat class_body_declaration]    \n   \t'} optSemiColon[opt ';]          \n\texport InitCalls[repeat declaration_or_statement]\n\t\t_%empty one\n\tby\n\t'{\t\n\t\t ClassBodyDecls[translateFieldDeclaration]\n\t\t \t       [translateInstanceInit]\n\t\t \t       [translateStaticInit]\n\t\t \t       [translateBodyMembers]\n\t\t \t        \t\n\t'}optSemiColon\nend function\n\nfunction addInterfaceExtendToImplmt \n\treplace [interface_header]\n\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tdeconstruct ExtendClause\n\t\t': Enames[list qualified_name+] \n\t\tdeconstruct ImplmntClause\n\t\t'implements Inames[list qualified_name+] \n\t\tconstruct NewAddedClause[list qualified_name+]\n\t\t\tEnames[, Inames]\n\t\tconstruct NewExtend [opt extends_clause]\n\t\t\t': NewAddedClause\n\tby\n\t\tmodifiers 'interface Name NewExtend\nend function\n\nfunction changeInterfaceBody\n\treplace[interface_body]\n\t\t'{                                   \n\t\t\tInterfaceBodyDecls[repeat class_body_declaration]    \n\t\t'} optSemiColon[opt ';]          \n\t\tby\n\t\t'{\t\n\t\t\t InterfaceBodyDecls[translateIntFieldDeclaration]\n\t\t\t \t           [translateIntMethods]\n\t\t\t \t           %[translateBodyMembers]\n\t'}optSemiColon\nend function\n\nfunction toQualifiedName Name[qualified_name]\nreplace[list qualified_name]\n\tTypeName[list qualified_name]\nby\n\tTypeName[,Name]\nend function\n\nfunction translateBodyMembers\n\treplace [repeat class_body_declaration]                               \n\t\tClassBodyDecl[class_body_declaration] \n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration]    \n   \tby\n\t \tClassBodyDecl[translateMemberDeclaration]%type declaration\n\t \t\t     [translateMethodConstructor]   \n    \t\tRemainingRepeatBodyDecl[translateBodyMembers]\nend function\n\nfunction translateInstanceInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\twhere ClassBodyDecl[containInitBlock] \n\t% change initializers by methods\n\tconstruct NewClassBodyDecl[repeat class_body_declaration]\n\t\tClassBodyDecl[toMethods]\n\t\n\tby\n\t% add all the methods calls in all constructors\n\t\tNewClassBodyDecl[setDefaultConstructor]\n\t\t\t\t[addCalls][addCallsToSuper]\nend function\n\nfunction translateStaticInit\n\treplace[repeat class_body_declaration]\n\t   ClassBodyDecl[repeat class_body_declaration] \n\tby\n\t   ClassBodyDecl[toStaticConstructor]\nend function\n\nfunction translateFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeField]\nend function\n\nfunction translateIntMethods\n\treplace[repeat class_body_declaration]                               \n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\t\tRemainingRepeatBodyDecl[repeat class_body_declaration] \n\t\t\n\tby\n\t\tModifiers[changeIntMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\n\t\tRemainingRepeatBodyDecl[translateIntMethods]\nend function\n\nfunction translateIntFieldDeclaration\n\treplace[repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\tby\n\t\tClassBodyDecl[changeIntField]\nend function\n\nfunction translateMemberDeclaration\n\treplace*[member_declaration]\n\t\tMember[member_declaration]\n\tby\n\t\tMember[translateTypeDecl]%2 static nested types only\t\n\t\t      %[translateMethodConstructor] 1 \nend function\n\nfunction translateMethodConstructor\n\t%match only the top level methods or constructors\n\tskipping [type_declaration]\n\treplace*[member_declaration]\n\t\tMC[method_or_constructor_declaration]\n\t\t%deconstruct Member\n\t\t%MC[method_or_constructor_declaration]\n\tby\n\t\tMC[translateMethods]\n\t\t  [doConChaining]% if a super class is called\n\t\t  [translateConstructors]% modifiers,declarator and block\n\t\t  [changMethodArray][changeConstructorArray]\nend function\n\nfunction addCallsToSuper\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere ConBody[containSuper][containThis]\n\t\t% yes by a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t       SuperCallStmt [declaration_or_statement]\n\t\t       RemainingStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. RemainingStmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t\t% a call to base class must be the first stmt\t      \n\t\t       SuperCallStmt\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCallsToSuper]\nend function\n\nfunction addCalls\n\treplace*[repeat class_body_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t\tRemaining[repeat class_body_declaration]\n\t%  does the constructor calls its base class?\n\twhere not ConBody[containSuper][containThis]\n\t\t% No, there is no a call to this or super\n\t\tdeconstruct ConBody\n\t\t'{\n\t\t\tStmts[repeat declaration_or_statement]\n\t\t'}\n\t\t% all initialMethods calls\n\t\timport InitCalls [repeat declaration_or_statement]\n\t\t% join the methods calls within the constructor body\n\t\tconstruct NewBlock[repeat declaration_or_statement]\n\t\t\tInitCalls [. Stmts]\n\tby\n\t\t% the constructor again in the new look\n\t\tModifiers ConDeclar ThrowsClause \n\t\t'{\n\t\t       NewBlock\n\t\t'}\n\t\tRemaining[addCalls]\nend function\n\nfunction setDefaultConstructor\n\treplace [repeat class_body_declaration]\n\t\tClassBodyDecl[repeat class_body_declaration] \n\t% get all constructors\n\tconstruct Cons[repeat constructor_declaration]\n\t\t_[^ ClassBodyDecl]\n\tconstruct ConsCount[number]\n\t\t_[length Cons]\n\twhere  ConsCount[< 1]% Not specified\n\timport ClassName[class_name]\t\n\tconstruct NewConstructor[constructor_declaration]\n\t\tClassName() {}\n\tby\n\t\tNewConstructor\n\t\tClassBodyDecl\nend function\n\nfunction containInitBlock\n\tmatch*[repeat class_body_declaration]\n\t\tBlock[block]\n\t\tremaining[repeat class_body_declaration]\nend function\n\nrule toMethods \n\treplace[class_body_declaration]\n\t\tBlock[block]\n\t% name begin with initialMethod\n\tconstruct MethodID[id]\n\t\tinitialMethod\n\t% find a number to add it to the name to be unique\n\tconstruct MethodName[id]\n\t\tMethodID[!]\n\tconstruct MethodCall[declaration_or_statement]\n\t\tMethodName();\n\timport InitCalls [repeat declaration_or_statement]\n\t% add the new method call to the brevious calls\n\texport InitCalls \n\t\tInitCalls [. MethodCall]\n\t% lastly the method itself\n\tconstruct initialMethod[member_declaration]\n\t\t'private 'void MethodName() Block\n\tby\n\t\tinitialMethod\nend rule\n\nrule toStaticConstructor \n\treplace[class_body_declaration]\n\t\t'static Block[block]\n\t% constructor name is same as class name\n\timport ClassName[class_name]\t\n\tconstruct NewStaticConstructor[constructor_declaration]\n\t   'static ClassName() \n\t      Block\t\t\t\t\n\tby\n\t   NewStaticConstructor\nend rule\n\nfunction changeField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tby\n\t   FieldDecl[changeFieldArrayDimensions][checkVar][checkPrimitiveConstants]\n\t   \t    [checkRunTimeConstants]% [changeArrayDimensions]\n\t   Remaining[changeField]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeMethodDeclarator\n\treplace [method_declarator]\n\t   Name[method_name] '( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\t  \n\tby\n\t  Name[changeMain] '( NewFormalParms ')Dim\nend function\n\nfunction changeIntMethodModifiers\n\tconstruct JavaModifiers [repeat modifier]\n\t\t'native  \n\tconstruct CSModifiers [repeat modifier]\n\t\t'extern \n\treplace * [ repeat modifier]\n\t\tModifiers [repeat modifier]\n\tby\n\t\tModifiers [$ each JavaModifiers CSModifiers ]\n\t\t  \t[removeIntPublic]% C# default is public\n\t\t  \t%[changeAbstract][makeVirtual]not needed\n\t\t  \t%[changeProtected][removeNonCS]not needed\nend function\n\nfunction translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function\n\nfunction changeIntField \n\treplace*[repeat class_body_declaration]\n\t\tFieldDecl[field_declaration]\n\t\tRemaining[repeat class_body_declaration]\n\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Interface field must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tby\n\t\tComment\n\t\tFieldDecl\n\t\tRemaining[changeIntField]\nend function\n\nfunction translateTypeDecl\n\treplace[member_declaration]\n\t\tNestedType[type_declaration]\n\tby\n\t\tNestedType[nonStaticNested][staticNested]\nend function\n\nfunction translateMethods\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] TypeSpecify[type_specifier]\n\t\tMDeclar[method_declarator]\n\t\tThrowsClause[opt throws] \n\t\tMBody[method_body]\t\n\tby\n\t\tModifiers[changeMethodModifiers]\n\t\tTypeSpecify[changeDataTypes][changeArrayTypes]\n\t\tMDeclar[changeMethodDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tMBody[translateBlock]\nend function\n\nfunction changMethodArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tReturnedType[type_specifier] Name[declared_name]\n\t\t'( FormalParms[list formal_parameter] ') Dim[repeat dimension] \n\t\tThrowsClause[opt throws] \n\t\tBody[method_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions ]\n\tby\n\t\tModifiers\n\t\tReturnedType Name\n\t\t'( NewFormalParms ') Dim \n\t\tThrowsClause \n\t\tBody\n\nend function\n\nfunction translateConstructors\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\n\tby\n\t\tModifiers[changeConstructorModifiers]\n\t\tConDeclar[changeConstructorDeclarator]\n\t\t%ThrowsClause %not allowed in C#\n\t\tConBody [translateBlock]%[changeConstructorInheritance ConDeclar]\n\nend function\n\nfunction doConChaining\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tConDeclar[constructor_declarator] \n\t\tThrowsClause[opt throws] \n\t\tConBody[constructor_body]\n\t%check the first stmt if it is a call to super or this\n\twhere ConBody[containSuper][containThis]\n\tby\n\t\tModifiers \n\t\tConDeclar[changeToBase ConBody][changeToThis ConBody]\n\t\tThrowsClause %ommited later\n\t\tConBody [removeFirstStmt]\nend function\n\nfunction changeConstructorArray\n\treplace[method_or_constructor_declaration]\n\t\tModifiers[repeat modifier] \n\t\tName[class_name] '( FormalParms[list formal_parameter]') \n\t\tThrowsClause[opt throws] \n\t\tBody[constructor_body]\n\tconstruct NewFormalParms[list formal_parameter]\n\t\tFormalParms[changeMethodConArrayDimentions]\n\tby\n\t\tModifiers Name '( NewFormalParms ')ThrowsClause \n\t\tBody\n\nend function\n\nfunction containSuper \n\tmatch [constructor_body]\n\t   '{\n\t       'super args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction containThis \n\tmatch [constructor_body]\n\t   '{\n\t       'this args[repeat component] ';\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\nend function\n\nfunction checkPrimitiveConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[removeStatic][finalToConst]\n\t\t\t [removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkRunTimeConstants\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarator];\n\twhere Modifiers[containFinal]\n\twhere not VarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToReadOnly][removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction checkVar\n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes]\n\t\tVarDecl ;\t\nend function\n\nfunction changeFieldArrayDimensions \n\treplace[field_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\t% data type first and [] follows\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction changeMain\nreplace[method_name]\n\t'main\nby\n\t'Main\nend function\n\nfunction changeFormalParamsDataTypes FormalParm[formal_parameter]\n\treplace[list formal_parameter]\n\t\tFormalParms[list formal_parameter]\n\tdeconstruct FormalParm\t\n\t\tFinalOpt[opt 'final] DataType[type_specifier] Name[variable_name]\n\tconstruct NewFormalParm[formal_parameter]\n\t\tFinalOpt DataType[changeDataTypes][changeArrayTypes] Name\n\tby\n\t\tFormalParms[, NewFormalParm]\nend function\n\nfunction changeAbstract\nreplace [repeat modifier]\n\t   Modifiers[repeat modifier]\n\twhere Modifiers[containAbstract] \n\tby\n\t   Modifiers[addPublic]\nend function\n\nfunction makeVirtual\nreplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containFinal][containAbstract][containStatic][containPrivate] \n\tby\n\t\t'virtual \n\t\tModifiers[addPublic]\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeIntPublic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\n\tby\n\t   RemainingModifiers\nend rule\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction staticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere NestedType[checkStatic]\n\tby\n\t\tNestedType[removeStatic][changeStaticClassHeader][changeStaticInterfaceHeader]\n\t\t\t  %[removeStatic]\nend function\n\nfunction nonStaticNested\n\treplace[type_declaration]\n\t\tNestedType[type_declaration]\n\twhere not NestedType[isComment]\n\twhere not NestedType[checkStatic]\n\t\n\tconstruct S[stringlit]\n\t\t\"//J2C# NotSupported:Inner classes must be removed manually\"\n\tconstruct Comment[comment]\n\t\t_[unquote S]\t\n\tconstruct RepeatCom[ repeat comment]\n\t\t_[. Comment]\n\tby\n\t\tComment NestedType\nend function\n\nfunction changeMethodModifiers\n    construct JavaModifiers [repeat modifier]\n    \t'native  \n    construct CSModifiers [repeat modifier]\n    \t'extern \n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [$ each JavaModifiers CSModifiers ]\n\t          [changeAbstract]\n\t          [makeVirtual]\n\t          [changeProtected]\n\t          [removeNonCS]      \nend function\n\nrule changeMethodConArrayDimentions \n\treplace[formal_parameter]\n\t\tFormalParm[formal_parameter]\n\tdeconstruct FormalParm\n\t\tFinalOpt[opt 'final] DataType[type_name] Name[declared_name]Dim[repeat dimension]\n\tby\n\t\tFinalOpt DataType Dim Name\nend rule\n\nfunction changeConstructorDeclarator\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter]') %Init[opt constructor_initializer]  \n\t   construct NewFormalParms[list formal_parameter]\n\t\t_[changeFormalParamsDataTypes each FormalParms ]\n\tby\n\t   Name '( NewFormalParms')%Init\nend function\n\nfunction changeConstructorModifiers\n    replace * [ repeat modifier]\n        Modifiers [repeat modifier]\n    by\n\tModifiers [setDefaultAccess][changeProtected]\t\t  \nend function\n\nfunction changeToBase ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'super args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'base args\nend function\n\nfunction changeToThis ConBody[constructor_body]\n\tdeconstruct ConBody\n\t'{\n\t    'this args[repeat component] ';\n\t    Remaining[repeat declaration_or_statement]\n\t'}\n\treplace [constructor_declarator]\n\t   Name[class_name] '( FormalParms[list formal_parameter] ')\n\tby\n\t  Name '( FormalParms ')': 'this args\nend function\n\nfunction removeFirstStmt \n\treplace [constructor_body]\n\t   '{\n\t       stmt[declaration_or_statement]\n\t       Remaining[repeat declaration_or_statement]\n\t   '}\n\tby\n\t   '{ \n\t      Remaining \n\t   '}\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeStatic\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\n\tby\n\t   RemainingModifiers\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction finalToReadOnly\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'readonly\n\t\tRemainingModifiers\nend function\n\nfunction addPublic\n\treplace [repeat modifier]\n\t\tModifiers[repeat modifier]\n\twhere not Modifiers[containPublic][containPrivate][containProtected] \n\tby\n\t   'public \n\t    Modifiers\nend function\n\nrule containAbstract\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isAbstract]\nend rule\n\nrule containPrivate\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPrivate]\nend rule\n\nrule containStatic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isStatic]\nend rule\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isPublic\n\tmatch [modifier]\n\t\t'public\nend function\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction translateStatement\n\treplace [statement]\n\t\tOneStmnt[statement]\n\tby\n\t\tOneStmnt[changeExpressionStmt]\n\t\t        [changeIf]\n\t\t        [changeSwitch]\n\t\t        [changeWhile]\n\t\t        [changeDoWhile]\n\t\t        [changeFor]\n\t\t        [changeBreak]\n\t\t        [changeContinue]\n\t\t        [changeReturn]\n\t\t        [changeThrow]\n\t\t        [changeSynchronized]\n\t\t        [changeTry]\n\t\t       \nend function\n\n\n\nfunction isComment\n\tmatch [type_declaration]\n\t\tComment[comment]\nend function\n\nfunction changeStaticClassHeader\n\treplace [type_declaration]\n\t\tClassHead[class_header]ClassBody[class_body]\n\t\tdeconstruct ClassHead\n\t\t\tmodifiers[repeat modifier] 'class Name[class_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause ]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewClassHead[class_header]\n\t\tNewModifiers 'class Name NewExtend NewImplement\n\tby\n\t\tNewClassHead[addClassExtendToImplmt]\n\t\tClassBody [translateEmptyBody][changeClassBody]   \nend function\n\nfunction changeStaticInterfaceHeader\n\treplace [type_declaration]\n\t\tInterfaceHead[interface_header] InterfaceBody[interface_body]\n\t\tdeconstruct InterfaceHead\n\t\t\tmodifiers[repeat modifier] 'interface Name[interface_name] ExtendClause[opt extends_clause] ImplmntClause[opt implements_clause]\n\t\tconstruct NewModifiers [repeat modifier]\t\t\n\t\t\tmodifiers[changeModifiers ]\n\t\tconstruct NewImplement[opt implements_clause]\n\t\t\tImplmntClause[changeImplement ExtendClause]\n\t\tconstruct NewExtend [opt extends_clause]\t\t\n\t\t\tExtendClause[changeExtend]\n\t\tconstruct NewInterfaceHead[interface_header]\n\t\tNewModifiers 'interface Name NewExtend NewImplement\n\tby\n\t\tNewInterfaceHead[addInterfaceExtendToImplmt]\n\t\tInterfaceBody [translateEmptyBody][changeInterfaceBody] \nend function\n\nfunction setDefaultAccess\n\treplace [repeat modifier]\n\t\tModifiers [repeat modifier]\n\t\tconstruct ModifiersLength[number]\n\t\t\t_[length Modifiers]\n\twhere\n\t\tModifiersLength[< 1]\n\tby\n\t\t'internal\t\n\tend function\n\nfunction isStatic\n\tmatch [modifier]\n\t\t'static\nend function\n\nrule containPublic\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isPublic]\nend rule\n\nrule containProtected\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isProtected]\nend rule\n\nfunction isAbstract\n\tmatch [modifier]\n\t\t'abstract\nend function\n\nfunction isPrivate\n\tmatch [modifier]\n\t\t'private\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction isProtected\n\tmatch [modifier]\n\t\t'protected\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\n",
        "after": " class Exceptions {\n\n    public static void test (Object obj) {\n        Console.WriteLine (obj.toString ());\n    }\n\n    private static void storeItem (Object [] a, int i, Object item) {\n        a [i] = item;\n    }\n\n    public static void Main (String [] args) {\n        try {\n            Console.WriteLine (\"NullPointerException example\");\n            test (null);\n        } catch (NullReferenceException npe) {\n        }\n        try {\n            Console.WriteLine (\"NumberFormatException example\");\n            Integer inum = new Integer (\"36.5\");\n            // format problem\n            \n        } catch (System.Exception nfe) {\n        }\n        try {\n            Console.WriteLine (\"ArithmeticException Example\");\n            int a = 100;\n            a /= 0;\n        } catch (ArithmeticException ae) {\n        }\n        Console.WriteLine (\"ArrayStoreException Example\");\n        Integer [] a = new Integer [3];\n        storeItem (a, 2, new String (\"abc\"));\n    }\n\n}\n\n ",
        "before": "\nclass Exceptions {\n\n    public static void test (Object obj) {\n        System.out.println (obj.toString ());\n    }\n\n    private static void storeItem (Object [] a, int i, Object item) {\n        a [i] = item;\n    }\n\n    public static void main (String [] args) {\n        try {\n            System.out.println (\"NullPointerException example\");\n            test (null);\n        } catch (NullPointerException npe) {\n        }\n        try {\n            System.out.println (\"NumberFormatException example\");\n            Integer inum = new Integer (\"36.5\");\n            // format problem\n            \n        } catch (NumberFormatException nfe) {\n        }\n        try {\n            System.out.println (\"ArithmeticException Example\");\n            int a = 100;\n            a /= 0;\n        } catch (ArithmeticException ae) {\n        }\n        System.out.println (\"ArrayStoreException Example\");\n        Integer [] a = new Integer [3];\n        storeItem (a, 2, new String (\"abc\"));\n    }\n\n}\n\n "
    },
    {
        "hole_rule": "function translateBlock\n\treplace*[block]\n\t   '{                                        \n        \tDeclOrStmt[repeat declaration_or_statement]     \n    \t   '}\n\tby\n\t   '{\n\t   \tDeclOrStmt[translateVarDeclaration]\n\t   \t          [translateClassInBlock]     \n           \t          [translateStatementInBlock]\n           '}\nend function",
        "context": "function changeExpressionStmt\n\treplace[statement]\n\t\tExpression[expression];\n\tby\n\t\tExpression[changeExpression][changeCSStatement];\nend function\n\nfunction changeIf\n\treplace*[statement]\n\t\t'if '( IfExp[expression] ')     \n\t\t        IfStmt[statement]\n    \t\tElseClause[opt else_clause] \n\tby\n\t\t'if '( IfExp[changeExpression] ')     \n\t\t\tIfStmt[translateStatement][translateBlock]\n    \t\tElseClause[changeElseClause] \nend function\n\nfunction changeSwitch\nreplace*[statement]\n    'switch '( SwitchExp[expression] ') '{ SwitchAlters [repeat switch_alternative] '}\nby\n    'switch '( SwitchExp[changeExpression] ')'{ SwitchAlters [addBreak][fallThrough]\n    \t\t\t\t\t\t\t     [changeSwitchStmts] '}   \t\nend function\n\nfunction changeWhile\n\treplace*[statement]\n\t\t'while '( WhileExp[expression] ') \n        \t\tStmts[statement]   \n\tby\n\t\t'while '( WhileExp[changeExpression]') \n        \t\tStmts[translateStatement][translateBlock]\nend function\n\nfunction changeDoWhile\n\treplace*[statement]\n\t\t'do\n\t\t\tStmts[statement]\n\t\t'while '( DoWhileExp[expression] ');    \n\tby\n\t\t'do\n\t\t\tStmts[translateStatement][translateBlock]\n\t\t'while '( DoWhileExp[changeExpression]'); \t\nend function\n\nfunction changeFor\n\treplace*[statement]\n\t\t'for '( InitExp[for_init] ForExp[for_expression]UpdateExp [for_update] ')\n        \t\tStmts[statement]    \n\tby\n\t\t'for '( InitExp[checkLocalVars][changeExpression] ForExp[changeExpression]UpdateExp [changeExpression] ')\n        \t\tStmts[translateStatement][translateBlock]  \t\nend function\n\nfunction changeBreak\n\treplace*[statement]\n\t\tBreakStmt[break_statement]\n\tdeconstruct BreakStmt\n\t\t'break LabelName[reference]';\n\tby\n\t\tBreakStmt[$ 'break 'goto]%'goto LabelName ';\nend function\n\nfunction changeContinue\n\treplace*[statement]\n\t\tContinueStmt[continue_statement]\n\tdeconstruct ContinueStmt\n\t\t'continue LabelName[reference]';\n\tby\n\t\tContinueStmt[$ 'continue 'goto]%'goto LabelName ';\nend function\n\nfunction changeReturn\n\treplace*[statement]\n\t\t'return ReturnExp[opt expression] ';\n\tby\n\t\t'return ReturnExp[changeOptExpression] ';\nend function\n\nfunction changeThrow\n\treplace*[statement]\n\t\t'throw ThrowExp[expression] ';\n\tby\n\t\t'throw ThrowExp[changeExpression][changeCSException][changeCSStatement] ';\nend function\n\nfunction changeSynchronized\n\treplace*[statement]\n    \t    'synchronized '( SyncExp[expression] ')\n        \tStmts[statement]                 \n        by\n            'lock '( SyncExp[changeExpression] ')\n        \tStmts[translateStatement][translateBlock]                 \nend function\n\nfunction changeTry\n\treplace*[statement]\n\t\t'try TryBlock[block] Catches[repeat catch_clause] Finally[opt finally_clause]\n\tconstruct NewCatches[repeat catch_clause]\n\t\t_[changeCatch each Catches]\n\tby\n\t\t'try TryBlock[translateBlock] NewCatches Finally[changeFinally]\nend function\n\nfunction changeExpression\n\treplace*[expression]\n\t\tExpression[expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSStatement\n\treplace [expression]\n\t\tFirstId[id] '. SecondId[id]'. ThirdId[id]Remaining[repeat component]\n\t%to search for specified entry in the statemnts table\n\tconstruct Key[reference]\n\t\tFirstId.SecondId.ThirdId\n\timport StatementMapping [StmtMapper]\n\t% match the key entry with C# one\n\tdeconstruct *[table_entry] StatementMapping\n\t\tKey -> CSStmt [reference]\n\t% to build a new valid expression \n\tdeconstruct CSStmt\n\t\tFirstCSId[id] CSRemaining[repeat component]\n\t%join the method arguements with the new part\n\tby \n\t\tFirstCSId CSRemaining[. Remaining]\nend function\n\n\n\nfunction changeElseClause\n\treplace[opt else_clause]\n\t\t'else ElseStmts [statement]\n\tby\n\t\t'else ElseStmts[translateStatement][translateBlock]\nend function\n\nfunction addBreak\n\treplace[repeat switch_alternative]\n\t  \tSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length SwitchAlters]\n\tconstruct Index[number]\n\t\tLength[- 1]\n\tconstruct LastAlter[repeat switch_alternative]\n\t\tSwitchAlters [tail Length]\n\tdeconstruct LastAlter\n\t\tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t%no break ?\n\twhere not Stmts[ContainBreak]\n\t% all alternatives before the last one\n\tconstruct BeforeLastAlter[repeat switch_alternative]\n\t\tSwitchAlters [head Index]\n\t%a new break to be added\n\tconstruct Break[repeat declaration_or_statement]\n\t\tbreak ;\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. Break]\n\t%new statements with break\n\tconstruct NewLastAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tBeforeLastAlter[. NewLastAlter]\n\tby\n\t\tNewSwitchAlters  \nend function\n\nfunction fallThrough\n\treplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]   \n\tconstruct Length[number]\n\t\t _[length Stmts]\n\t%no break and at least one statement is present\n\twhere not Stmts[ContainBreak]\n\twhere Length[ > 0]\n\twhere not Stmts[isGoto]\n\tdeconstruct RemainingSwitchAlters\n\t\tNextLabel[switch_label]  NextStmts[repeat declaration_or_statement] \n\t\tRemainingAlters [repeat switch_alternative] \n\t%goto the next alternative\n\tconstruct GotoStmt[repeat declaration_or_statement]\n\t\tgoto NextLabel \n\t%replace colon with semi colon to be a valid statement\n\tconstruct NewGotoStmt[repeat declaration_or_statement]\n\t\tGotoStmt[$ ': '; ]\t\n\tconstruct NewStmts[repeat declaration_or_statement] \n\t\tStmts[. NewGotoStmt]\n\t%new statements with goto\n\tconstruct NewAlter[repeat switch_alternative]\n\t\tLabel NewStmts\n\t%check the other cases also\n\tconstruct NewRemainingAlters[repeat switch_alternative]\n\t\tRemainingSwitchAlters[fallThrough]\n\t%the final result\n\tconstruct NewSwitchAlters[repeat switch_alternative]\n\t\tNewAlter[. NewRemainingAlters]\n\tby\n\t\t  NewSwitchAlters\nend function\n\nfunction changeSwitchStmts\nreplace*[repeat switch_alternative]\n\t  \tLabel[switch_label]  Stmts[repeat declaration_or_statement] \n\t\tRemainingSwitchAlters [repeat switch_alternative]\n\tby\n\t\tLabel  Stmts[translateStatementInBlock] \n\t\tRemainingSwitchAlters[changeSwitchStmts] \n\nend function\n\nfunction checkLocalVars\n\treplace*[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\t\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere not Modifiers[containFinal]\n\tby\n\t\tModifiers[removeNonCSModifiers][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeOptExpression\n\treplace[opt expression]\n\t\tExpression[opt expression]\n\tby\n\t\tExpression[$ '>>> '>>]\nend function\n\nfunction changeCSException\n\treplace *[expression]\n\t\texp[expression]\n\tdeconstruct exp\n\t\t'new ExceptionName[qualified_name]()\n\tby\n\t\t'new ExceptionName[changeExceptionName]()\nend function\n\nfunction changeCatch CatchClause[catch_clause]\n\treplace[repeat catch_clause]\n\t\tCatches[repeat catch_clause]\n\tdeconstruct CatchClause\t\n\t\t'catch '( DataType[type_specifier] Name[variable_name] ') \n\t\t\tCatchBlock[block] \n\tconstruct NewCatchClause[catch_clause]\n\t\t'catch '( DataType[changeDataTypes][changeArrayTypes][changeExceptionName] Name ') \n\t\t\tCatchBlock[translateBlock]  \n\tby\n\t\tCatches[. NewCatchClause]\nend function\n\nfunction changeFinally\n\treplace[opt finally_clause]\n\t\t'finally FinBlock[block] \n\tby\n\t\t'finally FinBlock[translateBlock]\nend function\n\nfunction translateVarDeclaration\nreplace*[repeat declaration_or_statement]\n\tVar[local_variable_declaration]\n\tRemaining[repeat declaration_or_statement]\nby\n\tVar[checkLocalVars]\n\t   [checkLocalConstants][checkLocalRunTimeConstants]\n\t   [checkLocalBlankConstants][changeArrayDimensions]\n\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateClassInBlock \n\treplace*[repeat declaration_or_statement]\n\t\tClassInBlock[class_declaration]\n\t\tRemaining[repeat declaration_or_statement]\n\t\tconstruct S[stringlit]\n\t\t\"//J2C# Unsupported:Classes within blocks must be removed manually\"\n\t\tconstruct Comment[comment]\n\t\t\t_[unquote S]\n\tby\n\t\tComment\n\t\tClassInBlock\n\t\tRemaining[translateVarDeclaration]\nend function\n\nfunction translateStatementInBlock\n\treplace*[repeat declaration_or_statement]\n\t\tStmnt[statement]\n\t\tRemaining[repeat declaration_or_statement]\n\tby\n\t\tStmnt[translateStatement]\n\t\tRemaining[translateStatementInBlock]\nend function\n\nfunction ContainBreak\n\tmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tbreakStmt[break_statement]\nend function\n\nfunction isGoto\nmatch[repeat declaration_or_statement]\n\t\tStmts[repeat declaration_or_statement]\n\tconstruct Length[number]\n\t\t _[length Stmts]\n\tconstruct LastDecStmt[repeat declaration_or_statement]\n\t\tStmts [tail Length]\n\tdeconstruct *LastDecStmt\n\t\tgotoStmt[goto_statement]\nend function\n\nfunction changeDataTypes\n\treplace[type_specifier]\n\t\tDataType[primitive_type]\n\tby\n\t\tDataType[changePrimDataTypes]\nend function\n\nfunction changeArrayTypes\n\treplace[type_specifier]\n\t\tArrayType[type_name] Dimentions[repeat dimension+]\n\t\tdeconstruct *[primitive_type] ArrayType\n\t\t\tPrimType[primitive_type]\n\tby\n\t\tPrimType[changePrimDataTypes]Dimentions\nend function\n\nfunction changeExceptionName\nreplace *[qualified_name]\n\tExceptionName[qualified_name]\nimport RunTimeExceptionsMapper [ExceptionMapper]\ndeconstruct * [exceptionTable] RunTimeExceptionsMapper\n\tExceptionName -> CSName [qualified_name]\nby\n\tCSName\nend function\n\nfunction changeProtected\n\treplace * [ repeat modifier]\n\t\t'protected\n\tby\n\t\t'internal 'protected\nend function\n\nrule containFinal\n\tmatch [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\nend rule\n\nrule removeNonCSModifiers\n\treplace [repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isTransient][isVolatile]\n\tby\n\t\tRemainingModifiers\nend rule\n\nfunction checkLocalConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[finalToConst][changeProtected]\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalRunTimeConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_declarators];\n\tconstruct AllVarDecl[repeat variable_declarator]\n\t\t_[^ VarDecl]\n\tdeconstruct AllVarDecl\n\t\tFirstVarDecl[variable_declarator]Remaining[repeat variable_declarator]\n\twhere Modifiers[containFinal]\n\twhere not FirstVarDecl[isCompileTime]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction checkLocalBlankConstants\n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tTypeSpecifier[type_specifier] \n\t\tVarDecl[variable_name];%no initializer\n\twhere Modifiers[containFinal]\n\tby\n\t\tModifiers[changeProtected][removeNonCS]%remove final\n\t\tTypeSpecifier[changeDataTypes][changeArrayTypes][changeExceptionName]\n\t\tVarDecl[changeCSException][changeCSStatement] ;\t\nend function\n\nfunction changeArrayDimensions \n\treplace[local_variable_declaration]\n\t\tModifiers[repeat modifier] \n\t\tDataType[type_name]\n\t\tVarName[declared_name]Dim [repeat dimension]VarInit [opt equals_variable_initializer];\n\tconstruct NewTypeSpecifier[type_specifier]\n\t\tDataType Dim\n\tby\n\t\tModifiers NewTypeSpecifier VarName VarInit ;\nend function\n\nfunction changePrimDataTypes\n\treplace [primitive_type]\n\t\tJavaType[primitive_type]\n\t\timport PrimDataTypesMapping [DataMapper]\n\t\tdeconstruct * [primitiveTable] PrimDataTypesMapping\n\t\t\tJavaType -> CSType [primitive_type]\n\tby\n\t\tCSType\nend function\n\nfunction isFinal\n\tmatch [modifier]\n\t\t'final\nend function\n\nfunction isTransient\n\tmatch [modifier]\n\t\t'transient\nend function\n\nfunction isVolatile\n\tmatch [modifier]\n\t\t'volatile\nend function\n\nfunction isCompileTime\n\tmatch[variable_declarator]\n\t\tVarName[variable_name] '= Value[literal]\nend function\n\nfunction finalToConst\n\treplace *[repeat modifier]\n\t\tCurrentModifier[modifier]\n\t\tRemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal]\n\tby \n\t\t'const\n\t\tRemainingModifiers\nend function\n\nrule removeNonCS\n\treplace [repeat modifier]\n\t   CurrentModifier[modifier]\n\t   RemainingModifiers[repeat modifier]\n\twhere CurrentModifier[isFinal][isTransient][isVolatile]\n\tby\n\t   RemainingModifiers\nend rule\n\n",
        "after": " Console.WriteLine (\"?\");\n ",
        "before": "\nSystem.out.println (\"?\");\n "
    },
    {
        "hole_rule": "function changeOptArrayPart OAP [opt array_part]\n    deconstruct OAP\n\t'[ N [number] ']\n    replace [argument_declaration]\n\tDI [decl_identifier] ': T [type_specifier]\n    construct NewN [number]\n\tN [- 1]\n    construct TuringArraySpec [type_specifier]\n\t'array 0 .. NewN 'of T\n    construct NewTuringArraySpec [type_specifier]\n\tTuringArraySpec [changeToStringSpec]\n    by\n\tDI ': NewTuringArraySpec\nend function",
        "context": "function translateFunction\n    replace [function_definition]\n\tTS [type_specifier] N [identifier] '( AD [list argument_declaration] ')\n\tCS [compound_statement]\n    construct TuringArgs [list argument_declaration]\n\t_ [translateArg each AD]\n    construct ArgPart [t_paramDecl]\n\t'( TuringArgs ')\n    construct NewFunc [function_definition]\n\t'function N ArgPart ': TS\n\t    CS [changeCompound]\n\t'end N\n    by\n\tNewFunc [removeBeginEndFromFunc] \n\t\t[removeEmptyArgsFromFunc]\nend function\n\nfunction translateProcedure\n    replace [function_definition]\n\t'void N [identifier] '( AD [list argument_declaration] ')\n\tCS [compound_statement]\n    construct TuringArgs [list argument_declaration]\n\t_ [translateArg each AD]\n    construct ArgPart [t_paramDecl]\n\t'( TuringArgs ')\n    construct NewProc [function_definition]\n\t'procedure N ArgPart\n\t    CS [changeCompound]\n\t'end N\n    by\n    NewProc [removeBeginEndFromProc] \n    \t    [removeEmptyArgsFromProc]\nend function\n\nfunction translateArg AD [argument_declaration]\n    deconstruct AD\n\tT [type_specifier] DI [decl_identifier] OAP [opt array_part] OI [opt initialisation]\n    replace [list argument_declaration]\n\tSoFar [list argument_declaration]\n    construct TuringArg [argument_declaration]\n\tDI ': T\n    construct NewTuringArg [argument_declaration]\n\tTuringArg [changeOptArrayPart OAP]\n\t\t  [changeType]\n    by\n\tSoFar [, NewTuringArg]\t\nend function\n\nfunction removeBeginEndFromFunc\n    replace [function_definition]\n\t'function N [identifier] OA [opt t_paramDecl] ': TS [type_specifier]\n\t    'begin\n\t\tD [repeat externaldefinition]\n\t\tS [repeat statement]\n\t    'end\n\t'end N\n    construct NewType [type_specifier]\n\tTS [changeType]\n    by\n\t'function N OA ': NewType\n\t    D\n\t    S\n\t'end N\nend function\n\nfunction removeEmptyArgsFromFunc\n    replace [function_definition]\n\t'function N [identifier] '( ') ': TS [type_specifier] \n\t    D [repeat externaldefinition]\n\t    S [repeat statement]\n\t'end N\n    by\n\t'function N ': TS\n\t    D\n\t    S\n\t'end N\nend function\n\nrule changeCompound\n    replace [compound_statement]\n\t'{\n\t\tD [repeat declaration] \n\t\tS [repeat statement]\n\t'} OS [opt ';]\n    construct ExtDefs [repeat externaldefinition]\n\t_ [makeExternalDef each D]\n    construct TuringDecls [repeat externaldefinition]\n\t_ [changeExternalDef each ExtDefs]\n    construct TuringStatements [repeat statement]\n\t_ [translateCStatements each S]\n    by\n\t'begin\n\t\tTuringDecls\n\t\tTuringStatements \n\t'end\nend rule\n\nfunction removeBeginEndFromProc\n    replace [function_definition]\n\t'procedure N [identifier] OA [opt t_paramDecl]\n\t    'begin\n\t\tD [repeat externaldefinition]\n\t\tS [repeat statement]\n\t    'end\n\t'end N\n    by\n\t'procedure N OA\n\t    D\n\t    S\n\t'end N\nend function\n\nfunction removeEmptyArgsFromProc\n    replace [function_definition]\n\t'procedure N [identifier] '( ')\n\t    D [repeat externaldefinition]\n\t    S [repeat statement]\n\t'end N\n    by\n\t'procedure N\n\t    D\n\t    S\n\t'end N\nend function\n\nfunction changeType\n    construct CTypes [repeat type_specifier]\n    \t'char 'long 'float 'double\n    construct TuringTypes [repeat type_specifier]\n    \t'string(1) 'int 'real 'real\n    replace * [type_specifier]\n        CType [type_specifier]\n    by\n\tCType [$ each CTypes TuringTypes]\nend function\n\n\n\nfunction changeExternalDef ExtDef [externaldefinition]\n    replace [repeat externaldefinition]\n\tSoFar [repeat externaldefinition]\n\t\n    construct NewExtDef [externaldefinition]\n\tExtDef [translateCConst]\n\t       [translateCType]\n\t       [translateCVar]\n\t       [translateCFunction]\n    by\n\tSoFar [. NewExtDef]\nend function\n\nfunction translateCStatements CStatement [statement]\t\t\t\n    replace [repeat statement]\n\tSoFar [repeat statement]\n    construct NewTuringStatement [statement]\n\tCStatement [changeCStatement]\n    by\n\tSoFar [. NewTuringStatement]\nend function\n\nfunction makeExternalDef D [declaration]\n    replace [repeat externaldefinition]\n\tSoFar [repeat externaldefinition]\n    construct NewExternalDef [externaldefinition]\n\tD\n    by\n\tSoFar [. NewExternalDef]\nend function\n\nfunction changeToStringSpec\n    replace * [type_specifier]\n\t'array 0 .. N [number] 'of 'char\n    construct NewN [number]\n\tN [+ 1]\n    construct NewTuringTypeSpec [type_specifier]\n\t'string '( NewN ')\n    by\n\tNewTuringTypeSpec\nend function\n\nfunction translateCConst\n    replace [externaldefinition]\n\t'const T [type_specifier] N [identifier] '= E [expression] ';\n    construct NewType [type_specifier]\n\tT [changeType]\n    by\t\n\t'const N ': NewType ':= E\nend function\n\nfunction translateCType\n    replace [externaldefinition]\n\t'typedef T [type_specifier] OP [opt pointer] N [identifier] OAP [opt array_part] ';\n    construct NewType [type_specifier]\n\tT [changeType]\n    construct NewTuringType [externaldefinition]\n\t'type N : NewType\n    by\n\tNewTuringType\nend function\n\nfunction translateCVar\n    replace [externaldefinition]\n\tT [type_specifier] D [list decl_id_part+] ';\n    construct NewTuringVar [repeat t_var]\n\t_ [translatePointerVarDecl T each D]\n\t  [translateVarDecl T each D]\n    construct NewED [externaldefinition]\n\tNewTuringVar\n    by\n\tNewED\nend function\n\nfunction changeCStatement\n    replace [statement]\n\tS [statement]\n    construct NewS [statement]\n\tS [changeExprStatement]\n\t  [changeIfStatement]\n\t%% Loop statements\n\t  [changeDoWhileStatement]\n\t  [changeWhileStatement]\n\t  [changeForStatement]\n\t%% Jump statements\n\t  [changeReturnStatement]\n\t  [changeBreakStatement]\n    deconstruct not NewS\n\tS\n    by\n\tNewS\nend function\n\nfunction translateVarDecl T [type_specifier] D [decl_id_part]\n    deconstruct D\n\tDI [decl_identifier] OAP [opt array_part] OI [opt initialisation]\n    replace [repeat t_var]\n\tSoFar [repeat t_var]\n    construct TuringVar [t_var]\n\t'var DI ': T\n    construct NewTuringVar [t_var]\n\tTuringVar [addOptArrayPart OAP]\n\t\t  [addOptInit OI]\n\t\t  [changeType]\n    by\n\tSoFar [. NewTuringVar]\t\nend function\n\nfunction translatePointerVarDecl T [type_specifier] D [decl_id_part]\n    deconstruct D\n\t'* DI [decl_identifier] OAP [opt array_part] OI [opt initialisation]\n    deconstruct T\n\t'char\n    replace [repeat t_var]\n\tSoFar [repeat t_var]\n    construct TuringVar [t_var]\n\t'var DI ': 'string\n    construct NewTuringVar [t_var]\n\tTuringVar [addOptArrayPart OAP]\n\t\t  [addOptInit OI]\n    by\n\tSoFar [. NewTuringVar]\t\nend function\n\nfunction changeDoWhileStatement\n    replace [statement]\n\t'do\n\t    S [statement] \n\t'while '( E [expression] ') ';\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( E [changeExpression] ')\n    construct NewS [repeat statement]\n\tS \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'loop\n\t    NewBody [. exitCondition]\n\t'end 'loop\nend function\n\nfunction changeWhileStatement\n    replace [statement]\n\t'while '( E [expression] ') \n\t    S [statement]\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( E [changeExpression] ')\n    construct NewS [repeat statement]\n\tS \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'loop\n\t    exitCondition \n\t    NewBody\n\t'end 'loop\nend function\n\nfunction changeForStatement\n    replace [statement]\n\t'for '( I [expression] '; C [expression] '; S1 [expression] ') \n\t    S2 [statement]\n    construct InitStatement [statement]\n\tI\n    construct NewInitStatement [statement]\n\tInitStatement [changeCStatement]\n    construct exitCondition [statement]\t\n\t'exit 'when 'not '( C [changeExpression] ')\n    construct NewFinalStatement [repeat statement]\n\tS1\n    construct NewS [repeat statement]\n\tS2 \n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets] [. NewFinalStatement]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'begin\n\t    NewInitStatement\n\t    'loop\n\t\texitCondition\n\t\tNewBody\n\t    'end 'loop\n\t'end\nend function\n\nfunction changeIfStatement\n    replace [statement]\n\t'if '( E [expression] ')\n\t    S [statement]\n\tOE [opt ELSEstatement]\n    construct NewS [repeat statement]\n\tS\n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'if E [changeExpression] 'then\n\t    NewBody\n\tOE [changeElse]\n\t'end 'if\nend function\n\nfunction changeReturnStatement\n    replace [statement]\n\t'return E [expression] ';\n    by\n\t'result E [changeExpression]\nend function\n\nfunction changeBreakStatement\n    replace [statement]\n\t'break ';\n    by\n\t'exit\nend function\n\nrule changeExprStatement\n    replace [statement]\n\tES [expression_statement] \n    construct NewES [expression_statement]\n\tES [removeSemiColon]\n\t   [removeAmpersand]\n\t   [changeAssignment]\n\t   [changeBasicPrintf]\n\t   [changeComplexPrintf]\n\t   [changeBasicScanf]\n\t   [changeStrCopy]\n\t   [changeStrCat]\n\t   [changePrePlusPlus]\n\t   [changePostPlusPlus]\n\t   [changePreMinusMinus]\n\t   [changePostMinusMinus]\n\t   [changeArrayBrackets]\t\t%% changeArrayBrackets defined in expr_t.C\n    deconstruct not NewES\n\tES\n    by\n\tNewES \nend rule\n\nfunction addOptInit OI [opt initialisation]\n    deconstruct OI\n\t'= E [expression]\n    replace [t_var]\n\t'var DI [decl_identifier] ': T [type_specifier]\n    by\n\t'var DI ': T ':= E [changeExpression]\nend function\n\nfunction addOptArrayPart OAP[opt array_part]\n    deconstruct OAP\n\t'[ N [number] ']\n    replace [t_var]\n\t'var DI [decl_identifier] ': T [type_specifier]\n    construct NewN [number]\n\tN [- 1]\n    construct TuringArraySpec [type_specifier]\n\t'array 0 .. NewN 'of T\n    construct NewTuringArraySpec [type_specifier]\n\tTuringArraySpec [changeToStringSpec]\n    by\n\t'var DI ': NewTuringArraySpec\nend function\n\nfunction removeBrackets\n    replace [repeat statement]\n\t'{\n\t    RS [repeat statement]\n\t'}\n    by\n\tRS\nend function\n\nrule changeExpression\n    construct COps [repeat binary_operator]\n        '== '!= '&& '|| '%\n    construct TuringOps [repeat binary_operator]\n    \t'= 'not= 'and 'or 'mod\n    replace [expression]\n\tE [expression]\n    construct NewE [expression]\n\tE [changeOp each COps TuringOps]\n\t  [changeArrayBrackets]\n    deconstruct not NewE\n\tE \n    by\n\tNewE \nend rule\n\nrule changeElse\n    replace [ELSEstatement]\n\t'else 'if '( E [expression] ')\n\t    S [statement]\n\tOE [opt ELSEstatement]\n    construct NewS [repeat statement]\n\tS\n    construct NewS2 [repeat statement]\n\tNewS [removeBrackets]\n    construct NewBody [repeat statement]\n\t_ [translateCStatements each NewS2]\n    by\n\t'elsif E [changeExpression] 'then\n\t    NewBody\n\tOE [changeElse]\nend rule\n\nfunction removeSemiColon\n    replace [expression_statement]\n\tE [expression] ';\n    by\n\tE [changeExpression]\nend function\n\nfunction removeAmpersand\n    replace * [cast_expression]\n\t'& CE [cast_expression]\n    by\n\tCE\nend function\n\nfunction changeAssignment\n    replace [expression_statement]\n\tCE1 [cast_expression] '= CE2 [cast_expression] RBO [repeat binary_operation]\n    by\n\tCE1 ':= CE2 RBO\nend function\n\nfunction changeBasicPrintf\n    replace [expression_statement]\n\t'printf '( SL[stringlit] ')\n    by\n\t'put SL '..\nend function\n\nfunction changeComplexPrintf\n    replace [expression_statement]\n\t'printf '( LE [list assignment_expression+] ')\n    construct repeatExpr [repeat assignment_expression]\n\t_ [. each LE]\n    deconstruct repeatExpr\n\tSL [stringlit] Rest [repeat assignment_expression]\n    construct NewArgList [list putArg]\n\t_ [translatePutArgs SL Rest]\t\t\t\n    construct putStatement [expression_statement]\n\t'put NewArgList [removeEmptyArg] '..\n    by\n\tputStatement [removeOptDotDot]\nend function\n\nfunction changeBasicScanf\n    replace [expression_statement]\n\t'scanf '( LE [list assignment_expression+] ')\n    construct repeatExpr [repeat assignment_expression]\n\t_ [. each LE]\n    deconstruct repeatExpr\n\tSL [stringlit] Rest [repeat assignment_expression]\n    construct listExpr [list assignment_expression]\n\t_ [, each Rest]\n    by\n\t'get listExpr\nend function\n\nfunction changeStrCopy\n    replace [expression_statement]\n\tES [expression_statement]\n    by\n\tES [changeCopyWithLiteral]\n\t   [changeCopyWithIdentifier]\nend function\n\nfunction changeStrCat\n    replace [expression_statement]\n\tES [expression_statement]\n    by\n\tES [changeCatWithLiteral]\n\t   [changeCatWithIdentifier]\nend function\n\nfunction changePrePlusPlus\n    replace [expression_statement]\n\t'++ ID [identifier]\n    by\n\tID ':= ID '+ 1\nend function\n\nfunction changePostPlusPlus\n    replace [expression_statement]\n\tID [identifier] '++ \n    by\n\tID ':= ID '+ 1\nend function\n\nfunction changePreMinusMinus\n    replace [expression_statement]\n\t'-- ID [identifier]\n    by\n\tID ':= ID '- 1\nend function\n\nfunction changePostMinusMinus\n    replace [expression_statement]\n\tID [identifier] '-- \n    by\n\tID ':= ID '- 1\nend function\n\nfunction changeArrayBrackets\n    replace * [unary_expression]\n\tPE [primary_expression] '[ E [expression] ']\n    by\n\tPE '( E ')\nend function\n\nfunction changeOp COp [binary_operator] TuringOp [binary_operator]\n    replace * [binary_operator]\n\tCOp\n    by\n\tTuringOp\nend function\n\nfunction translatePutArgs SL [stringlit] RAE [repeat assignment_expression]\t\t\t\n    replace [list putArg]\n\tSoFar [list putArg]\n    construct beforePercent [stringlit]\t\t% get everything before the next percent\n\tSL [before \"%\"] [replaceEmpty SL RAE]\n    construct NewSL [putArg]\n\tbeforePercent\n    where not\t\t\t\t\t% terminating condition\n\tbeforePercent [?replaceEmpty SL RAE]\n    construct afterPercent [stringlit]\t\t% get everything after the percent sign\n\tSL [after \"%\"]\n    construct restSL [stringlit]\t\t% skip the next character\n\tafterPercent [: 2 9999] \t\t% 2nd to last character\n    construct RestAE [repeat assignment_expression]\n\t_ [getRest RAE]\n    construct recurse [list putArg]\n\t_ [translatePutArgs restSL RestAE]  \n    by\n\tSoFar [, NewSL] [addAE RAE] [, recurse]\nend function\n\nfunction removeEmptyArg\n    replace * [list_1_putArg]\n\t\"\" ', Tail [list_1_putArg]\n    by\n\tTail \nend function\n\nfunction removeOptDotDot\n    replace [expression_statement]\n\t'put LPA [list putArg] '..\n    construct NewLPA [list putArg]\n\tLPA [removeNewline]\n    %%deconstruct not NewLPA \n    \t%%LPA\n    by\n\t'put NewLPA\nend function\n\nfunction changeCopyWithLiteral\n    replace [expression_statement]\n\t'strcpy '( N [identifier] ', SL [stringlit] ')\n    by\n\tN ':= SL\nend function\n\nfunction changeCopyWithIdentifier\n    replace [expression_statement]\n\t'strcpy '( N [identifier] ', N2 [identifier] ')\n    by\n\tN ':= N2\nend function\n\nfunction changeCatWithLiteral\n    replace [expression_statement]\n\t'strcat '( N [identifier] ', SL [stringlit] ')\n    by\n\tN ':= N '+ SL\nend function\n\nfunction changeCatWithIdentifier\n    replace [expression_statement]\n\t'strcat '( N [identifier] ', N2 [identifier] ')\n    by\n\tN ':= N '+ N2\nend function\n\nfunction replaceEmpty restSL [stringlit] RAE [repeat assignment_expression]\n    replace [stringlit]\n\t\"\"\n    where not\n\tRAE [?notEmpty]\n    by\n\trestSL\nend function\n\nfunction addAE RAE [repeat assignment_expression]\n    deconstruct RAE\n\tAE [assignment_expression] RestAE [repeat assignment_expression]\n    replace [list putArg]\n\tLPA [list putArg]\n    construct NewPA [putArg]\n\tAE\n    by\n\tLPA [, NewPA]\nend function\n\nfunction getRest RAE [repeat assignment_expression]\n    replace [repeat assignment_expression]\n\tRest [repeat assignment_expression]\n    deconstruct RAE\n\tAE [assignment_expression] RestAE [repeat assignment_expression]\n    by\n\tRestAE\nend function\n\nfunction before SL [stringlit]\n    replace [stringlit]\n\tScope [stringlit]\n    construct N [number]\n\t_ [index Scope SL]\n    construct NewN [number]\n\tN [- 1]\n    by\n\tScope [changeNull N]\n\t      [changeNOTNull 1 NewN]\nend function\n\nfunction after SL [stringlit]\n    replace [stringlit]\n\tScope [stringlit]\n    construct N [number]\n\t_ [index Scope SL]\n    construct NewN [number]\n\tN [+ 1]\n    by\n\tScope [changeNull N]\n\t      [changeNOTNull NewN 9999]\nend function\n\nfunction removeNewline\n    replace * [list putArg]\n\tS [stringlit]\n    by\n\t% nothing\nend function\n\nfunction changeNull N [number]\n    replace [stringlit]\n\tSL [stringlit]\n    where\n\tN [<= 1]\n    by\n\t\"\"\nend function\n\nfunction changeNOTNull N1 [number] N2 [number]\n    replace [stringlit]\n\tSL [stringlit]\n    by\n\tSL [: N1 N2]\nend function\n\n",
        "after": " function maxin (a : array 0..4 of int, n : int) : int\n    var m : int := - 999999999\n    var i : int\n\n    begin\n        i := 0\n        loop\n            exit when not (i < n)\n            if a (i) > m then\n                m := a (i)\n            end if\n            i := i + 1\n        end loop\n    end\n    result m\nend maxin\n\n ",
        "before": "\nint maxin (int a [5], int n) {\n    int m = - 999999999;\n    int i;\n    for (i = 0; i < n; i ++)\n    if (a [i] > m) m = a [i];\n    return m;\n}\n\n "
    }
]